<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<!--Description-->



    <meta name="description" content="Notes of single-chip microcompute, RTOS and Firmware."/>


<!--Author-->

    <meta name="author" content="LuSkywalker"/>


<!--Open Graph Title-->

    <meta property="og:title" content="RT-Thread - SLAB"/>


<!--Open Graph Description-->

    <meta property="og:description" content="Notes of single-chip microcompute, RTOS and Firmware."/>


<!--Open Graph Site Name-->
    <meta property="og:site_name" content="HackTech"/>

<!--Type page-->

    <meta property="og:type" content="article"/>


<!--Page Cover-->


    <meta property="og:image" content="https://blog.lusw.dev/img/home-bg.jpg"/>


<meta name="twitter:card" content="summary_large_image"/>




    <meta name="twitter:image" content="https://blog.lusw.dev/img/home-bg.jpg"/>


<!-- Title -->

<title>RT-Thread - SLAB | HackTech</title>

<!-- Bootstrap Core CSS -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">

<!-- Custom CSS -->

<link rel="stylesheet" href="/css/main.css">


<!-- Custom Fonts -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.0/css/all.min.css" />
<link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.0/css/all.min.css" />
<link href="//fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
<link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<!-- Gallery -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/featherlight@1.4.0/src/featherlight.css" integrity="sha256-30DV/STftlyQ6v8yaOWlabammvCYtRJERLj/m0b3zno=" crossorigin="anonymous">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/lightgallery@1.6.11/dist/css/lightgallery.min.css">

<!-- favicon -->

<link rel="icon" href="/img/favicon.png"/>



    <!-- Google Analytics -->
    
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-73LPFQQS33"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-73LPFQQS33');
</script>



<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="HackTech" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<!-- Head tag -->

<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top bg-transparent position-absolute w-100 p-0" id="nav">
    <div class="container pl-0 pr-0">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <a class="navbar-brand text-white p-1 pl-3" href="/">LuSkywalker</a>
        </div>
        <div class="navbar-nav float-right">
            <button class="btn btn-link search-btn navbar-item" data-toggle="modal" data-target="#searchModal">
                <i class="fas fa-search"></i>
            </button>
        </div>
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 col-md-12 text-center">
                <div class="post-heading text-white">
                    <h1>RT-Thread - SLAB</h1>
                    
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Main Content -->
            <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
                
                    <span class="meta d-inline-block">
    
        <i class="far fa-bookmark fa-fw"></i>
        

<a href="/categories/RT-Thread/">RT-Thread</a>

    
    
    <!-- Date -->
    
        <span class="post-meta-split">&nbsp;|&nbsp;</span>
        <i class="far fa-calendar-check fa-fw"></i>
        2018-12-05
    
    <!-- word count and read count -->
    
        <span class="post-meta-split">&nbsp;|&nbsp;</span>
        <i class="far fa-file-word fa-fw"></i>
        3.6k
    

    

    
</span>  
                
                <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SLAB</code></p>
</blockquote>
<p>SLAB 將記憶體根據不同的對象切成不同的區 (zone)，對象通常是大小，也可看成是一個 zone 代表一個 pool，不同的 zone 放在一個 array 管理。</p>
<p>一個 zone 大小介於 32kB~128kB 之間，最多可以有 72 種 zone；zone 對象大小上上限 16kB，超過由頁分配器分配</p>
<ul>
<li>alloc：根據需要的大小，找到對應的 zone 取得記憶體；如假設需要 32kB，我們去尋找對象為 32kB 的 zone。
<ul>
<li>若是該 zone 為空（找不到），直接向頁分配器分配一個新的 zone，取得第一塊 free chunk</li>
<li>若非空，直接取得第一塊，如果拿完該 zone 已經沒有 free chunk 頁分配器須將此 zone 刪除</li>
</ul>
</li>
<li>free：找到對應的 zone 插入至 free list，如果該 zone 的所有 free chunk 都已經釋放完畢，則須將此 zone 整個釋放到分配器裡</li>
</ul>
<p><div class="img-item" data-src="https://i.imgur.com/GZdBl7V.png" data-sub-html=".caption"><img src="https://i.imgur.com/GZdBl7V.png" alt="" title="SLAB example"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p>
<hr>
<h2 id="結構-v12">結構<a class="header-anchor" href="#結構-v12">#</a></h2>
<div class="alert alert-success"><p><strong>File:</strong> slab.c</p></div>
<h3 id="Zone">Zone<a class="header-anchor" href="#Zone">#</a></h3>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The IN-BAND zone header is placed at the beginning of each zone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">rt_int32_t</span>  z_magic;        <span class="comment">/* magic number for sanity check */</span></span><br><span class="line">    <span class="type">rt_int32_t</span>  z_nfree;        <span class="comment">/* total free chunks / ualloc space in zone */</span></span><br><span class="line">    <span class="type">rt_int32_t</span>  z_nmax;         <span class="comment">/* maximum free chunks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> *<span class="title">z_next</span>;</span>   <span class="comment">/* zoneary[] link if z_nfree non-zero */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  *z_baseptr;     <span class="comment">/* pointer to start of chunk array */</span></span><br><span class="line">    <span class="type">rt_int32_t</span>  z_uindex;       <span class="comment">/* current initial allocation index */</span></span><br><span class="line">    <span class="type">rt_int32_t</span>  z_chunksize;    <span class="comment">/* chunk size for validation */</span></span><br><span class="line">    <span class="type">rt_int32_t</span>  z_zoneindex;    <span class="comment">/* zone index */</span></span><br><span class="line">    slab_chunk  *z_freechunk;   <span class="comment">/* free chunk list */</span></span><br><span class="line">} slab_zone;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Chunk structure for free elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span> *<span class="title">c_next</span>;</span></span><br><span class="line">} slab_chunk;</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="Page-Allocator">Page Allocator<a class="header-anchor" href="#Page-Allocator">#</a></h3>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page allocator */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">next</span>;</span>      <span class="comment">/* next valid page */</span></span><br><span class="line">    <span class="type">rt_size_t</span> page;                 <span class="comment">/* number of page  */</span></span><br><span class="line">    <span class="comment">/* dummy */</span></span><br><span class="line">    <span class="type">char</span> dummy[RT_MM_PAGE_SIZE - (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_page_head *) + <span class="keyword">sizeof</span>(<span class="type">rt_size_t</span>))];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="Descriptor">Descriptor<a class="header-anchor" href="#Descriptor">#</a></h3>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array of descriptors that describe the contents of each page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_TYPE_FREE      0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_TYPE_SMALL     0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_TYPE_LARGE     0x02</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memusage</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> type: <span class="number">2</span> ;       <span class="comment">/* page type */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> size: <span class="number">30</span>;       <span class="comment">/* pages allocated or offset from zone */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="初始化-heap">初始化 heap<a class="header-anchor" href="#初始化-heap">#</a></h2>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化 heap</td>
<td>void</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>*begin_addr</code></th>
<th><code>*end_addr</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>記憶體起始位址</td>
<td>結束位址</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will init system heap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system page</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_system_heap_init</span><span class="params">(<span class="type">void</span> *begin_addr, <span class="type">void</span> *end_addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">rt_uint32_t</span> limsize, npages;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align begin and end addr to page */</span></span><br><span class="line">    heap_start = RT_ALIGN((<span class="type">rt_uint32_t</span>)begin_addr, RT_MM_PAGE_SIZE);</span><br><span class="line">    heap_end   = RT_ALIGN_DOWN((<span class="type">rt_uint32_t</span>)end_addr, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap_start &gt;= heap_end)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"rt_system_heap_init, wrong address[0x%x - 0x%x]\n"</span>,</span><br><span class="line">                   (<span class="type">rt_uint32_t</span>)begin_addr, (<span class="type">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>向上對齊起始位址，向下對其結束位址</li>
<li>檢查是否合法</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line">limsize = heap_end - heap_start;</span><br><span class="line">npages  = limsize / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>計算最大的 size，設定頁數量</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize heap semaphore */</span></span><br><span class="line">rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"heap[0x%x - 0x%x], size 0x%x, 0x%x pages\n"</span>,</span><br><span class="line">                             heap_start, heap_end, limsize, npages));</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化 semaphore，值為 1</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init pages */</span></span><br><span class="line">rt_page_init((<span class="type">void</span> *)heap_start, npages);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化 page</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* calculate zone size */</span></span><br><span class="line">zone_size = ZALLOC_MIN_ZONE_SIZE;</span><br><span class="line"><span class="keyword">while</span> (zone_size &lt; ZALLOC_MAX_ZONE_SIZE &amp;&amp; (zone_size &lt;&lt; <span class="number">1</span>) &lt; (limsize / <span class="number">1024</span>))</span><br><span class="line">    zone_size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">zone_limit = zone_size / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (zone_limit &gt; ZALLOC_ZONE_LIMIT)</span><br><span class="line">    zone_limit = ZALLOC_ZONE_LIMIT;</span><br><span class="line"></span><br><span class="line">zone_page_cnt = zone_size / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>計算 zone 的大小、對象大小的上限及總頁數</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"zone size 0x%x, zone page count 0x%x\n"</span>,</span><br><span class="line">                                 zone_size, zone_page_cnt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate memusage array */</span></span><br><span class="line">    limsize  = npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> memusage);</span><br><span class="line">    limsize  = RT_ALIGN(limsize, RT_MM_PAGE_SIZE);</span><br><span class="line">    memusage = rt_page_alloc(limsize / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"memusage 0x%x, size 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="type">rt_uint32_t</span>)memusage, limsize));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>最後建立一個陣列紀錄頁的資訊</li>
</ul>
<hr>
<h3 id="rt-page-init">rt_page_init<a class="header-anchor" href="#rt-page-init">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化頁分配器</td>
<td>void</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>*addr</code></th>
<th><code>npages</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>存放頁的記憶體位址</td>
<td>頁的總數</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize the page allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rt_page_init</span><span class="params">(<span class="type">void</span> *addr, <span class="type">rt_size_t</span> npages)</span></span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rt_page_list = RT_NULL;</span><br><span class="line">    rt_page_free(addr, npages);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>將 page list 設為空，釋放所有的 page</li>
</ul>
<hr>
<h2 id="分配記憶體-v2">分配記憶體<a class="header-anchor" href="#分配記憶體-v2">#</a></h2>
<h3 id="rt-malloc">rt_malloc<a class="header-anchor" href="#rt-malloc">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>size</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>要求記憶體</td>
<td>記憶體位址</td>
<td>欲要求的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will allocate a block from system heap memory.</span></span><br><span class="line"><span class="comment"> * - If the nbytes is less than zero,</span></span><br><span class="line"><span class="comment"> * or</span></span><br><span class="line"><span class="comment"> * - If there is no nbytes sized memory valid in system,</span></span><br><span class="line"><span class="comment"> * the RT_NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size the size of memory to be allocated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">rt_malloc</span><span class="params">(<span class="type">rt_size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="type">rt_int32_t</span> zi;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero size, return RT_NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果 size = 0，回傳 NULL</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle large allocations directly.  There should not be very many of</span></span><br><span class="line"><span class="comment"> * these so performance is not a big issue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= zone_limit)</span><br><span class="line">{</span><br><span class="line">    size = RT_ALIGN(size, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    chunk = rt_page_alloc(size &gt;&gt; RT_MM_PAGE_BITS);</span><br><span class="line">    <span class="keyword">if</span> (chunk == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果 size 超過一個 chunk 的上限，則透過頁分配器來分配</li>
<li>且如果失敗了，直接回傳 <code>NULL</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set kup */</span></span><br><span class="line">kup = btokup(chunk);</span><br><span class="line">kup-&gt;type = PAGE_TYPE_LARGE;</span><br><span class="line">kup-&gt;size = size &gt;&gt; RT_MM_PAGE_BITS;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>設定頁的資訊：
<ul>
<li>type：<code>PAGE_TYPE_LARGE</code></li>
<li>size：用了幾頁</li>
</ul>
</li>
<li>btokup：<code>&amp;memusage[((rt_uint32_t)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS]</code>
<ul>
<li>找到陣列中與起始位置的差值，位移 12-bit，即除一頁的大小</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"malloc a large memory 0x%x, page cnt %d, kup %d\n"</span>,</span><br><span class="line">                      size,</span><br><span class="line">                      size &gt;&gt; RT_MM_PAGE_BITS,</span><br><span class="line">                      ((<span class="type">rt_uint32_t</span>)chunk - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += size;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>要鎖，更新使用大小，跳到 <code>__done</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock heap */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to allocate out of an existing zone.  First try the free list,</span></span><br><span class="line"><span class="comment"> * then allocate out of unallocated space.  If we find a good zone move</span></span><br><span class="line"><span class="comment"> * it to the head of the list so later allocations find it quickly</span></span><br><span class="line"><span class="comment"> * (we might have thousands of zones in the list).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: zoneindex() will panic of size is too large.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">zi = zoneindex(&amp;size);</span><br><span class="line">RT_ASSERT(zi &lt; NZONES);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果 size 小於一個 chunk 的上限，尋找此大小對應的 zone</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"try to malloc 0x%x on zone: %d\n"</span>, size, zi));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((z = zone_array[zi]) != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(z-&gt;z_nfree &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove us from the zone_array[] when we become empty */</span></span><br><span class="line">    <span class="keyword">if</span> (--z-&gt;z_nfree == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        zone_array[zi] = z-&gt;z_next;</span><br><span class="line">        z-&gt;z_next = RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果該 zone 不為空，且此 zone 剩最後一顆可用時，將此 zone 刪除</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No chunks are available but nfree said we had some memory, so</span></span><br><span class="line"><span class="comment">         * it must be available in the never-before-used-memory area</span></span><br><span class="line"><span class="comment">         * governed by uindex.  The consequences are very serious if our zone</span></span><br><span class="line"><span class="comment">         * got corrupted so we use an explicit rt_kprintf rather then a KASSERT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;z_uindex + <span class="number">1</span> != z-&gt;z_nmax)</span><br><span class="line">        {</span><br><span class="line">            z-&gt;z_uindex = z-&gt;z_uindex + <span class="number">1</span>;</span><br><span class="line">            chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* find on free chunk list */</span></span><br><span class="line">            chunk = z-&gt;z_freechunk;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* remove this chunk from list */</span></span><br><span class="line">            z-&gt;z_freechunk = z-&gt;z_freechunk-&gt;c_next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>取得一塊，跳至 done
<ul>
<li>從 <code>uindex</code> 找，這種方式取得的屬於此 zone 最初的 chunk</li>
<li>如果不行，從 free list 中取得，並從 free list 移除此 chunk；這種的 chunk 是已經被要過，又還回來的</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If all zones are exhausted we need to allocate a new zone for this</span></span><br><span class="line"><span class="comment"> * index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * At least one subsystem, the tty code (see CROUND) expects power-of-2</span></span><br><span class="line"><span class="comment"> * allocations to be power-of-2 aligned.  We maintain compatibility by</span></span><br><span class="line"><span class="comment"> * adjusting the base offset below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">rt_int32_t</span> off;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = zone_free) != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* remove zone from free zone list */</span></span><br><span class="line">        zone_free = z-&gt;z_next;</span><br><span class="line">        -- zone_free_cnt;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果找到的 zone 為空，且 <code>zone_free</code> 不為空：代表有可用的空 zone 可以使用</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* unlock heap, since page allocator will think about lock */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a zone from page */</span></span><br><span class="line">    z = rt_page_alloc(zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (z == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        chunk = RT_NULL;</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>否則需要重新與頁分配器要一個 zone</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"alloc a new zone: 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="type">rt_uint32_t</span>)z));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set message usage */</span></span><br><span class="line">    <span class="keyword">for</span> (off = <span class="number">0</span>, kup = btokup(z); off &lt; zone_page_cnt; off ++)</span><br><span class="line">    {</span><br><span class="line">        kup-&gt;type = PAGE_TYPE_SMALL;</span><br><span class="line">        kup-&gt;size = off;</span><br><span class="line"></span><br><span class="line">        kup ++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著設定每一頁的資訊</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear to zero */</span></span><br><span class="line">rt_memset(z, <span class="number">0</span>, <span class="keyword">sizeof</span>(slab_zone));</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>清空整個 zone</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset of slab zone struct in zone */</span></span><br><span class="line">off = <span class="keyword">sizeof</span>(slab_zone);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Guarentee power-of-2 alignment for power-of-2-sized chunks.</span></span><br><span class="line"><span class="comment"> * Otherwise just 8-byte align the data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((size | (size - <span class="number">1</span>)) + <span class="number">1</span> == (size &lt;&lt; <span class="number">1</span>))</span><br><span class="line">    off = (off + size - <span class="number">1</span>) &amp; ~(size - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    off = (off + MIN_CHUNK_MASK) &amp; ~MIN_CHUNK_MASK;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>計算我們要用的對齊法：
<ul>
<li>如果 size 是二的次方，將 off (zone 的頭) 與 size 向上對齊</li>
<li>否則直接與 8 向上對齊</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br></pre></td><td class="code"><pre><span class="line">z-&gt;z_magic     = ZALLOC_SLAB_MAGIC;</span><br><span class="line">z-&gt;z_zoneindex = zi;</span><br><span class="line">z-&gt;z_nmax      = (zone_size - off) / size;</span><br><span class="line">z-&gt;z_nfree     = z-&gt;z_nmax - <span class="number">1</span>;</span><br><span class="line">z-&gt;z_baseptr   = (<span class="type">rt_uint8_t</span> *)z + off;</span><br><span class="line">z-&gt;z_uindex    = <span class="number">0</span>;</span><br><span class="line">z-&gt;z_chunksize = size;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>設定 magic、對應 <code>zone_array</code> 的 index
<ul>
<li>最大數量為 <code>zone_size</code> - off 再除以一個 chunk 的大小</li>
<li>目前可用的數量則為最大數量減 1，因為待會會拿走一塊</li>
<li>基址為起始位址加上 <code>off，uindex</code> 為 0，這是之後 alloc 時可直接使用這兩個來找到 free chunk</li>
<li>最後設定 chunk size</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">        chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* link to zone array */</span></span><br><span class="line">        z-&gt;z_next = zone_array[zi];</span><br><span class="line">        zone_array[zi] = z;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>拿走第一塊，並將這個 zone 插上對應的 zone array entry</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line">done:</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_malloc_hook, ((<span class="type">char</span> *)chunk, size));</span><br><span class="line"></span><br><span class="line">__exit:</span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>最後回傳找到的 chunk</li>
</ul>
<hr>
<h4 id="zoneindex">zoneindex<a class="header-anchor" href="#zoneindex">#</a></h4>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>*bytes</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>尋找傳入的 size 對應 zone array 的 index</td>
<td>index</td>
<td>傳入的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the zone index for the allocation request size and set the</span></span><br><span class="line"><span class="comment"> * allocation request size to that particular zone's chunk size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rt_inline <span class="type">int</span> <span class="title function_">zoneindex</span><span class="params">(<span class="type">rt_uint32_t</span> *bytes)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* unsigned for shift opt */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> n = (<span class="type">rt_uint32_t</span>) * bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">128</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">7</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 8 byte chunks, 16 zones */</span></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">256</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">15</span>) &amp; ~<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">16</span> + <span class="number">7</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">8192</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">512</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">31</span>) &amp; ~<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">32</span> + <span class="number">15</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1024</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">64</span> + <span class="number">23</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2048</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">127</span>) &amp; ~<span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">128</span> + <span class="number">31</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4096</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">255</span>) &amp; ~<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">256</span> + <span class="number">39</span>);</span><br><span class="line">        }</span><br><span class="line">        *bytes = n = (n + <span class="number">511</span>) &amp; ~<span class="number">511</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">512</span> + <span class="number">47</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">16384</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">1023</span>) &amp; ~<span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">1024</span> + <span class="number">55</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"Unexpected byte count %d"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>根據不同的 range，將傳入的大小對齊，並平均分配每個 range 有 16 個 zone index</p>
<hr>
<h4 id="rt-page-alloc">rt_page_alloc<a class="header-anchor" href="#rt-page-alloc">#</a></h4>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>npages</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>要求頁記憶體</td>
<td>頁</td>
<td>欲要求的頁數</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">rt_page_alloc</span><span class="params">(<span class="type">rt_size_t</span> npages)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (npages == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;page &gt; npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* splite pages */</span></span><br><span class="line">            n       = b + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            n-&gt;page = b-&gt;page - npages;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果找到一個頁數大於需求的，選擇此頁，並分割</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (b-&gt;page == npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* this node fit, remove this node */</span></span><br><span class="line">            *prev = b-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果有一個剛剛好，選擇此頁</li>
<li>最後回傳選擇的頁</li>
</ul>
<hr>
<h3 id="rt-realloc">rt_realloc<a class="header-anchor" href="#rt-realloc">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>增長/縮減記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>*rmem</code></th>
<th><code>newsize</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>欲增長/縮減的記憶體位址</td>
<td>新的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the size of previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the previously allocated memory block</span></span><br><span class="line"><span class="comment"> * @param size the new size of memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">rt_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">rt_size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *nptr;</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果傳入的 <code>ptr</code> 為空，<code>malloc(size)</code></li>
<li>如果傳入的 <code>size</code> 為 0，<code>free(ptr)</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the original allocation's zone.  If the new request winds up</span></span><br><span class="line"><span class="comment"> * using the same chunk size we do not have to do anything.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kup = btokup((<span class="type">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line"><span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">{</span><br><span class="line">    <span class="type">rt_size_t</span> osize;</span><br><span class="line"></span><br><span class="line">    osize = kup-&gt;size &lt;&lt; RT_MM_PAGE_BITS;</span><br><span class="line">    <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    rt_memcpy(nptr, ptr, size &gt; osize ? osize : size);</span><br><span class="line">    rt_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著檢查此 <code>ptr</code> 所在的頁資訊，如果是 LARGE，代表原來的 <code>ptr</code> 是由頁分配器所分配的</li>
<li>新 <code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_SMALL)</span><br><span class="line">{</span><br><span class="line">    z = (slab_zone *)(((<span class="type">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    zoneindex(&amp;size);</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_chunksize == size)</span><br><span class="line">        <span class="keyword">return</span> (ptr); <span class="comment">/* same chunk */</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果是 SMALL，首先找到歸屬得 zone：
<ul>
<li>透過減掉頁資訊上的 size 乘以頁的大小，即可找到zone的初始位址</li>
<li>在 <code>malloc</code> 中，建立 zone 時 size 是從 0 開始填，一頁一頁加一</li>
<li>如果新的大小與原本的 chunk 相同，不做事</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Allocate memory for the new request size.  Note that zoneindex has</span></span><br><span class="line"><span class="comment">         * already adjusted the request size to the appropriate chunk size, which</span></span><br><span class="line"><span class="comment">         * should optimize our bcopy().  Then copy and return the new pointer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">            <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">        rt_memcpy(nptr, ptr, size &gt; z-&gt;z_chunksize ? z-&gt;z_chunksize : size);</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果不同，<code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li>
</ul>
<hr>
<h3 id="rt-calloc">rt_calloc<a class="header-anchor" href="#rt-calloc">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>要求一段連續的記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>count</code></th>
<th><code>size</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>欲要求的數量</td>
<td>一塊的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">rt_calloc</span><span class="params">(<span class="type">rt_size_t</span> count, <span class="type">rt_size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>與 memheap 相同，一次要一塊 <code>count</code> 乘 <code>size</code> 的記憶體</li>
<li>清 0 並回傳起始位址</li>
</ul>
<hr>
<h2 id="釋放記憶體-v2">釋放記憶體<a class="header-anchor" href="#釋放記憶體-v2">#</a></h2>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>*ptr</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>釋放記憶體</td>
<td>void</td>
<td>欲釋放的記憶體</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previous allocated memory block by rt_malloc.</span></span><br><span class="line"><span class="comment"> * The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free a RT_NULL pointer */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_free_hook, (ptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get memory usage */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> RT_DEBUG_SLAB</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">rt_uint32_t</span> addr = ((<span class="type">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free a memory 0x%x and align to 0x%x, kup index %d\n"</span>,</span><br><span class="line">                      (<span class="type">rt_uint32_t</span>)ptr,</span><br><span class="line">                      (<span class="type">rt_uint32_t</span>)addr,</span><br><span class="line">                      ((<span class="type">rt_uint32_t</span>)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    kup = btokup((<span class="type">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">    <span class="comment">/* release large allocation */</span></span><br><span class="line">    <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">rt_uint32_t</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">/* clear page counter */</span></span><br><span class="line">        size = kup-&gt;size;</span><br><span class="line">        kup-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= size * RT_MM_PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free large memory block 0x%x, page count %d\n"</span>,</span><br><span class="line">                      (<span class="type">rt_uint32_t</span>)ptr, size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free this page */</span></span><br><span class="line">        rt_page_free(ptr, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果要釋放的記憶體是由頁分配器分配的，根據頁資訊中的 size 來釋放，並清 0</li>
<li>實際呼叫 <code>rt_page_free(ptr, size)</code> 來完成</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone case. get out zone. */</span></span><br><span class="line">    z = (slab_zone *)(((<span class="type">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    chunk          = (slab_chunk *)ptr;</span><br><span class="line">    chunk-&gt;c_next  = z-&gt;z_freechunk;</span><br><span class="line">    z-&gt;z_freechunk = chunk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= z-&gt;z_chunksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果是由 zone 分配，找到歸屬的 zone，並將需要釋放的 chunk 插到 free list 上</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bump the number of free chunks.  If it becomes non-zero the zone</span></span><br><span class="line"><span class="comment"> * must be added back onto the appropriate list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree++ == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    z-&gt;z_next = zone_array[z-&gt;z_zoneindex];</span><br><span class="line">    zone_array[z-&gt;z_zoneindex] = z;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>更新 <code>nfree</code>，如果本來為 0 ，則需要將此 zone 插回 zone array</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the zone becomes totally free, and there are other zones we</span></span><br><span class="line"><span class="comment"> * can allocate from, move this zone to the FreeZones list.  Since</span></span><br><span class="line"><span class="comment"> * this code can be called from an IPI callback, do *NOT* try to mess</span></span><br><span class="line"><span class="comment"> * with kernel_map here.  Hysteresis will be performed at malloc() time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree == z-&gt;z_nmax &amp;&amp;</span><br><span class="line">    (z-&gt;z_next || zone_array[z-&gt;z_zoneindex] != z))</span><br><span class="line">{</span><br><span class="line">    slab_zone **pz;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"free zone 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="type">rt_uint32_t</span>)z, z-&gt;z_zoneindex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove zone from zone array list */</span></span><br><span class="line">    <span class="keyword">for</span> (pz = &amp;zone_array[z-&gt;z_zoneindex]; z != *pz; pz = &amp;(*pz)-&gt;z_next)</span><br><span class="line">        ;</span><br><span class="line">    *pz = z-&gt;z_next;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果釋放完這個 chunk 後整個 zone 都釋放完了，我們需要釋放整個 zone</li>
<li>這裡還同時確保在同一個 zone array entry 中還有其他的 zone 可以分配</li>
<li>接著我們把這個 zone 從 zone array 移除</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset zone */</span></span><br><span class="line">z-&gt;z_magic = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* insert to free zone list */</span></span><br><span class="line">z-&gt;z_next = zone_free;</span><br><span class="line">zone_free = z;</span><br><span class="line"></span><br><span class="line">++ zone_free_cnt;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>重設 magic，將這個 zone 插上 free zone，free count 加一</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release zone to page allocator */</span></span><br><span class="line">        <span class="keyword">if</span> (zone_free_cnt &gt; ZONE_RELEASE_THRESH)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">register</span> <span class="type">rt_base_t</span> i;</span><br><span class="line"></span><br><span class="line">            z         = zone_free;</span><br><span class="line">            zone_free = z-&gt;z_next;</span><br><span class="line">            -- zone_free_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set message usage */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, kup = btokup(z); i &lt; zone_page_cnt; i ++)</span><br><span class="line">            {</span><br><span class="line">                kup-&gt;type = PAGE_TYPE_FREE;</span><br><span class="line">                kup-&gt;size = <span class="number">0</span>;</span><br><span class="line">                kup ++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* unlock heap */</span></span><br><span class="line">            rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* release pages */</span></span><br><span class="line">            rt_page_free(z, zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果已經有 <code>ZONE_RELEASE_THRESH</code> (2) 個以上的 free zone，完全釋放一個 zone 給頁分配器
<ul>
<li>從 free zone 中移除，free count 減一</li>
<li>重設頁資訊：type free、size 0</li>
<li>透過 <code>rt_page_free</code> 完成</li>
</ul>
</li>
</ul>
<hr>
<h3 id="rt-page-free">rt_page_free<a class="header-anchor" href="#rt-page-free">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>釋放頁記憶體</td>
<td>void</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>*addr</code></th>
<th><code>pages</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>欲釋放的頁</td>
<td>欲釋放的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_page_free</span><span class="params">(<span class="type">void</span> *addr, <span class="type">rt_size_t</span> npages)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT((<span class="type">rt_uint32_t</span>)addr % RT_MM_PAGE_SIZE == <span class="number">0</span>);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line">    n = (<span class="keyword">struct</span> rt_page_head *)addr;</span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        RT_ASSERT(b-&gt;page &gt; <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT(b &gt; n || b + b-&gt;page &lt;= n);</span><br><span class="line">        <span class="keyword">if</span> (b + b-&gt;page == n)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (b + (b-&gt;page += npages) == b-&gt;next)</span><br><span class="line">            {</span><br><span class="line">                b-&gt;page += b-&gt;next-&gt;page;</span><br><span class="line">                b-&gt;next  = b-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b == n + npages)</span><br><span class="line">        {</span><br><span class="line">            n-&gt;page = b-&gt;page + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b &gt; n + npages)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    n-&gt;page = npages;</span><br><span class="line">    n-&gt;next = b;</span><br><span class="line">    *prev   = n;</span><br><span class="line">_return:</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
            </div>

            <!-- Post information -->
            
    <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 post-tags">
        
            <i class="fas fa-tag" style="vertical-align: middle;font-size: .8rem;"></i>
            tags:&nbsp;
            
            
        
            <a href="/tags/kernel/">#kernel</a> <a href="/tags/RT-Thread/">#RT-Thread</a> <a href="/tags/MemMan/">#記憶體管理</a>
        
    </div>

            
    <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
        <ul class="pagination d-block text-center">
            
                <li class="previous page-item d-inline"><a href="/posts/hexo/custom-domain.html" class="page-link float-left">&larr;  下一頁</a></li>
            
            
                <li class="next page-item d-inline"><a href="/posts/rt-thread/small-mem.html" class="page-link float-right">上一頁  &rarr;</a></li>
            
        </ul>
    </div>


            
                <!-- Comments -->
                
    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    
    <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
        <div id="gitalk-container"></div>
    </div>

    <script>
        let gitalk = new Gitalk({
            clientID: '97c34b7bba491c6a5007',
            clientSecret: '6140d208bae6bbbc69c65e3e332a46d090094fc8',
            repo: 'HackTech',
            owner: 'luswdev',
            admin: "luswdev",
            id: '2018-12-05 15:42:50',
            title: 'RT-Thread - SLAB',
            distractionFreeMode: false  // Facebook-like distraction free mode
        });
        gitalk.render('gitalk-container');
    </script>


                

            

        </div>
    </div>
</article> 


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    <style>
        #toc-content .toc-link::before {
            background-color: transparent;
            max-height: 25px;
        }

        #toc-content .toc-link.is-active-link::before {
            background-color: #404040;
        }
    </style>
    <script src="//cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <div class="ui-toc dropup scrollspy-body pull-right" style="right: 3%;">
        <button type="button" class="toc-btn btn btn-light" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" data-display="static">
            <i class="fas fa-list"></i>
        </button>
        <div class="dropdown-menu dropdown-menu-right p-2"  aria-labelledby="tocLabel">
            <div class="toc-widget">
                <div id="toc-content" class="text-truncate">
                </div>
            </div>
            <div class="toc-menu pt-3 pl-4">
                <a class="expand-toggle d-block py-1" href="#"><span class="expand-text">全部展開</span><span class="close-text" style="display: none;">全部收起</span></a>
                <a class="back-to-top d-block py-1" href="#">回到頂部</a>
                <a class="go-to-bottom d-block py-1" href="#">移至底部</a>
            </div>
        </div>
    </div>
    <script>
        tocbot.init({
            // Where to render the table of contents.
            tocSelector: '#toc-content',
            // Where to grab the headings to build the table of contents.
            contentSelector: 'article',
            // Which headings to grab inside of the contentSelector element.
            headingSelector: 'h1, h2, h3',
            // For headings inside relative or absolute positioned containers within content.
            hasInnerContainers: true,
        });
    </script>


    


    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer id="footer">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 text-center">
                <ul class="list-inline">
                    

                    

                    
                        <li class="list-inline-item">
                            <a rel="external" href="https://github.com/luswdev" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                        <li class="list-inline-item">
                            <a rel="external" href="https://www.linkedin.com/in/callum-lu" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                        <li class="list-inline-item">
                            <a rel="external" href="mailto:info@lusw.dev" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <ul class="copyright footer-menu list-inline">
                    
                    
                        <li class="list-inline-item">
                            
                            
                            <a href="/">
                                
                                    Home
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/archives">
                                
                                    Archives
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/tags">
                                
                                    Tags
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/categories">
                                
                                    Categories
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/about">
                                
                                    About
                                
                            </a>
                        </li>
                    
                </ul>
                <p class="copyright footer-author">
                    &copy; 2018-2022 
                    <a rel="external" class="copyright-link" href="https://github.com/luswdev" target="_blank">LuSkywalker</a><br/>
                    Powered by <a rel="external" class="copyright-link" href="https://hexo.io/" target="_blank">Hexo</a>  
                    <span class="copyright-split">&nbsp;|&nbsp;&nbsp;</span>
                    Theme <a rel="external" class="copyright-link" href="https://github.com/luswdev/hexo-theme-clean.git" target="_blank">Clean</a>
                    
                    
                </p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    <!-- jQuery -->
<script src="//cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js"></script>

<!-- For drop down -->
<script src="//cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>

<!-- Bootstrap -->
<script src="//cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/js/bootstrap.min.js"></script>
<!-- Gallery -->
<script src="//cdn.jsdelivr.net/npm/lightgallery@1.6.11/dist/js/lightgallery-all.min.js"></script>
<!-- Busuanzi -->


<!-- Search script -->

<script src="/js/search.js"></script>

<script type="text/javascript">
    $(function () {
        searchFunc( '/search.xml' , 'searchInput', 'searchResult');
    });
</script>



<script src="/js/main.js"></script>



    <!-- Search Modal -->
    <!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
    <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
        <div class="modal-content overflow-auto">
            <div class="modal-header">
                <input type="text" class="form-control" placeholder="搜尋關鍵字..." id="searchInput">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-body">
                <div id="searchResult">
                    <div class="search-empty text-center text-muted p-5">
                        <i class="far fa-meh"></i>
                    </div>
                </div>
            </div> 
        </div>
    </div>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>