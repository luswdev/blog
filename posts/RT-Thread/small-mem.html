<!DOCTYPE html>
<html lang="zh-TW">
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!--Description-->



    <meta name="description" content="Notes of single-chip microcompute, RTOS and Firmware.">


<!--Author-->

    <meta name="author" content="LuSkywalker">


<!--Open Graph Title-->

    <meta property="og:title" content="RT-Thread - Small Memory Manager">


<!--Open Graph Description-->

    <meta property="og:description" content="Notes of single-chip microcompute, RTOS and Firmware.">


<!--Open Graph Site Name-->
    <meta property="og:site_name" content="HackTech">

<!--Type page-->

    <meta property="og:type" content="article">


<!--Page Cover-->


    <meta property="og:image" content="https://blog.lusw.dev/img/home-bg.jpg">


<meta name="twitter:card" content="summary_large_image">




    <meta name="twitter:image" content="https://blog.lusw.dev/img/home-bg.jpg">


<!-- Title -->

<title>RT-Thread - Small Memory Manager | HackTech</title>

<!-- Bootstrap Core CSS -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">

<!-- Custom CSS -->
<link rel="stylesheet" href="/css/main.css">

<!-- Custom Fonts -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.0/css/all.min.css">
<link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.0/css/all.min.css">
<link href="//fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
<link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<!-- Gallery -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/featherlight@1.4.0/src/featherlight.css" integrity="sha256-30DV/STftlyQ6v8yaOWlabammvCYtRJERLj/m0b3zno=" crossorigin="anonymous">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/lightgallery@1.6.11/dist/css/lightgallery.min.css">

<!-- favicon -->

<link rel="icon" href="/img/favicon.png">



    <!-- Google Analytics -->
    
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-73LPFQQS33"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-73LPFQQS33');
</script>



<link rel="alternate" href="/atom.xml" title="HackTech" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<!-- Head tag -->

<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top bg-transparent position-absolute w-100 p-0" id="nav">
    <div class="container pl-0 pr-0">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <a class="navbar-brand text-white p-1 pl-3" href="/">LuSkywalker</a>
        </div>
        <div class="navbar-nav float-right">
            <button class="btn btn-link search-btn navbar-item" data-toggle="modal" data-target="#searchModal">
                <i class="fas fa-search"></i>
            </button>
        </div>
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 col-md-12 text-center">
                <div class="post-heading text-white">
                    <h1>RT-Thread - Small Memory Manager</h1>
                    
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Main Content -->
            <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
                
                    <span class="meta d-inline-block">
    
        <i class="far fa-bookmark fa-fw"></i>
        

<a href="/categories/RT-Thread/">RT-Thread</a>

    
    
    <!-- Date -->
    
        <span class="post-meta-split">&nbsp;|&nbsp;</span>
        <i class="far fa-calendar-check fa-fw"></i>
        2018-12-05
    
    <!-- word count and read count -->
    
        <span class="post-meta-split">&nbsp;|&nbsp;</span>
        <i class="far fa-file-word fa-fw"></i>
        2.8k
    

    

    
</span>  
                
                <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SMALL_MEM</code></p>
</blockquote>
<ul>
<li>與 memory heap 的做法類似，一開始是一塊大的記憶體，包含 header</li>
<li>分配記憶體時適當的切割</li>
<li>所有的記憶體塊透過 header 串起來，形成一個雙向鏈結</li>
</ul>
<p><div class="img-item" data-src="https://i.imgur.com/tbptSYO.png" data-sub-html=".caption"><img src="https://i.imgur.com/tbptSYO.png" alt title="small memory example"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p>
<hr>
<h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2>
<div class="alert alert-success"><p><strong>File:</strong> mem.c</p></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* magic and used flag */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> magic;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> next, prev;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> thread[<span class="number">4</span>];   <span class="comment">/* thread name */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>此結構即為一個記憶體塊的 header</li>
<li>包含了
<ul>
<li>magic 碼 <code>0x1ea0</code></li>
<li>使用中標記</li>
<li>前一顆與下一顆</li>
<li>使用此記憶體的 thread 名稱（選）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="初始化-heap">初始化 heap<a class="header-anchor" href="#初始化-heap">#</a></h2>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化 heap</td>
<td>void</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>*begin_addr</code></th>
<th><code>*end_addr</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>記憶體起始位址</td>
<td>結束位址</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will initialize system heap memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system heap memory.</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system heap memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> begin_align = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> end_align = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>向上對齊起始位址與向下對齊結束位址</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alignment addr */</span></span><br><span class="line"><span class="keyword">if</span> ((end_align &gt; (<span class="number">2</span> * SIZEOF_STRUCT_MEM)) &amp;&amp;</span><br><span class="line">    ((end_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM) &gt;= begin_align))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* calculate the aligned memory size */</span></span><br><span class="line">    mem_size_aligned = end_align - begin_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"mem init, error begin address 0x%x, and end address 0x%x\n"</span>,</span><br><span class="line">               (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著檢查起始與結束位址是否合法</li>
<li>如果合法，給定 <code>mem_size</code> 為結束位址 - 起始位址 - 2 倍的 <code>struct mem</code> 大小</li>
<li>也就是與 <code>mem_heap</code> 相同，一開始的記憶體設定為一大塊，頭與尾都要有一個 header</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to begin address of heap */</span></span><br><span class="line">heap_ptr = (<span class="keyword">rt_uint8_t</span> *)begin_align;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"mem init, heap begin address 0x%x, size %d\n"</span>,</span><br><span class="line">                            (<span class="keyword">rt_uint32_t</span>)heap_ptr, mem_size_aligned));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the start of the heap */</span></span><br><span class="line">mem        = (struct heap_mem *)heap_ptr;</span><br><span class="line">mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line">mem-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">mem-&gt;prev  = <span class="number">0</span>;</span><br><span class="line">mem-&gt;used  = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著設定前面的 header：
<ul>
<li>設定 magic 碼</li>
<li>下一塊為結尾的 header</li>
<li>上一塊為自己</li>
<li>以及沒有使用過</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the end of the heap */</span></span><br><span class="line">    heap_end        = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    heap_end-&gt;magic = HEAP_MAGIC;</span><br><span class="line">    heap_end-&gt;used  = <span class="number">1</span>;</span><br><span class="line">    heap_end-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">    heap_end-&gt;prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(heap_end, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著設定結尾的 header
<ul>
<li>magic 碼</li>
<li>已被使用過</li>
<li>上一塊與下一塊指向自己</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the lowest-free pointer to the start of the heap */</span></span><br><span class="line">    lfree = (struct heap_mem *)heap_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>最後初始化 semaphore</li>
<li>把這一塊掛上 <code>lfree</code></li>
</ul>
<hr>
<h2 id="分配記憶體">分配記憶體<a class="header-anchor" href="#分配記憶體">#</a></h2>
<h3 id="Code-rt-malloc">Code: rt_malloc<a class="header-anchor" href="#Code-rt-malloc">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>size</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>要求記憶體</td>
<td>記憶體位址</td>
<td>欲要求的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a block of memory with a minimum of 'size' bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size is the minimum size of the requested block in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory or NULL if no free memory was found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果 <code>size</code> 為 0，回傳 NULL</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != RT_ALIGN(size, RT_ALIGN_SIZE))</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d, but align to %d\n"</span>,</span><br><span class="line">                                size, RT_ALIGN(size, RT_ALIGN_SIZE)));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d\n"</span>, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alignment size */</span></span><br><span class="line">size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; mem_size_aligned)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"no memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>向上對齊 <code>size</code>，如果超過可用大小，回傳 NULL</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* every data block must be at least MIN_SIZE_ALIGNED long */</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; MIN_SIZE_ALIGNED)</span><br><span class="line">    size = MIN_SIZE_ALIGNED;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果小於 min size，設為 min size</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* take memory semaphore */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>取得 semaphore</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr = (<span class="keyword">rt_uint8_t</span> *)lfree - heap_ptr;</span><br><span class="line">     ptr &lt; mem_size_aligned - size;</span><br><span class="line">     ptr = ((struct heap_mem *)&amp;heap_ptr[ptr])-&gt;next)</span><br><span class="line">{</span><br><span class="line">    mem = (struct heap_mem *)&amp;heap_ptr[ptr];</span><br></pre></td></tr></tbody></table></figure>
<div class="alert alert-info"><p>這裡特別的說明一下 for 迴圈：<br>
首先起點是 <code>lfree</code> - <code>heap_ptr</code>，這裡代表最左邊的 free block 與 heap 起點的距離。 我們把 <code>heap_ptr</code> 看成是一個 <code>rt_uint8_t</code> 的陣列，也就是一格一個 byte 的陣列。 再來把 <code>lfree</code> - <code>heap_ptr</code> 看成是差量 (offset)，單位是 byte。 如此一來，<code>&amp;heap_ptr[ptr]</code> 就會是 <code>lfree</code> 的起始位置了。</p>
<p>再來我們看 <code>next</code>，在初始化的時候，<code>next</code> 是指向 0，這個意思是下一顆在陣列的第 0 個，也就是自己；所以 <code>next</code> 存放的是下一顆的 index，而不是起始位置。</p>
<p>最後來看上界，理論上我們需要從 lfree 找到最後一顆，實際上如果最後幾顆不夠大的話是不需要檢查的，所以這裡上界設在 <code>mem_size_aligned</code> - <code>size</code> 的意思就是說如果最後幾顆的大小總和不夠大，我們可以略過。</p></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!mem-&gt;used) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mem is not used and at least perfect fit is possible:</span></span><br><span class="line"><span class="comment">     * mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>first fit，如果找到第一顆可用的就進去</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;=</span><br><span class="line">    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))</span><br><span class="line">{</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>又，如果這顆夠大到可以切割的話</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing</span></span><br><span class="line"><span class="comment">                 * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')</span></span><br><span class="line"><span class="comment">                 * -&gt; split large block, create empty remainder,</span></span><br><span class="line"><span class="comment">                 * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if</span></span><br><span class="line"><span class="comment">                 * mem-&gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,</span></span><br><span class="line"><span class="comment">                 * struct heap_mem would fit in but no data between mem2 and mem2-&gt;next</span></span><br><span class="line"><span class="comment">                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty</span></span><br><span class="line"><span class="comment">                 *       region that couldn't hold data, but when mem-&gt;next gets freed,</span></span><br><span class="line"><span class="comment">                 *       the 2 regions would be combined, resulting in more free memory</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* create mem2 struct */</span></span><br><span class="line">                mem2       = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">                mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">                mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">                mem2-&gt;next = mem-&gt;next;</span><br><span class="line">                mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">                rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>設定下一顆的資料，同時把 <code>next</code> 與 <code>prev</code> 接到正確位置</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* and insert it between mem and mem-&gt;next */</span></span><br><span class="line">mem-&gt;next = ptr2;</span><br><span class="line">mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">{</span><br><span class="line">    ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著把原本那塊的 <code>next</code> 指向新的那塊，設為使用中</li>
<li>如果新的那塊 <code>next</code> 不是最後一塊，設定 <code>prev</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += (size + SIZEOF_STRUCT_MEM);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>最後更新 <code>used_mem</code> 與 <code>max_mem</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* (a mem2 struct does no fit into the user data space of mem and mem-&gt;next will always</span></span><br><span class="line"><span class="comment">                 * be used at this point: if not we have 2 unused structs in a row, plug_holes should have</span></span><br><span class="line"><span class="comment">                 * take care of this).</span></span><br><span class="line"><span class="comment">                 * -&gt; near fit or excact fit: do not split, no mem2 creation</span></span><br><span class="line"><span class="comment">                 * also can't move mem-&gt;next directly behind mem, since mem-&gt;next</span></span><br><span class="line"><span class="comment">                 * will always be used at this point!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果不可切割，只需設定使用中即可</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* set memory block magic */</span></span><br><span class="line">            mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">            <span class="keyword">if</span> (rt_thread_self())</span><br><span class="line">                rt_mem_setname(mem, rt_thread_self()-&gt;name);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rt_mem_setname(mem, <span class="string">"NONE"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mem == lfree)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* Find next free block after mem and update lowest free pointer */</span></span><br><span class="line">                <span class="keyword">while</span> (lfree-&gt;used &amp;&amp; lfree != heap_end)</span><br><span class="line">                    lfree = (struct heap_mem *)&amp;heap_ptr[lfree-&gt;next];</span><br><span class="line"></span><br><span class="line">                RT_ASSERT(((lfree == heap_end) || (!lfree-&gt;used)));</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>視情況更新 <code>lfree</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)mem + SIZEOF_STRUCT_MEM + size &lt;= (<span class="keyword">rt_uint32_t</span>)heap_end);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)mem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">                     (<span class="string">"allocate memory at 0x%x, size: %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM),</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_malloc_hook,</span><br><span class="line">                            (((<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM)), size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* return the memory data except mem struct */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>還鎖，並回傳找到的記憶體位址</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>沒找到一樣還鎖，並回傳 NULL</li>
</ul>
<hr>
<h3 id="Code-rt-realloc">Code: rt_realloc<a class="header-anchor" href="#Code-rt-realloc">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>增長/縮減記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>*rmeme</code></th>
<th><code>newsize</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>欲增長/縮減的記憶體位址</td>
<td>新的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem pointer to memory allocated by rt_malloc</span></span><br><span class="line"><span class="comment"> * @param newsize the required new size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the changed memory block address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *nmem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alignment size */</span></span><br><span class="line">    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (newsize &gt; mem_size_aligned)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"realloc: out of memory\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>向上對齊 size，如果：
<ul>
<li>大於可用大小，回傳 NULL</li>
<li>等於 0，free 記憶體，回傳 NULL</li>
</ul>
</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate a new memory block */</span></span><br><span class="line"><span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">    <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如原來的記憶體為空，直接 <code>malloc</code>，並回傳</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* illegal memory */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著取得鎖，檢查傳入的記憶體是否合法</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br><span class="line"></span><br><span class="line">ptr = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">size = mem-&gt;next - ptr - SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="keyword">if</span> (size == newsize)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* the size is the same as */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>找到記憶體塊的起始位址，算出 size，如果記憶體大小不需要變動，不做事，回傳原本的記憶體位址</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* split memory block */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= (size - newsize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;</span><br><span class="line">        mem2 = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">        mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">        mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">        mem2-&gt;next = mem-&gt;next;</span><br><span class="line">        mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">        rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        mem-&gt;next = ptr2;</span><br><span class="line">        <span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">        {</span><br><span class="line">            ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果可以切割，與上面的動作相同</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">    plug_holes(mem2);</span><br><span class="line"></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>plug_holes</code> 來合併 free block</li>
<li>還鎖，回傳更新後的記憶體位置</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand memory */</span></span><br><span class="line">    nmem = rt_malloc(newsize);</span><br><span class="line">    <span class="keyword">if</span> (nmem != RT_NULL) <span class="comment">/* check memory */</span></span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(nmem, rmem, size &lt; newsize ? size : newsize);</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果不可切割，或是需要增長，直接要一塊 new size，釋放原本的記憶體</li>
<li>最後回傳新的記憶體位址</li>
</ul>
<hr>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>*mem</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>合併 free block</td>
<td>void</td>
<td>欲合併的記憶體位址</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">plug_holes</span><span class="params">(struct heap_mem *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">nmem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">pmem</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &gt;= heap_ptr);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line">    RT_ASSERT(mem-&gt;used == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* plug hole forward */</span></span><br><span class="line">    nmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    <span class="keyword">if</span> (mem != nmem &amp;&amp;</span><br><span class="line">        nmem-&gt;used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">rt_uint8_t</span> *)nmem != (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;next is unused and not end of heap_ptr,</span></span><br><span class="line"><span class="comment">         * combine mem and mem-&gt;next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == nmem)</span><br><span class="line">        {</span><br><span class="line">            lfree = mem;</span><br><span class="line">        }</span><br><span class="line">        mem-&gt;next = nmem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[nmem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果可以與下一顆合併</li>
<li>檢查是否需要更新 <code>lfree</code></li>
<li>重新接上 <code>next</code> 與 <code>prev</code> (<code>next</code> 的 <code>prev</code>)</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* plug hole backward */</span></span><br><span class="line">    pmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;prev];</span><br><span class="line">    <span class="keyword">if</span> (pmem != mem &amp;&amp; pmem-&gt;used == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;prev is unused, combine mem and mem-&gt;prev */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == mem)</span><br><span class="line">        {</span><br><span class="line">            lfree = pmem;</span><br><span class="line">        }</span><br><span class="line">        pmem-&gt;next = mem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[mem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)pmem - heap_ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果可以與上一顆合併，動作一樣</li>
</ul>
<hr>
<h3 id="Code-rt-calloc">Code: rt_calloc<a class="header-anchor" href="#Code-rt-calloc">#</a></h3>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
</tr>
</thead>
<tbody>
<tr>
<td>要求一段連續的記憶體</td>
<td>記憶體位址</td>
</tr>
</tbody>
</table></div>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th><code>count</code></th>
<th><code>size</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>欲要求的數量</td>
<td>一塊的大小</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>與 memheap 相同，一次要一塊 count 乘 size 的記憶體</li>
<li>清 0 並回傳起始位址</li>
</ul>
<hr>
<h2 id="釋放記憶體">釋放記憶體<a class="header-anchor" href="#釋放記憶體">#</a></h2>
<div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>功能</th>
<th>回傳值</th>
<th><code>*rmem</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>釋放記憶體</td>
<td>void</td>
<td>欲釋放的記憶體</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previously allocated memory block by</span></span><br><span class="line"><span class="comment"> * rt_malloc. The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果需要釋放得記憶體為空，不做事</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)rmem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_ptr &amp;&amp;</span><br><span class="line">          (<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"illegal memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the corresponding struct heap_mem ... */</span></span><br><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>檢查記憶體位址是否合法，並找到真正的記憶體區塊位址</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">             (<span class="string">"release memory 0x%x, size: %d\n"</span>,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)rmem,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* protect the heap from concurrent access */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... which has to be in a used state ... */</span></span><br><span class="line"><span class="keyword">if</span> (!mem-&gt;used || mem-&gt;magic != HEAP_MAGIC)</span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"to free a bad data block:\n"</span>);</span><br><span class="line">    rt_kprintf(<span class="string">"mem: 0x%08x, used flag: %d, magic code: 0x%04x\n"</span>, mem, mem-&gt;used, mem-&gt;magic);</span><br><span class="line">}</span><br><span class="line">RT_ASSERT(mem-&gt;used);</span><br><span class="line">RT_ASSERT(mem-&gt;magic == HEAP_MAGIC);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>要鎖，檢查是否是使用中的區塊，及是否屬於 heap</li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* ... and is now unused. */</span></span><br><span class="line">    mem-&gt;used  = <span class="number">0</span>;</span><br><span class="line">    mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem &lt; lfree)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* the newly freed struct is now the lowest */</span></span><br><span class="line">        lfree = mem;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接著設為可使用，及更新 <code>lfree</code></li>
</ul>
<figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= (mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finally, see if prev or next are free also */</span></span><br><span class="line">    plug_holes(mem);</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>最後合併記憶體塊，並還鎖</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>

            <!-- Post information -->
            
    <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 post-tags">
        
            <i class="fas fa-tag" style="vertical-align: middle;font-size: .8rem;"></i>
            tags:&nbsp;
            
            
        
            <a href="/tags/RT-Thread/">#RT-Thread</a> <a href="/tags/kernel/">#kernel</a> <a href="/tags/MemMan/">#記憶體管理</a>
        
    </div>

            
    <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
        <ul class="pagination d-block text-center">
            
                <li class="previous page-item d-inline"><a href="/posts/RT-Thread/slab.html" class="page-link float-left">&larr;  下一頁</a></li>
            
            
                <li class="next page-item d-inline"><a href="/posts/RT-Thread/memheap.html" class="page-link float-right">上一頁  &rarr;</a></li>
            
        </ul>
    </div>


            
                <!-- Comments -->
                
    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    
    <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
        <div id="gitalk-container"></div>
    </div>

    <script>
        let gitalk = new Gitalk({
            clientID: '97c34b7bba491c6a5007',
            clientSecret: '6140d208bae6bbbc69c65e3e332a46d090094fc8',
            repo: 'HackTech',
            owner: 'luswdev',
            admin: "luswdev",
            id: '2018-12-05 15:42:44',
            title: 'RT-Thread - Small Memory Manager',
            distractionFreeMode: false  // Facebook-like distraction free mode
        });
        gitalk.render('gitalk-container');
    </script>


                

            

        </div>
    </div>
</article> 


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    <style>
        #toc-content .toc-link::before {
            background-color: transparent;
            max-height: 25px;
        }

        #toc-content .toc-link.is-active-link::before {
            background-color: #404040;
        }
    </style>
    <script src="//cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <div class="ui-toc dropup scrollspy-body pull-right" style="right: 3%;">
        <button type="button" class="toc-btn btn btn-light" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" data-display="static">
            <i class="fas fa-list"></i>
        </button>
        <div class="dropdown-menu dropdown-menu-right p-2" aria-labelledby="tocLabel">
            <div class="toc-widget">
                <div id="toc-content" class="text-truncate">
                </div>
            </div>
            <div class="toc-menu pt-3 pl-4">
                <a class="expand-toggle d-block py-1" href="#"><span class="expand-text">全部展開</span><span class="close-text" style="display: none;">全部收起</span></a>
                <a class="back-to-top d-block py-1" href="#">回到頂部</a>
                <a class="go-to-bottom d-block py-1" href="#">移至底部</a>
            </div>
        </div>
    </div>
    <script>
        tocbot.init({
            // Where to render the table of contents.
            tocSelector: '#toc-content',
            // Where to grab the headings to build the table of contents.
            contentSelector: 'article',
            // Which headings to grab inside of the contentSelector element.
            headingSelector: 'h1, h2, h3',
            // For headings inside relative or absolute positioned containers within content.
            hasInnerContainers: true,
        });
    </script>


    


    <!-- Footer -->
    <hr>

<!-- Footer -->
<footer id="footer">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 text-center">
                <ul class="list-inline">
                    

                    

                    
                        <li class="list-inline-item">
                            <a rel="external" href="https://github.com/luswdev" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                        <li class="list-inline-item">
                            <a rel="external" href="https://www.linkedin.com/in/callum-lu" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                        <li class="list-inline-item">
                            <a rel="external" href="mailto:info@lusw.dev" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <ul class="copyright footer-menu list-inline">
                    
                    
                        <li class="list-inline-item">
                            
                            
                            <a href="/">
                                
                                    Home
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/archives">
                                
                                    Archives
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/tags">
                                
                                    Tags
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/categories">
                                
                                    Categories
                                
                            </a>
                        </li>
                    
                        <li class="list-inline-item">
                            
                                <span class="copyright-split">&nbsp;|&nbsp;</span>
                            
                            
                            <a href="/about">
                                
                                    About
                                
                            </a>
                        </li>
                    
                </ul>
                <p class="copyright footer-author">
                    &copy; 2018-2022 
                    <a rel="external" class="copyright-link" href="https://github.com/luswdev" target="_blank">LuSkywalker</a><br>
                    Powered by <a rel="external" class="copyright-link" href="https://hexo.io/" target="_blank">Hexo</a>  
                    <span class="copyright-split">&nbsp;|&nbsp;&nbsp;</span>
                    Theme <a rel="external" class="copyright-link" href="https://github.com/luswdev/hexo-theme-clean.git" target="_blank">Clean</a>
                    
                    
                </p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    <!-- jQuery -->
<script src="//cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js"></script>

<!-- For drop down -->
<script src="//cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>

<!-- Bootstrap -->
<script src="//cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/js/bootstrap.min.js"></script>
<!-- Gallery -->
<script src="//cdn.jsdelivr.net/npm/lightgallery@1.6.11/dist/js/lightgallery-all.min.js"></script>
<!-- Busuanzi -->


<!-- Search script -->
<script src="/js/search.js"></script>
<script type="text/javascript">
    $(function () {
        searchFunc( '/search.xml' , 'searchInput', 'searchResult');
    });
</script>


<script src="/js/main.js"></script>


    <!-- Search Modal -->
    <!-- Modal -->
<div class="modal fade" id="searchModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
    <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
        <div class="modal-content overflow-auto">
            <div class="modal-header">
                <input type="text" class="form-control" placeholder="搜尋關鍵字..." id="searchInput">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-body">
                <div id="searchResult">
                    <div class="search-empty text-center text-muted p-5">
                        <i class="far fa-meh"></i>
                    </div>
                </div>
            </div> 
        </div>
    </div>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>