<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>透過 SplatNet APIs 獲取遊戲紀錄</title>
      <link href="/posts/splatnet-api.html"/>
      <url>/posts/splatnet-api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="SplatNet-Cookies">SplatNet Cookies<a class="header-anchor" href="#SplatNet-Cookies">#</a></h2><p>要透過 SplatNet APIs 獲取遊戲紀錄的話，首先必須要登入帳號，並取得 cookies。一個比較簡單快速的方式是透過 <a href="https://github.com/frozenpandaman/splatnet2statink" target="_blank" rel="noopener">splatnet2statink</a> 這個 repo 來取得。</p><h3 id="splatnet2statink">splatnet2statink<a class="header-anchor" href="#splatnet2statink">#</a></h3><p>Clone 下來後執行：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python3 splatnet2statink.py -M 100</span><br></pre></td></tr></tbody></table></figure><p>上述的指令是每 150 秒獲取一次資料，在第一次執行的時候會首先要你登入，並產生 cookies。我們可以利用此 repo 產生的 cookies 來認證。</p><ul><li>登入完後開啟 <em>config.txt</em>，並存下 cookies</li></ul><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"api_key"</span>: <span class="string">"your_key"</span>,</span><br><span class="line">    <span class="attr">"cookie"</span>: <span class="string">"your_cookie"</span>,</span><br><span class="line">    <span class="attr">"session_token"</span>: <span class="string">"your_token"</span>,</span><br><span class="line">    <span class="attr">"user_lang"</span>: <span class="string">"en-US"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="APIs">APIs<a class="header-anchor" href="#APIs">#</a></h2><p>下述為 SplatNet APIs 的清單：</p><ul><li><a href="https://github.com/msruback/MoNet2/wiki/Splatnet-2-API" target="_blank" rel="noopener">SplatNet APIs</a></li><li>常使用到的如下<ul><li><code>/api/results</code> 獲取近 50 場紀錄</li><li><code>/api/records</code> 獲取用戶統計數據</li><li><code>/api/nickname_and_icon?id=your_id</code> 獲取用戶名及頭像</li><li><code>/api/records/hero</code> 獲取英雄模式紀錄</li></ul></li></ul><h3 id="Request">Request<a class="header-anchor" href="#Request">#</a></h3><p>要使用 APIs 需要在 header 帶入 cookies，格式為 <code>iksm_session=api_cookie</code></p><ul><li>完整 header 參考下表（以 PHP cURL lib 展示）</li></ul><figure class="highlight php line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl_setopt_array($ch, <span class="keyword">array</span> (</span><br><span class="line">    CURLOPT_HEADER          =&gt;  <span class="number">0</span>,</span><br><span class="line">    CURLOPT_RETURNTRANSFER  =&gt;  <span class="keyword">true</span>,</span><br><span class="line">    CURLOPT_COOKIE          =&gt; <span class="string">'iksm_session='</span> . $api_cookie,</span><br><span class="line">    CURLOPT_HTTPHEADER      =&gt; <span class="keyword">array</span> (</span><br><span class="line">        <span class="string">'Host'</span>              =&gt; <span class="string">'app.splatoon2.nintendo.net'</span>,</span><br><span class="line">        <span class="string">'x-unique-id'</span>       =&gt; $app_unique_id,</span><br><span class="line">        <span class="string">'x-requested-with'</span>  =&gt; <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">        <span class="string">'x-timezone-offset'</span> =&gt; strval($app_timezone_offset),</span><br><span class="line">        <span class="string">'User-Agent'</span>        =&gt; $app_user_agent,</span><br><span class="line">        <span class="string">'Accept'</span>            =&gt; <span class="string">'*/*'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>           =&gt; <span class="string">'https://app.splatoon2.nintendo.net/home'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>   =&gt; <span class="string">'gzip, deflate'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>   =&gt; $user_lang,</span><br><span class="line">    )</span><br><span class="line">));</span><br></pre></td></tr></tbody></table></figure><p>接下來只需連線至 API 網址即可，完整範例可參考 <a href="https://github.com/luswdev/SplatoonBot/blob/master/src/splatnet.php" target="_blank" rel="noopener">GitHub</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SplatNet </tag>
            
            <tag> Nintendo Switch </tag>
            
            <tag> Splatoon 2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache 將網站架設於子目錄</title>
      <link href="/posts/linux/apache-upload-in-subdir.html"/>
      <url>/posts/linux/apache-upload-in-subdir.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般而言，如果要在不同目錄架設網站的話，需要使用 virtual host，但這是在子網域下的設定。</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">example.com</span><br><span class="line">sub<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>如果我們需要將網站建立在子目錄而不將網頁資料放在同一個資料夾裡呢？</p><figure class="highlight maxima"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">example</span>.com</span><br><span class="line"><span class="built_in">example</span>.com/sub/</span><br></pre></td></tr></tbody></table></figure><h2 id="a2ensite">a2ensite<a class="header-anchor" href="#a2ensite">#</a></h2><p>首先建立一個 apache site config，名字取名跟網站相關及可，放置於 <code>/etc/apache2/site-available/</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo touch /etc/apache2/site-available/example.conf</span><br></pre></td></tr></tbody></table></figure><p>接著輸入以下指令啟用設定欓</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">a2ensite example.conf</span><br></pre></td></tr></tbody></table></figure><h2 id="conf">.conf<a class="header-anchor" href="#conf">#</a></h2><p>下一步是撰寫設定欓</p><figure class="highlight apache"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">Alias</span> /example /path/to/source</span><br><span class="line"><span class="section">&lt;Directory /path/to/source&gt;</span></span><br><span class="line">        <span class="attribute"><span class="nomarkup">Order</span></span> allow,deny</span><br><span class="line">        <span class="attribute"><span class="nomarkup">allow</span></span> from <span class="literal">all</span></span><br><span class="line">        <span class="attribute">Allowoverride</span> <span class="literal">All</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>如此一來，此資源將會被導向 <code>/example</code></p><h3 id="重啟">重啟<a class="header-anchor" href="#重啟">#</a></h3><p>最後請重啟 apache</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BMP (Bitmap) 檔案格式</title>
      <link href="/posts/bitmap-file-structure.html"/>
      <url>/posts/bitmap-file-structure.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>點陣圖（<code>.bmp</code>）是 windows 使用的圖像格式，整個檔案由四個部分組成：<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[點陣圖（Bitmap）檔案格式 @ 瘋小貓的華麗冒險](https://crazycat1130.pixnet.net/blog/post/1345538)">[1]</span></a></sup></p><ul><li>Bitmap File Header</li><li>Bitmap Info Header</li><li>Color Table (Palette)</li><li>Bitmap Array</li></ul><h2 id="1-Bitmap-File-Header">1. Bitmap File Header<a class="header-anchor" href="#1-Bitmap-File-Header">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Start</th><th>Name</th><th>Size (Byte)</th><th>Content</th></tr></thead><tbody><tr><td>0x0000</td><td>ID</td><td>2</td><td>“BM”</td></tr><tr><td>0x0002</td><td>File Size</td><td>4</td><td>Total file size</td></tr><tr><td>0x0004</td><td>Reserved</td><td>4</td><td>Reserved</td></tr><tr><td>0x000A</td><td>Bitmap Data Offset</td><td>4</td><td>BMP offset</td></tr></tbody></table></div><ul><li>ID 欄位為識別碼，對應以下值：<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[BMP - 維基百科，自由的百科全書](https://zh.wikipedia.org/wiki/BMP)">[2]</span></a></sup><ul><li>BM – Windows 3.1x, 95, NT, … etc.</li><li>BA – OS/2 struct Bitmap Array</li><li>CI – OS/2 struct Color Icon</li><li>CP – OS/2 const Color Pointer</li><li>IC – OS/2 struct Icon</li><li>PT – OS/2 Pointer</li></ul></li><li>Bitmap Data Offset：點陣圖資料（像素陣列）的位址偏移，也就是起始位址。</li></ul><h2 id="2-Bitmap-Info-Header">2.Bitmap Info Header<a class="header-anchor" href="#2-Bitmap-Info-Header">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Start</th><th>Name</th><th>Size (Byte)</th><th>Content</th></tr></thead><tbody><tr><td>0x000E</td><td>Bitmap Header Size</td><td>4</td><td>BIH size</td></tr><tr><td>0x0012</td><td>Width</td><td>4</td><td>BMP width  (pixel)</td></tr><tr><td>0x0016</td><td>Height</td><td>4</td><td>BMP height (pixel)</td></tr><tr><td>0x001A</td><td>Planes</td><td>2</td><td>BMP plane counts</td></tr><tr><td>0x001C</td><td>Bits Per Pixel</td><td>2</td><td>Pixel size</td></tr><tr><td>0x001E</td><td>Compression</td><td>4</td><td>Compression method</td></tr><tr><td>0x0022</td><td>Bitmap Data Size</td><td>4</td><td>BMP data size</td></tr><tr><td>0x0026</td><td>H-Resolution</td><td>4</td><td>Horizontal Resolution</td></tr><tr><td>0x002A</td><td>V-Resolution</td><td>4</td><td>Vertical Resolution</td></tr><tr><td>0x002E</td><td>Used Colors</td><td>4</td><td>Palette colors used</td></tr><tr><td>0x0032</td><td>Important Colors</td><td>4</td><td>Important color count</td></tr></tbody></table></div><ul><li>高度為帶號值<ul><li>若為正數，代表圖為倒向</li><li>若為負數，代表圖為正向 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[BMP檔案格式詳解（BMP file format）[圖文解說] - IT閱讀](https://www.itread01.com/content/1549504280.html)">[3]</span></a></sup></li></ul></li><li>Planes 為圖層數，不過永遠設成 1</li><li>Bits/pixel 有 6 種不同方式:<ul><li>1：單色點陣圖（使用 2 色調色盤）</li><li>4：4 位元點陣圖（使用 16 色調色盤）</li><li>8：8 位元點陣圖（使用 256 色調色盤）</li><li>16：16 位元高彩點陣圖（不一定使用調色盤）</li><li>24：24 位元全彩點陣圖（不使用調色盤）</li><li>32：32 位元全彩點陣圖（不一定使用調色盤）</li></ul></li><li>壓縮方式有 4 種<ul><li>0：未壓縮，不使用調色盤</li><li>1：RLE 8-bit/pixel</li><li>2：RLE 4-bit/pixel</li><li>3：Bitfields</li></ul></li></ul><h2 id="3-Palette">3.Palette<a class="header-anchor" href="#3-Palette">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Start</th><th>Name</th><th>Size (Byte)</th><th>Content</th></tr></thead><tbody><tr><td>0x0036</td><td>Palette</td><td>N*4</td><td>Palette data</td></tr></tbody></table></div><p>每個索引值表示一個顏色：<code>0x00RRGGBB</code>，最高位保留 0</p><h2 id="4-Bitmap-Array">4.Bitmap Array<a class="header-anchor" href="#4-Bitmap-Array">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Start</th><th>Name</th><th>Size (Byte)</th><th>Content</th></tr></thead><tbody><tr><td>-</td><td>Bitmap Data</td><td>-</td><td>BMP data</td></tr></tbody></table></div><p>根據 Height 設定的值不同，掃描的方向也不同；若為正向則為由下到上，反之亦然。而每個掃描列須為<strong>4 Bytes 的倍數</strong>。</p><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://crazycat1130.pixnet.net/blog/post/1345538" target="_blank" rel="noopener">點陣圖（Bitmap）檔案格式 @ 瘋小貓的華麗冒險</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/BMP" target="_blank" rel="noopener">BMP - 維基百科，自由的百科全書</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.itread01.com/content/1549504280.html" target="_blank" rel="noopener">BMP檔案格式詳解（BMP file format）[圖文解說] - IT閱讀</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 更換時區指令</title>
      <link href="/posts/linux/change-timezone.html"/>
      <url>/posts/linux/change-timezone.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Linux 的預設時時區是 <code>UTC</code>，如果在安裝的時候沒有更改，或是租 VPS 的時候就需要手動修改。<br>這裡介紹 Ubuntu 內建的指令 <code>timedatectl</code>。</p><div class="alert alert-info"><p>這是 Ubuntu 的指令，若是你的 Linux 發行版不是 Ubuntu 則不適用。</p></div><h2 id="timedatectl">timedatectl<a class="header-anchor" href="#timedatectl">#</a></h2><p>這是一個可以顯示、設定及修改系統時區的指令。</p><h3 id="顯示所有時區">顯示所有時區<a class="header-anchor" href="#顯示所有時區">#</a></h3><p>可以用 <code>list-timezones</code> 來列出所有時區</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ timedatectl list-timezones</span><br></pre></td></tr></tbody></table></figure><ul><li>結果會像是這樣：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Aferica/...</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>可以結合 <code>grep</code> 來搜尋想要的結果，如我們只列出亞洲的：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ timedatectl list-timezones | grep Asia</span><br></pre></td></tr></tbody></table></figure><h3 id="顯示目前時區">顯示目前時區<a class="header-anchor" href="#顯示目前時區">#</a></h3><p>不加上任何設定即可顯示目前設定的時區</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ timedatectl</span><br></pre></td></tr></tbody></table></figure><ul><li>結果會像是這樣：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Local time: Thu 2020-05-07 22:08:01 CST</span><br><span class="line">Universal time: Thu 2020-05-07 14:08:01 UST</span><br><span class="line">RTC time: Thu 2020-05-07 22:08:01</span><br><span class="line">Time zone: Asia/Taipei (CST +8000)</span><br><span class="line">System clock synchronized: yes</span><br><span class="line">NTP service: active</span><br><span class="line">RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</span><br></pre></td></tr></tbody></table></figure><p>加上 <code>status</code> 可以顯示設定</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ timedatectl status</span><br></pre></td></tr></tbody></table></figure><ul><li>結果會像是這樣：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Timezone=Asia/Taipei</span><br><span class="line">LocalRTC=no</span><br><span class="line">CanNTP=yes</span><br><span class="line">NTP=yes</span><br><span class="line">NTPSynchronized=yes</span><br><span class="line">TimeUSec=Thu 2020-05-07 22:08:01 CST</span><br><span class="line">RTCTimeUSec=Thu 2020-05-07 22:08:01 CTS</span><br></pre></td></tr></tbody></table></figure><h3 id="改變時區">改變時區<a class="header-anchor" href="#改變時區">#</a></h3><p>使用 <code>set-timezone</code> 可以修改系統設定的時區</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ timedatectl <span class="built_in">set</span>-timezone Zone</span><br></pre></td></tr></tbody></table></figure><p><code>Zone</code> 需要修改成想要設定的時區，如 <code>Asia/Taipei</code>。</p><p>修改後可以使用 <code>show</code> 來看是否修改成功。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ timedatectl show</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> timezone </tag>
            
            <tag> timedatectl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 Makefile 專案建置</title>
      <link href="/posts/linux/building-stm32-in-makefile.html"/>
      <url>/posts/linux/building-stm32-in-makefile.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="資料夾結構">資料夾結構<a class="header-anchor" href="#資料夾結構">#</a></h2><p>第一步，建立三個資料夾 “System”、“OS” 及 “User”</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- System</span><br><span class="line">|</span><br><span class="line">|-- OS</span><br><span class="line">|</span><br><span class="line">`-- User</span><br></pre></td></tr></tbody></table></figure><ul><li>System 放驅動程式</li><li>OS 就是作業系統（也可不用）</li><li>User 放的是我們的專案</li></ul><p>接著，在每個資料夾底下新增一個 makefile。</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- System</span><br><span class="line">|   `-- makefile</span><br><span class="line">|</span><br><span class="line">|-- OS</span><br><span class="line">|   `-- makefile</span><br><span class="line">|</span><br><span class="line">|-- User</span><br><span class="line">|   `-- makefile</span><br><span class="line">|</span><br><span class="line">`-- makefile</span><br></pre></td></tr></tbody></table></figure><p>準備步驟的最後，將所有程式碼正確的擺放。如範例：</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- System</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- STM32</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   `-- inc</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">-- STM32F429</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   `-- inc</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">-- CMSIS</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   `-- inc</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   `-- makefile</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">-- OS</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   `-- makefile</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">-- User</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   `-- makefile</span></span><br><span class="line">|</span><br><span class="line">`-- makefile</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>在這個例子，我們在 System 底下放了三個驅動，所以需要將程式碼分成三個資料夾。<br>當然你也可以直接全部放在一起是沒問題的。</p></div><p>最後的最後，別忘了在驅動的底下也加一個 makefile。</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- System</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- STM32</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   `-- makefile</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">-- STM32F429</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   `-- makefile</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">-- CMSIS</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   `-- makefile</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   `-- makefile</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">-- OS</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   `-- makefile</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">-- User</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- src</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">-- inc</span></span><br><span class="line">|<span class="string">   `-- makefile</span></span><br><span class="line">|</span><br><span class="line">`-- makefile</span><br></pre></td></tr></tbody></table></figure><hr><p>下一步，來寫 makefile！</p><h2 id="GCC">GCC<a class="header-anchor" href="#GCC">#</a></h2><p>在所有的 makefile（除了最上層）寫上以下程式碼：</p><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TCPREFIX = arm-none-eabi-</span><br><span class="line">CC       = <span class="variable">$(TCPREFIX)</span>gcc</span><br><span class="line"></span><br><span class="line">CFLAGS = -c -Wall -fno-common -O0 -g -mthumb -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-d16 --specs=nosys.specs</span><br><span class="line"></span><br><span class="line">INCFLAG =\</span><br><span class="line">-I. \</span><br><span class="line">-Iinc</span><br><span class="line"></span><br><span class="line">CFLAGS  += <span class="variable">$(INCFLAG)</span></span><br><span class="line"></span><br><span class="line">OBJDIR = obj</span><br><span class="line"></span><br><span class="line">OBJS =\</span><br><span class="line"><span class="variable">$(OBJDIR)</span>/src.o </span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/%.o: src/%.c | <span class="variable">$(OBJDIR)</span></span><br><span class="line">@echo <span class="string">"bulid file: <span class="variable">$&lt;</span>"</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MMD -MF$(@:%.o=%.d) -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>:</span><br><span class="line">@echo <span class="variable">$(NOW)</span> INFO Make new folder User/<span class="variable">$(OBJDIR)</span>.</span><br><span class="line">mkdir -p <span class="variable">$(OBJDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(OBJDIR)</span>/*.o </span><br><span class="line">-rm -rf <span class="variable">$(OBJDIR)</span>/*.d</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>arm-none-eabi-gcc</code> 來進行編譯</li><li>為 <code>gcc</code> 加入一些設定，如浮點數處理器。</li><li>接著設定所有需要連結的 object file</li><li>將所有 <code>.c</code> 編譯成 <code>.o</code></li><li>Target <code>all</code> 將會完成編譯所有檔案</li><li>Target <code>clean</code> 可以清理所有 object file</li></ul><p>接著告訴主要的 makefile 要去底下的 makefile 執行編譯</p><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">obj:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> all -C System</span><br><span class="line"><span class="variable">$(MAKE)</span> all -C OS</span><br><span class="line"><span class="variable">$(MAKE)</span> all -C User</span><br></pre></td></tr></tbody></table></figure><p><code>-C</code> 意味著要去下層資料夾執行目標，所以第二行等同於：</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">cd ./System</span><br><span class="line">make all</span><br></pre></td></tr></tbody></table></figure><h3 id="Startup-o">Startup.o<a class="header-anchor" href="#Startup-o">#</a></h3><p>Startup.o 是必須的，把它放在 <code>User</code> 理，但不要放進 <code>src</code>；編譯他的道理是類似的</p><figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">OBJS +=\</span><br><span class="line">startup.o</span><br><span class="line"></span><br><span class="line"><span class="section">Startup/startup.o: ./startup.s | <span class="variable">$(OBJDIR)</span></span></span><br><span class="line">@echo <span class="string">"bulid file: <span class="variable">$&lt;</span>"</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MMD -MF$(@:%.o=%.d) -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></tbody></table></figure><p>以上建置完成後，能快速的編譯所有程式。接著我們將所有 object file 連結成一個二進位檔。</p><h2 id="G-Linker">G++ (Linker)<a class="header-anchor" href="#G-Linker">#</a></h2><p>連結的動作放在主要的 makefile 中。</p><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TCPREFIX = arm-none-eabi-</span><br><span class="line">LD       = <span class="variable">$(TCPREFIX)</span>g++</span><br><span class="line"></span><br><span class="line">LFLAGS  = -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -Os -T<span class="variable">$(LDFILE)</span> --specs=nosys.specs</span><br><span class="line">LDFILE  = ./STM32F429ZI_FLASH.ld</span><br><span class="line"></span><br><span class="line">OBJS =\</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./User/obj/*.o)</span> \</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./System/*/obj/*.o)</span> \</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./OS/obj/*.o)</span> \</span><br><span class="line">./User/startup.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.elf: <span class="variable">$(OBJS)</span> <span class="variable">$(LDFILE)</span></span></span><br><span class="line">@echo <span class="string">"link file: <span class="variable">$@</span>"</span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 wildcard 掃描所有 object file</li><li>連結成一個 <code>.elf</code></li></ul><h3 id="Objdump-and-Objcopy">Objdump and Objcopy<a class="header-anchor" href="#Objdump-and-Objcopy">#</a></h3><p>再將 <code>.elf</code> 轉成 <code>.bin</code> 燒錄。</p><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCPREFIX = arm-none-eabi-</span><br><span class="line">CP       = <span class="variable">$(TCPREFIX)</span>objcopy</span><br><span class="line">OD       = <span class="variable">$(TCPREFIX)</span>objdump</span><br><span class="line"></span><br><span class="line"><span class="section">main.bin: obj main.elf</span></span><br><span class="line">@echo <span class="string">"copy file main.elf"</span></span><br><span class="line"><span class="variable">$(CP)</span> <span class="variable">$(CPFLAGS)</span> main.elf <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(OD)</span> <span class="variable">$(ODFLAGS)</span> main.elf &gt; main.lst</span><br></pre></td></tr></tbody></table></figure><h2 id="Openocd">Openocd<a class="header-anchor" href="#Openocd">#</a></h2><p>最後一件事，燒錄；這裡使用 <a href="http://openocd.org/" target="_blank" rel="noopener">openocd</a>。</p><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">run: main.bin</span></span><br><span class="line">@echo <span class="variable">$(YELLOW)</span><span class="string">"Flash <span class="variable">$&lt;</span> into board..."</span><span class="variable">$(RST)</span></span><br><span class="line">openocd -f <span class="variable">$(OCDCFG)</span>  \</span><br><span class="line">-c <span class="string">"init"</span>                   \</span><br><span class="line">            -c <span class="string">"reset init"</span>             \</span><br><span class="line">            -c <span class="string">"stm32f2x unlock 0"</span>      \</span><br><span class="line">            -c <span class="string">"flash probe 0"</span>          \</span><br><span class="line">            -c <span class="string">"flash info 0"</span>           \</span><br><span class="line">            -c <span class="string">"flash write_image erase <span class="variable">$&lt;</span> 0x8000000"</span> \</span><br><span class="line">            -c <span class="string">"reset run"</span> -c shutdown</span><br><span class="line">@echo <span class="variable">$(GREEN)</span><span class="string">"Finish flash <span class="variable">$&lt;</span> into board."</span><span class="variable">$(RST)</span></span><br><span class="line">@echo <span class="string">""</span></span><br></pre></td></tr></tbody></table></figure><h2 id="總結">總結<a class="header-anchor" href="#總結">#</a></h2><p>在主 makefile 寫下以下片段，將所有東西整合吧。</p><figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">all: run</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: main.bin</span></span><br></pre></td></tr></tbody></table></figure><p>如此以來，只要下指令 <code>make all</code> 就會將所有該編譯的程式碼編譯完成，連結成一個二進位檔，最後燒盡板子。</p><hr><p>這是我的一個專案建置的範例，可以參考。</p><ul><li><a href="https://github.com/luswdev/GUI-workspace" target="_blank" rel="noopener">GUI Workspace</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> STM32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Theme Clean Document</title>
      <link href="/posts/hexo/theme-clean-doc.html"/>
      <url>/posts/hexo/theme-clean-doc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>This is a theme base on <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank" rel="noopener">Hexo Clean Blog Theme</a>, and modfy for more feature and coding style.</p></blockquote><div class="alert alert-info"><p>Get theme source on <a href="https://github.com/luswdev/hexo-theme-clean" target="_blank" rel="noopener">github</a></p></div><h2 id="Features">Features<a class="header-anchor" href="#Features">#</a></h2><ul><li>Cover image for posts and pages</li><li>Post toc</li><li>Code syntax highlighting</li><li>MathJax support</li><li>Bootstrap Alert, Card and Label support</li><li>Responsive Images, table and codeblock</li><li>Light Gallery support</li><li>Disqus and Gitalk</li><li>Google Analytics, Busuanzi Statistics and Word counts support</li><li>Tags, Categories and About support</li><li>Pin post at home page support</li><li>Hexo local search</li></ul><h2 id="Installation">Installation<a class="header-anchor" href="#Installation">#</a></h2><ul><li>Clone into your hexo blog directory</li></ul><figure class="highlight crmsh"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/luswdev/hexo-theme-clean.git themes/clean</span><br></pre></td></tr></tbody></table></figure><p>Then update your blog’s main <code>_config.yml</code> to set the theme to <code>clean</code>:</p><figure class="highlight clean"><table><tbody><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: http:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: clean</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Configuration">Configuration<a class="header-anchor" href="#Configuration">#</a></h2><h3 id="Top-Left-Label">Top Left Label<a class="header-anchor" href="#Top-Left-Label">#</a></h3><p>The top left label is configured in the theme’s <code>_config.yml</code>. When clicked it will lead to the Home Page.</p><figure class="highlight sas"><table><tbody><tr><td class="code"><pre><span class="line"># <span class="meta">Title</span> <span class="meta">on</span> top left of menu. <span class="meta">Leave</span> empty to use main blog <span class="meta">title</span></span><br><span class="line">menu_title: Configurable <span class="meta">Title</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Home-Page-cover-image">Home Page cover image<a class="header-anchor" href="#Home-Page-cover-image">#</a></h3><p>The Home Page cover is configured in the theme’s <code>_config.yml</code>. It will be the same for all index type pages.</p><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># URL of the Home page image</span></span><br><span class="line">index_cover: <span class="regexp">/img/</span>home-bg.jpg</span><br></pre></td></tr></tbody></table></figure><h3 id="Favicon-image">Favicon image<a class="header-anchor" href="#Favicon-image">#</a></h3><p>The favicon is configured in the theme’s <code>_config.yml</code>.</p><figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Set your own favicon</span></span><br><span class="line">favicon: <span class="regexp">/img/</span>favicon.png</span><br></pre></td></tr></tbody></table></figure><h3 id="Start-Year">Start Year<a class="header-anchor" href="#Start-Year">#</a></h3><p>This will set archives page button group starting year, if not set, it will start at current year.<br>Also is footer copyright start year, too.</p><figure class="highlight vala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># Site start year</span></span><br><span class="line"><span class="meta"># Default with current year</span></span><br><span class="line">start_year:</span><br></pre></td></tr></tbody></table></figure><h3 id="Google-Analytics">Google Analytics<a class="header-anchor" href="#Google-Analytics">#</a></h3><p>The Google Analytics Tracking ID is configured in the theme’s <code>_config.yml</code>. It allow us to learn about blog visitors.</p><figure class="highlight avrasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># Google Analytics Tracking ID</span></span><br><span class="line"><span class="symbol">google_analytics:</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Busuanzi">Busuanzi<a class="header-anchor" href="#Busuanzi">#</a></h3><p>The Busuanzi is configured in the theme’s <code>_config.yml</code>. It can record site traffic and visitors count.</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Busuanzi Statistics</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</span></span><br><span class="line"><span class="attr">  site_views:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  site_visitors:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Social-Account">Social Account<a class="header-anchor" href="#Social-Account">#</a></h3><p>Setup the links to your social pages in the theme’s <code>_config.yml</code>. Links are in the footer.</p><figure class="highlight less"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">footer</span>:</span><br><span class="line">  <span class="attribute">social_link</span>:</span><br><span class="line">    <span class="attribute">twitter_url</span>:</span><br><span class="line">    <span class="attribute">twitter_handle</span>:</span><br><span class="line">    <span class="attribute">facebook_url</span>:</span><br><span class="line">    <span class="attribute">github_url</span>: <span class="attribute">https</span>:<span class="comment">//github.com/luswdev/hexo-theme-clean</span></span><br><span class="line">    <span class="attribute">gitlab_url</span>:</span><br><span class="line">    <span class="attribute">linkedin_url</span>: </span><br><span class="line">    <span class="attribute">mailto</span>:</span><br></pre></td></tr></tbody></table></figure><h3 id="New-Tags-page">New Tags page<a class="header-anchor" href="#New-Tags-page">#</a></h3><blockquote><p>Follow these steps to add a <code>tags</code> page that contains all the tags in your site.</p></blockquote><ul><li>Create a page named <code>tags</code></li></ul><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span><span class="string">"tags"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Edit the newly created page and set page type to <code>tags</code> in the front matter.</li></ul><figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line">title: <span class="keyword">All</span> tags</span><br><span class="line"><span class="keyword">type</span>: <span class="string">"tags"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Add <code>tags</code> to the menu in the theme <code>_config.yml</code>:</li></ul><figure class="highlight dts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">footer:</span></span><br><span class="line"><span class="symbol">  menu:</span></span><br><span class="line"><span class="symbol">    Home:</span> /</span><br><span class="line"><span class="symbol">    Tags:</span> /tags</span><br></pre></td></tr></tbody></table></figure><h3 id="Categories-page">Categories page<a class="header-anchor" href="#Categories-page">#</a></h3><blockquote><p>Follow these steps to add a <code>categories</code> page that contains all the categories in your site.</p></blockquote><ul><li>Create a page named <code>categories</code></li></ul><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span><span class="string">"categories"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Edit the newly created page and set page type to <code>categories</code> in the front matter.</li></ul><figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line">title: <span class="keyword">All</span> categories</span><br><span class="line"><span class="keyword">type</span>: <span class="string">"categories"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Add <code>Categories</code> to the menu in the theme <code>_config.yml</code>:</li></ul><figure class="highlight dts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">footer:</span></span><br><span class="line"><span class="symbol">  menu:</span></span><br><span class="line"><span class="symbol">    Home:</span> /</span><br><span class="line"><span class="symbol">    Categories:</span> /categories</span><br></pre></td></tr></tbody></table></figure><h3 id="New-About-page">New About page<a class="header-anchor" href="#New-About-page">#</a></h3><blockquote><p>Follow these steps to add a <code>about</code> page that can write some information about you.</p></blockquote><ul><li>Create a page named <code>about</code></li></ul><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span><span class="string">"about"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Edit the newly created page and set page type to <code>about</code> in the front matter.</li></ul><figure class="highlight avrasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">title:</span> About</span><br><span class="line"><span class="symbol">type:</span> <span class="string">"about"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Add <code>About</code> to the menu in the theme <code>_config.yml</code>:</li></ul><figure class="highlight dts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">footer:</span></span><br><span class="line"><span class="symbol">  menu:</span></span><br><span class="line"><span class="symbol">    Home:</span> /</span><br><span class="line"><span class="symbol">    About:</span> /about</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Writing">Writing<a class="header-anchor" href="#Writing">#</a></h2><h3 id="Default-post-title">Default post title<a class="header-anchor" href="#Default-post-title">#</a></h3><p>The default post title (used when no title is specified) is configured in the theme’s <code>_config.yml</code>.</p><figure class="highlight avrasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># Default post title</span></span><br><span class="line"><span class="symbol">default_post_title:</span> Untitled</span><br></pre></td></tr></tbody></table></figure><h3 id="Post-word-count">Post word count<a class="header-anchor" href="#Post-word-count">#</a></h3><p>The post word count can show a post’s word count and read time, you need to install plugin:</p><figure class="highlight stata"><table><tbody><tr><td class="code"><pre><span class="line">npm i --<span class="keyword">save</span> hexo-<span class="built_in">wordcount</span></span><br></pre></td></tr></tbody></table></figure><p>And configured in the theme’s <code>_config.yml</code>.</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Post meta</span></span><br><span class="line"><span class="attr">post_info:</span></span><br><span class="line"><span class="attr">  word_count:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  read_time:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Post’s-Excerpt">Post’s Excerpt<a class="header-anchor" href="#Post’s-Excerpt">#</a></h3><p>This theme does not support traditional excerpts. To show excerpts on the index page, use <code>subtitle</code> in the front-matter:</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Post</span> <span class="string">title</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2007</span><span class="bullet">-08</span><span class="bullet">-05</span> <span class="number">07</span><span class="string">:08:05</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Standard</span> <span class="string">Excerpts</span> <span class="string">are</span> <span class="string">not</span> <span class="string">supported</span> <span class="string">in</span> <span class="string">Clean</span> <span class="string">Blog</span> <span class="string">but</span> <span class="string">you</span> <span class="string">can</span> <span class="string">use</span> <span class="string">subtitles</span> <span class="string">in</span> <span class="string">the</span> <span class="string">front</span> <span class="string">matter</span> <span class="string">to</span> <span class="string">display</span> <span class="string">text</span> <span class="string">in</span> <span class="string">the</span> <span class="string">index.</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Post’s-Cover-Image">Post’s Cover Image<a class="header-anchor" href="#Post’s-Cover-Image">#</a></h3><p>By default, posts will use the home page cover image. You can specify a custom cover in the front-matter:</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Post</span> <span class="string">title</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2007</span><span class="bullet">-08</span><span class="bullet">-05</span> <span class="number">07</span><span class="string">:08:05</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/assets/contact-bg.jpg</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Author">Author<a class="header-anchor" href="#Author">#</a></h3><p>The post’s author is specified in the posts front-matter:</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Post</span> <span class="string">title</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2007</span><span class="bullet">-08</span><span class="bullet">-05</span> <span class="number">07</span><span class="string">:08:05</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Klug</span> <span class="string">Jo</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h3 id="TOC">TOC<a class="header-anchor" href="#TOC">#</a></h3><p>We implement TOC and back to top on the TOC menu, which is a dropup menu on the bottom right. Enable it in the theme’s <code>_config.yml</code>.</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Enable post toc</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Card-Tag">Card Tag<a class="header-anchor" href="#Card-Tag">#</a></h3><p>You can insert a bs card by using tags, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">I am a card.</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><div class="card bg-default  my-3"><div class="card-body"><p>I am a card.</p></div></div><h4 id="Card-header">Card header<a class="header-anchor" href="#Card-header">#</a></h4><p>Also you can put some title into header, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- header --&gt;</span></span></span><br><span class="line"><span class="xml">I am header.</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endheader --&gt;</span></span></span><br><span class="line"><span class="xml">I am a card.</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><div class="card bg-default  my-3"><div class="card-header"><p>I am header.</p></div><div class="card-body"><p>I am a card.</p></div></div><h4 id="Card-footer">Card footer<a class="header-anchor" href="#Card-footer">#</a></h4><p>Also you can put some words into footer, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">I am a card.</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- footer --&gt;</span></span></span><br><span class="line"><span class="xml">I am footer.</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endfooter --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><div class="card bg-default  my-3"><div class="card-body"><p>I am a card.</p></div><div class="card-footer"><p>I am footer.</p></div></div><h4 id="Card-style">Card style<a class="header-anchor" href="#Card-style">#</a></h4><p>There have 8 style for card, we have:</p><ul><li>primary, secondary, success, danger, warning, info, light, dark.</li></ul><p>Just put classes into tag like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> success %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">I am success!</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><div class="card bg-success  text-white my-3"><div class="card-body"><p>I am success!</p></div></div><p>You can see all style in <a href="https://getbootstrap.com/docs/4.4/components/card/#background-and-color" target="_blank" rel="noopener">Bootstrap doc</a>.</p><h3 id="Alert-Tag">Alert Tag<a class="header-anchor" href="#Alert-Tag">#</a></h3><p>You can insert a bs alert by using tags, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">alert</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">I am a alert</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endalert</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-secondary"><p>I am a alert</p></div><h4 id="Alert-style">Alert style<a class="header-anchor" href="#Alert-style">#</a></h4><p>There have 8 style for alert, we have:</p><ul><li>primary, secondary, success, danger, warning, info, light, dark.</li></ul><p>Just put classes into tag like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">alert</span> success %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">I am success!</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endalert</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-success"><p>I am success!</p></div><p>You can see all style in <a href="https://getbootstrap.com/docs/4.4/components/alerts/#examples" target="_blank" rel="noopener">Bootstrap doc</a>.</p><h3 id="Badge-Tag">Badge Tag<a class="header-anchor" href="#Badge-Tag">#</a></h3><p>You can insert a bs badge by using tags, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> @new! %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><span class="badge badge-secondary">new!</span><h4 id="Badge-style">Badge style<a class="header-anchor" href="#Badge-style">#</a></h4><p>There have 8 style for badge, we have:</p><ul><li>primary, secondary, success, danger, warning, info, light, dark.</li></ul><p>Just put classes into tag like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> success @success! %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><span class="badge badge-success">success!</span><p>You can see all style in <a href="https://getbootstrap.com/docs/4.4/components/badge/#contextual-variations" target="_blank" rel="noopener">Bootstrap doc</a>.</p><h3 id="Detail-Tag">Detail Tag<a class="header-anchor" href="#Detail-Tag">#</a></h3><p>We impliment html detail tag into hexo, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">spoiler</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">Something more information at here!</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endspoiler</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><details class="alert alert-secondary"><summary>Details</summary><p>Something more information at here!</p></details><h4 id="Detail-Title">Detail Title<a class="header-anchor" href="#Detail-Title">#</a></h4><p>You can replace <code>Details</code> title to special you want, just write something like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">spoiler</span> Click Me %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">Something more information at here!</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endspoiler</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><details class="alert alert-secondary"><summary>Click Me</summary><p>Something more information at here!</p></details><h3 id="MathJax">MathJax<a class="header-anchor" href="#MathJax">#</a></h3><p>You can write <code>LaTeX</code> code in <code>Markdown</code> file and render on post. Just enable in the theme’s <code>_config.yml</code>.</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Enable post mathjax</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>And set mathjax to <code>true</code> in the posts front-matter:</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Post</span> <span class="string">title</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2007</span><span class="bullet">-08</span><span class="bullet">-05</span> <span class="number">07</span><span class="string">:08:05</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><p>And so on, you can now write inline <code>LaTeX</code> in post like this:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$(a + b)^2 = a^2 + 2ab + b^2$</span><br></pre></td></tr></tbody></table></figure><p>$(a + b)^2 = a^2 + 2ab + b^2$</p><p>Or write a <code>LaTeX</code> block in post like this:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin{array}{lll}</span><br><span class="line">(a + b)^2 &amp;=&amp; a^2 + 2ab + b^2 \\\\</span><br><span class="line">(a - b)^2 &amp;=&amp; a^2 - 2ab + b^2</span><br><span class="line">\end{array}</span><br><span class="line">$$</span><br></pre></td></tr></tbody></table></figure><p>$$<br>\begin{array}{lll}<br>(a + b)^2 &amp;=&amp; a^2 + 2ab + b^2 \\<br>(a - b)^2 &amp;=&amp; a^2 - 2ab + b^2<br>\end{array}<br>$$</p><p>For more information, you can see <a href="https://docs.mathjax.org/en/v2.7-latest/index.html" target="_blank" rel="noopener">MathJax Doc</a>.</p><h3 id="Comments">Comments<a class="header-anchor" href="#Comments">#</a></h3><p>The comments provider is specified in the theme’s <code>_config.yml</code>.</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Comments. Choose one by filling up the information</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Disqus comments</span></span><br><span class="line"><span class="attr">  disqus:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    shortname:</span> </span><br><span class="line">  <span class="comment"># Gitalk</span></span><br><span class="line"><span class="attr">  gitalk:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    owner:</span></span><br><span class="line"><span class="attr">    repo:</span></span><br><span class="line"><span class="attr">    oauth:</span></span><br><span class="line"><span class="attr">      accessToken:</span></span><br><span class="line"><span class="attr">      clientId:</span></span><br><span class="line"><span class="attr">      clientSecret:</span></span><br><span class="line"><span class="attr">    admin:</span></span><br></pre></td></tr></tbody></table></figure><p>You can too hide the comment in the posts front-matter:</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Post</span> <span class="string">title</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2007</span><span class="bullet">-08</span><span class="bullet">-05</span> <span class="number">07</span><span class="string">:08:05</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">comment:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Post-Font-matter">Post Font-matter<a class="header-anchor" href="#Post-Font-matter">#</a></h2><p>This is all font-matter you can use.</p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>title</td><td>Title</td><td>Filename (posts only)</td></tr><tr><td>subtitle</td><td>Sub Title</td><td>-</td></tr><tr><td>date</td><td>Published date</td><td>File created date</td></tr><tr><td>tags</td><td>Post tags</td><td>-</td></tr><tr><td>category</td><td>Post category</td><td>-</td></tr><tr><td>mathjax</td><td>Use mathjax or not</td><td><code>false</code></td></tr><tr><td>comment</td><td>Show comment field or not</td><td><code>true</code></td></tr><tr><td>cover</td><td>Use special header cover</td><td>-</td></tr><tr><td>pin</td><td>Pin this post on home page</td><td><code>false</code></td></tr></tbody></table></div><h2 id="Custom">Custom<a class="header-anchor" href="#Custom">#</a></h2><p>You can modify your blog yourself by writing <code>custom.styl</code>, it location at</p><figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line">. </span><br><span class="line">`<span class="comment">-- source</span></span><br><span class="line">  `<span class="comment">-- css</span></span><br><span class="line">    `<span class="comment">-- _custom</span></span><br><span class="line">      `<span class="comment">-- custom.styl</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Creator">Creator<a class="header-anchor" href="#Creator">#</a></h2><p>This theme was created by <a href="https://github.com/BlackrockDigital" target="_blank" rel="noopener">Blackrock Digital</a>, adapted for Hexo by <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a> and modfy by <a href="/">LuSkywalker</a></p><h2 id="Version">Version<a class="header-anchor" href="#Version">#</a></h2><ul><li>V1.0.0<ul><li>Base fuction support.</li></ul></li></ul><h2 id="License">License<a class="header-anchor" href="#License">#</a></h2><p>MIT</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> theme-clean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add Bootstrap badge Tags into Hexo</title>
      <link href="/posts/hexo/add-bs-label.html"/>
      <url>/posts/hexo/add-bs-label.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Boostrap-badge">Boostrap badge<a class="header-anchor" href="#Boostrap-badge">#</a></h2><span class="badge badge-secondary">badge content</span><p>So this is a badge given by <a href="https://getbootstrap.com/docs/4.4/components/badge/" target="_blank" rel="noopener">bootstrap</a>, we can add this into hexo just simply write some <span class="badge badge-warning">HTML</span> like this.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-secondary"</span>&gt;</span>badge content<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>And yes, this is not like <ins><em>Hexo</em></ins> style, and hardly to modify.<br>So as <a href="/post/hexo/add-bs-card.html">last post</a>, let build a tags to insert a badge.</p><hr><h2 id="Badge-Tags">Badge Tags<a class="header-anchor" href="#Badge-Tags">#</a></h2><h3 id="badge-js">badge.js<a class="header-anchor" href="#badge-js">#</a></h3><p>First things to do, new a file call <em>badge.js</em> and put into <code>scripts</code> directory in current theme’s directory:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /path/to/your/current/theme/dir/script/badge.js</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p>if <code>scripts</code> directory is not existed, first new a directory.</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /path/to/your/current/theme/dir/script</span></span><br></pre></td></tr></tbody></table></figure></div><p>Then, write down this into lastest javascript file (badge.js).</p><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * badge.js | global hexo script.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {% badge [class]@Text %}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [class] : primary | secondary | success | danger | warning | info | light | dark.</span></span><br><span class="line"><span class="comment"> *           If not defined, default class will be selected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postBadge</span> (<span class="params">args</span>) </span>{</span><br><span class="line">    args = args.join(<span class="string">' '</span>).split(<span class="string">'@'</span>);</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line">    <span class="keyword">var</span> text = args[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  </span><br><span class="line">    classes = classes.trim();</span><br><span class="line">    !text &amp;&amp; hexo.log.warn(<span class="string">'badge text must be defined!'</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;span class="badge badge-'</span> + classes + <span class="string">'"&gt;'</span> + text + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">hexo.extend.tag.register(<span class="string">'badge'</span>, postBadge, { <span class="attr">ends</span>: <span class="literal">false</span> });</span><br></pre></td></tr></tbody></table></figure><p>In line 23, we registed a tag name badge, and next time we write something like below , it will show like bs badge.</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> @blah %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><h3 id="Different">Different<a class="header-anchor" href="#Different">#</a></h3><p>Here is a trivial different point with card we wrote in <code>register</code>.</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">hexo.extend.tag.register(<span class="string">'badge'</span>, postBadge, { <span class="attr">ends</span>: <span class="literal">false</span> });</span><br></pre></td></tr></tbody></table></figure><p>In the third parameter, we write down <code>{ ends: false }</code>, this will tell hexo that this tag has no end tag. So our badge tag should write like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> @blah %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>And carefully don’t write something like this:</p><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{% badge @blah %}</span><br><span class="line">{% endbadge %}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-danger"><p>Line 2 should not be write down in post markdown file.</p></div><hr><h3 id="Classes">Classes<a class="header-anchor" href="#Classes">#</a></h3><p>badge has some <a href="https://getbootstrap.com/docs/4.4/components/badge/#contextual-variations" target="_blank" rel="noopener">different styles</a>, we can use args to implement it.</p><div class="card bg-default  my-3"><div class="card-body"><p>Args is given by hexo tag api, we can pass argument to tag.<br>so we combine style name into bs classes, this is the code.</p></div><div class="card-footer"><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postbadge</span> (<span class="params">args</span>) </span>{</span><br><span class="line">    args = args.join(<span class="string">' '</span>).split(<span class="string">'@'</span>);</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'secondary'</span>;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;span class="badge badge-'</span> + classes + <span class="string">'"&gt;'</span> + text + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="card bg-default  my-3"><div class="card-body"><p><span class="badge badge-primary">Primary</span> <span class="badge badge-secondary">Secondary</span> <span class="badge badge-success">Success</span> <span class="badge badge-danger">Danger</span> <span class="badge badge-warning">Warning</span>  <span class="badge badge-info">Info</span> <span class="badge badge-light">Light</span>  <span class="badge badge-dark">Dark</span></p></div><div class="card-footer"><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{% badge primary @Primary %}</span><br><span class="line">{% badge secondary @Secondary %}</span><br><span class="line">{% badge success @Success %}</span><br><span class="line">{% badge danger @Danger %}</span><br><span class="line">{% badge warning @Warning %}</span><br><span class="line">{% badge info @Info %}</span><br><span class="line">{% badge light @Light %}</span><br><span class="line">{% badge dark @Dark %}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Content">Content<a class="header-anchor" href="#Content">#</a></h3><p>This is how content show.</p><div class="card bg-default  my-3"><div class="card-body"><p>Content is given by hexo tag api, this is a string inside tag (of course markdown). We can use hexo render engine to show it.</p></div><div class="card-footer"><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postbadge</span> (<span class="params">args</span>) </span>{</span><br><span class="line">    args = args.join(<span class="string">' '</span>).split(<span class="string">'@'</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> text = args[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;span class="badge badge-'</span> + classes + <span class="string">'"&gt;'</span> + text + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Remind">Remind<a class="header-anchor" href="#Remind">#</a></h3><p>This badge styling is using <a href="https://getbootstrap.com/docs/4.4/" target="_blank" rel="noopener">Bootstrap</a> v4.4, so you need to include bs stylesheet in <code>&lt;head&gt;</code>.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Latest compiled and minified CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Example">Example<a class="header-anchor" href="#Example">#</a></h2><figure class="highlight md"><table><tbody><tr><td class="code"><pre><span class="line">{% badge @badge content %}</span><br></pre></td></tr></tbody></table></figure><p>So this is the correct code I wrote in the top. badge class should given by first argument</p><figure class="highlight mel"><table><tbody><tr><td class="code"><pre><span class="line">{% badge primary @Stuff %} </span><br><span class="line">{% badge secondary @Stuff %} </span><br><span class="line">{% badge success @Stuff %} </span><br><span class="line">{% badge info @Stuff %} </span><br><span class="line">{% badge <span class="keyword">warning</span> @Stuff %} </span><br><span class="line">{% badge danger @Stuff %}</span><br><span class="line">{% badge light @Stuff %}</span><br><span class="line">{% badge dark @Stuff %}</span><br></pre></td></tr></tbody></table></figure><p>If not given classes, it will also show secondary classes. So this two are equal.</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> @Stuff %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> secondary @Stuff %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>And content should put after a <code>@</code></p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">badge</span> @Content here %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><hr><p>That is, how does a badge work on hexo by using tag plugins. You can find source code about this website in <a href="https://github.com/luswdev/HackTeck/tree/master" target="_blank" rel="noopener">github</a> if you want to learn more.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> bootstrap </tag>
            
            <tag> tag plugin </tag>
            
            <tag> badge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add Bootstrap Card Tags into Hexo</title>
      <link href="/posts/hexo/add-bs-card.html"/>
      <url>/posts/hexo/add-bs-card.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Bootstrap-Card">Bootstrap Card<a class="header-anchor" href="#Bootstrap-Card">#</a></h2><div class="card bg-default  my-3"><div class="card-header"><p>card header content</p></div><div class="card-body"><p>card content</p></div><div class="card-footer"><p>card footer</p></div></div><p>So this is a card given by <a href="https://getbootstrap.com/docs/4.4/components/card/" target="_blank" rel="noopener">bootstrap</a>, we can add this into hexo just simply write some <span class="badge badge-warning">HTML</span> like this.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card card-default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>card header content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-body"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>card content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>card footer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>But this kind of things is not like <ins><em>Hexo</em></ins> style, and hardly to modify.<br>Luckly, Hexo is giving us some api call <a href="https://hexo.io/api/tag" target="_blank" rel="noopener"><strong>tag plugin</strong></a>, so let made a tag to insert a card!</p><hr><h2 id="Tag-Plugin">Tag Plugin<a class="header-anchor" href="#Tag-Plugin">#</a></h2><p>So what is actually tag plugin is? This is the answer of Hexo doc.</p><div class="alert alert-secondary"><p>A tag allows users to quickly and easily insert snippets into their posts.</p></div><p>As you see, we can simply build a tag and it will render a block our want. A example is above. This <strong>Bs Alert</strong> block is write down in <code>.md</code> like this:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">alert</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">blah blah</span></span><br><span class="line"><span class="xml">blah more</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endalert</span>%}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>And this tag is named by <em>note</em>. OK, let we get started to build card tag.</p><hr><h2 id="card-Tag">card Tag<a class="header-anchor" href="#card-Tag">#</a></h2><h3 id="card-js">card.js<a class="header-anchor" href="#card-js">#</a></h3><p>First things to do, new a file call <em>card.js</em> and put into <code>scripts</code> directory in current theme’s directory:</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /path/to/your/current/theme/dir/script/card.js</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p>if <code>scripts</code> directory is not existed, first new a directory.</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /path/to/your/current/theme/dir/script</span></span><br></pre></td></tr></tbody></table></figure></div><p>Then, write down this into lastest javascript file (card.js).</p><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * card.js | global hexo script.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * {% card class %}</span></span><br><span class="line"><span class="comment"> * &lt;!-- header --&gt;</span></span><br><span class="line"><span class="comment"> * Any content (support inline tags too).</span></span><br><span class="line"><span class="comment"> *  &lt;!-- endheader --&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Any content (support inline tags too).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;!-- footer --&gt;</span></span><br><span class="line"><span class="comment"> * Any content (support inline tags too).</span></span><br><span class="line"><span class="comment"> *  &lt;!-- endfooter --&gt;</span></span><br><span class="line"><span class="comment"> * {% endcard %}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cardContent</span> (<span class="params">args, content</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line">    <span class="keyword">var</span> textClass = (classes != <span class="string">'default'</span> &amp;&amp; classes != <span class="string">'light'</span> ) ? <span class="string">' text-white'</span> : <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> rHeading = <span class="regexp">/&lt;!--\s*header\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endheader\s*--&gt;/g</span>;</span><br><span class="line">    <span class="keyword">var</span> rFooter = <span class="regexp">/&lt;!--\s*footer\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endfooter\s*--&gt;/g</span>;</span><br><span class="line">    <span class="keyword">var</span> heading = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> footer = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="string">'&lt;div class="card bg-'</span> + classes + <span class="string">' '</span> + textClass + <span class="string">' mt-3 mb-3"&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heading = rHeading.exec(content)) {</span><br><span class="line">        content = content.replace(rHeading, <span class="string">''</span>);</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="card-header"&gt;'</span> </span><br><span class="line">        returnVal += hexo.render.renderSync({<span class="attr">text</span>: heading[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (footer = rFooter.exec(content)) {</span><br><span class="line">        content = content.replace(rFooter, <span class="string">''</span>);</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="card-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="card-footer"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: footer[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        returnVal += <span class="string">'&lt;div class="card-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnVal;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">hexo.extend.tag.register(<span class="string">'card'</span>, cardContent, { <span class="attr">ends</span>: <span class="literal">true</span> });</span><br></pre></td></tr></tbody></table></figure><p>In line 47, we registed a tag name card, and next time we write something like below , it will show like bs card.</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">card stuff</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Classes">Classes<a class="header-anchor" href="#Classes">#</a></h3><p>card has some <a href="https://getbootstrap.com/docs/4.4/components/card/#background-and-color" target="_blank" rel="noopener">different styles</a>, we can use args to implement it.</p><div class="card bg-default  my-3"><div class="card-body"><p>Args is given by hexo tag api, we can pass argument to tag.<br>so we combine style name into bs classes, this is the code.</p></div><div class="card-footer"><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cardContent</span> (<span class="params">args, content</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> classes = args[<span class="number">0</span>] || <span class="string">'default'</span>;</span><br><span class="line">    <span class="keyword">var</span> textClass = (classes != <span class="string">'default'</span> &amp;&amp; classes != <span class="string">'light'</span> ) ? <span class="string">' text-white'</span> : <span class="string">''</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="string">'&lt;div class="card bg-'</span> + classes + <span class="string">' '</span> + textClass + <span class="string">' mt-3 mb-3"&gt;'</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="card bg-default  my-3"><div class="card-body"><div class="card bg-default  my-3"><div class="card-header"><p>Default card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-primary  text-white my-3"><div class="card-header"><p>Primary card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-secondary  text-white my-3"><div class="card-header"><p>Secondary card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-success  text-white my-3"><div class="card-header"><p>Success card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-danger  text-white my-3"><div class="card-header"><p>Danger card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-warning  text-white my-3"><div class="card-header"><p>Warning card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-info  text-white my-3"><div class="card-header"><p>Info card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-light  my-3"><div class="card-header"><p>Light card</p></div><div class="card-body"><p>card content</p></div></div><div class="card bg-dark  text-white my-3"><div class="card-header"><p>Dark card</p></div><div class="card-body"><p>card content</p></div></div></div><div class="card-footer"><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{% card default %}...{% endcard %}</span><br><span class="line">{% card primary %}...{% endcard %}</span><br><span class="line">{% card secondary %}...{% endcard %}</span><br><span class="line">{% card success %}...{% endcard %}</span><br><span class="line">{% card danger %}...{% endcard %}</span><br><span class="line">{% card warning %}...{% endcard %}</span><br><span class="line">{% card info %}...{% endcard %}</span><br><span class="line">{% card light %}...{% endcard %}</span><br><span class="line">{% card dark %}...{% endcard %}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Content">Content<a class="header-anchor" href="#Content">#</a></h3><p>This is how content show.</p><div class="card bg-default  my-3"><div class="card-body"><p>Content is given by hexo tag api, this is a string inside tag (of course markdown). We can use hexo render engine to show it.</p></div><div class="card-footer"><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cardContent</span> (<span class="params">args, content</span>) </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> returnVal = <span class="string">'&lt;div class="card bg-'</span> + classes + <span class="string">' '</span> + textClass + <span class="string">' mt-3 mb-3"&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    returnVal += <span class="string">'&lt;div class="card-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="header-and-Footer">header and Footer<a class="header-anchor" href="#header-and-Footer">#</a></h3><p>card header and footer is also given in bs, so we can implement it.</p><div class="card bg-default  my-3"><div class="card-header"><p><strong>Card Header</strong></p></div><div class="card-body"><p>This is how header work.</p><ol><li>First, you must put your header content between <code>&lt;!-- header --&gt;</code> and <code>&lt;!-- endheader --&gt;</code>.</li><li>In <em>card.js</em>, we use RegExp to find correct header content.</li><li>RegExp for header is line 1.</li><li>After finding, we render this stuff by using hexo render engine.</li></ol></div><div class="card-footer"><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rheader = <span class="regexp">/&lt;!--\s*header\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endheader\s*--&gt;/g</span>;</span><br><span class="line"><span class="keyword">if</span> (heading = rHeading.exec(content)) {</span><br><span class="line">    content = content.replace(rHeading, <span class="string">''</span>);</span><br><span class="line">    returnVal += <span class="string">'&lt;div class="card-header"&gt;'</span> </span><br><span class="line">    returnVal += hexo.render.renderSync({<span class="attr">text</span>: heading[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="card bg-default  my-3"><div class="card-header"><p><strong>Card Footer</strong></p></div><div class="card-body"><p>This is how footer work.</p><ol><li>First, you must put your header content between <code>&lt;!-- footer --&gt;</code> and <code>&lt;!-- endfooter --&gt;</code>.</li><li>In <em>card.js</em>, we use RegExp to find currect footer content.</li><li>RegExp for footer is line 1.</li><li>After finding, we render this stuff by using hexo render engine.</li></ol></div><div class="card-footer"><figure class="highlight js line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rFooter = <span class="regexp">/&lt;!--\s*footer\s*--&gt;\n([\w\W\s\S]*?)&lt;!--\s*endfooter\s*--&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (footer = rFooter.exec(content)) {</span><br><span class="line">    content = content.replace(rFooter, <span class="string">''</span>);</span><br><span class="line">    returnVal += <span class="string">'&lt;div class="card-body"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">    returnVal += <span class="string">'&lt;div class="card-footer"&gt;'</span> + hexo.render.renderSync({<span class="attr">text</span>: footer[<span class="number">1</span>], <span class="attr">engine</span>: <span class="string">'markdown'</span>}).trim() + <span class="string">'&lt;/div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h3 id="Remind">Remind<a class="header-anchor" href="#Remind">#</a></h3><p>This card styling is using <a href="https://getbootstrap.com/docs/4.4/" target="_blank" rel="noopener">Bootstrap</a> v4.4, so you need to include bs stylesheet in <code>&lt;head&gt;</code>.</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Latest compiled and minified CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Example">Example<a class="header-anchor" href="#Example">#</a></h2><figure class="highlight md"><table><tbody><tr><td class="code"><pre><span class="line">{% card %}</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- header  --&gt;</span></span></span><br><span class="line">card header content</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endheader --&gt;</span></span></span><br><span class="line">card content</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- footer --&gt;</span></span></span><br><span class="line">card footer</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endfooter --&gt;</span></span></span><br><span class="line">{% endcard %}</span><br></pre></td></tr></tbody></table></figure><p>So this is the correct code I wrote in the top. card box in the tag of:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>And header should put in:</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- endheader --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>Also footer should put in:</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- footer --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- endfooter --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>And this is support classes:</p><figure class="highlight django"><table><tbody><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> default %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> primary %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> secondary %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> success %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> danger %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> warning %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> info %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> light %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">{% <span class="name">card</span> dark %}</span><span class="xml">...</span><span class="template-tag">{% <span class="name">endcard</span> %}</span><span class="xml"></span></span><br></pre></td></tr></tbody></table></figure><p>If not given classes, it will also show default classes. So this two are equal.</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">{% card<span class="built_in"> default </span>%}<span class="built_in">..</span>.{% endcard %}</span><br><span class="line">{% card %}<span class="built_in">..</span>.{% endcard %}</span><br></pre></td></tr></tbody></table></figure><hr><p>That is, how does a card work on hexo by using tag plugins. You can find source code about this website in <a href="https://github.com/luswdev/HackTeck/tree/master" target="_blank" rel="noopener">github</a> if you want to learn more.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> card </tag>
            
            <tag> bootstrap </tag>
            
            <tag> tag plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 語言 - 位元欄位</title>
      <link href="/posts/CLang/c-bit-operation.html"/>
      <url>/posts/CLang/c-bit-operation.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 C 語言中，如果我們要對特定的 bit(s) 做操作的話，最直覺的方式是用 bit and（<code>&amp;</code>）跟 bit or（<code>|</code>）：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bit_sample = <span class="number">0x0123</span>; <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將第 2 個 bit 改成 1 */</span></span><br><span class="line">bit_samplee |= (<span class="number">0x1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將第 5 個 bit 改成 1 */</span></span><br><span class="line">bit_samplee |= ~(<span class="number">0x1</span> &lt;&lt; <span class="number">5</span>); <span class="comment">/* 0000 0001 0010 0011 */</span></span><br></pre></td></tr></tbody></table></figure><p>從上面的例子可以看到如何使用 bit and/or 來操作特定的 bit，這種方式對於單一個 bit 並不會太麻煩，但有以下缺點：</p><ul><li>無法覆用：這種方式不能快速地建立一個方法，也比較不好理解</li><li>對於區間上就不好使了</li></ul><p>如果要解決上述缺點，有一個方式是使用 <code>union</code>，一個在嵌入式、驅動程式裡常常用到的方法。</p><hr><h2 id="Union">Union<a class="header-anchor" href="#Union">#</a></h2><p><code>union</code> 是 C 語言裡面可以對一個結構裡面的元素，可以有不同的資料型態去理解，如以下例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> sample {</span><br><span class="line">    <span class="keyword">int</span> sample_int;</span><br><span class="line">    <span class="keyword">char</span> sample_str[<span class="number">4</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>需要注意的是：同一時間內只能存取一個屬性，準確來說他們是共用一個記憶體區塊，所以改第一個值第二個值會同時更改。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[[C 語言] 程式設計教學：如何使用聯合 (Union)](https://michaelchen.tech/c-programming/union/)">[1]</span></a></sup></p></blockquote><h3 id="struct">struct<a class="header-anchor" href="#struct">#</a></h3><p>奇怪，不是在講 <code>union</code> 嗎，怎麼會提到 <code>struct</code> 呢？那是因為 C 裡面有一個有趣的東西叫做位元欄位<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[位元欄](https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5)">[2]</span></a></sup>，這個東西必須搭配結構使用；先看例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit_row</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> row1 : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> row2 : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> row3 : <span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>乍看之下好像跟一般的結構差不多，可是我們注意到在每個元素宣告的結尾多了一個 <code>: 數字</code>，這是什麼意思？</p><ol><li>首先，<code>unsigned short</code> 在 64 位元裡大小是 4位，<code>unsigned int</code> 則是 8位</li><li>加上 <code>: 數字</code>，這個東西就叫位元欄位，我們可以限制當前元素的大小</li><li>因此，元素 1 的大小就被我們縮至 1 位，依此類推</li></ol><hr><p>有了上述的<strong>工具</strong>就可以建立一個好用而且好理解的位元操作方法！</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5to7 : <span class="number">3</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>建立好上面這個 union 後，如果要將某一個整數的第 3 到 4 位 的值改掉，可以這樣寫</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex int_ex;</span><br><span class="line">int_ex.real_val = <span class="number">0x0123</span>; <span class="comment">/* 0000 0001 0010 0011 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* change 3 and 4 bits to 01 */</span></span><br><span class="line">int_ex.bits.bit3and4 = B01; <span class="comment">/* 0000 0001 0010 1011 */</span></span><br></pre></td></tr></tbody></table></figure><p>這樣的寫法，更簡單，更易懂。</p><hr><h3 id="剩下的空間">剩下的空間<a class="header-anchor" href="#剩下的空間">#</a></h3><p>值得注意的一件事，我們沿用上面的例子；<code>method_ex</code> 有一個元素叫<em>真正的值</em>，他是一個整數（8 位），剛好另外一個元素我們使用位元欄位的技巧也控制在 8 位；但，如果我們沒有這麼做呢？</p><div class="alert alert-warning"><p>答案是：你可以這麼寫，不會有什麼問題，但不建議。</p></div><h4 id="更大">更大<a class="header-anchor" href="#更大">#</a></h4><p>如果 <code>bits</code> 結構今天大於 8 位，那我們就沒辦法透過更改<em>真正的值</em>來改變到高於 8 位的值，因此這麼做是<strong>沒意義</strong>的。</p><h4 id="更小">更小<a class="header-anchor" href="#更小">#</a></h4><p>如果 <code>bits</code> 結構今天小於 8 位，這麼做完全不會有任何問題，但習慣上，我們會把它補齊，像是我們在 <a href="/c-attribute">attribute</a> 篇裡提到的 padding。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5and6 : <span class="number">2</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>沒有定義第 7 位</p></div><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> method_ex {</span><br><span class="line">    <span class="keyword">int</span> real_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> {</span></span><br><span class="line">        <span class="keyword">short</span> bit0to2 : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">short</span> bit3and4 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> bit5and6 : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> notused : <span class="number">1</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>隨便取名，只要有定義就好</p></div><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://michaelchen.tech/c-programming/union/" target="_blank" rel="noopener">[C 語言] 程式設計教學：如何使用聯合 (Union)</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5" target="_blank" rel="noopener">位元欄</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C語言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C語言 </tag>
            
            <tag> Bit field </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何查看 Linux 被佔用的 port</title>
      <link href="/posts/linux/lookup-port.html"/>
      <url>/posts/linux/lookup-port.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>當我們下 <code>hexo s</code> 後，預設將會開啟 <code>:4000</code>，但如果 <code>:4000</code> 被佔用就會報錯；為解決此問題，我們必須知道是哪個行程佔用，並 <code>kill</code> 它。<br>以下我們介紹 2 種 Linux 的指令。</p></blockquote><h2 id="lsof">lsof<a class="header-anchor" href="#lsof">#</a></h2><p>lsof (List Open Files)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Linux 列出行程開啟的檔案，lsof 指令用法教學與範例](https://blog.gtwang.org/linux/linux-lsof-command-list-open-files-tutorial-examples/)">[1]</span></a></sup>，可以列出所有被行程打開的檔案。可以利用 <code>-i</code> 來查找所有網路連線；於是</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i</span></span><br></pre></td></tr></tbody></table></figure><p>將會列出所有使用 port 的行程。而有時候有些 port 會有別名，為了方便找查，我們加上 <code>-P</code> (列出實際的 port number)；於是</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i -P</span></span><br></pre></td></tr></tbody></table></figure><p>最後為了簡化結果，我們將原本的結果傳給 <code>grep</code></p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsof -i -P | grep :4000</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p><code>:4000</code> 可任意改成想要的 port number，如 <code>:1234</code></p></div><h2 id="netstat">netstat<a class="header-anchor" href="#netstat">#</a></h2><p>netstat 可以用來查看各種網路狀態，一樣可以拿來查找被佔用的 port。</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -tulpn</span></span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li><code>-t</code> 代表找走 <code>TCP</code> 協定的</li><li><code>-u</code> 代表找走 <code>UDP</code> 協定的</li><li><code>-l</code> 代表找 <code>LISTEN</code> 的 socket</li><li><code>-n</code> 代表顯示硬體名稱，<code>-p</code> 代表顯示 PID。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[netstat Command Usage on Linux](https://geekflare.com/netstat/)">[2]</span></a></sup></li></ul><p>我們一樣可以用 <code>grep</code> 來協助尋找</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -tulpn | grep :4000</span></span><br></pre></td></tr></tbody></table></figure><hr><ul><li>Reference<ul><li><a href="https://www.opencli.com/linux/3-way-check-linux-listen-port" target="_blank" rel="noopener">3 種 Linux 查看 port 被程式佔用的方法</a></li></ul></li></ul><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.gtwang.org/linux/linux-lsof-command-list-open-files-tutorial-examples/" target="_blank" rel="noopener">Linux 列出行程開啟的檔案，lsof 指令用法教學與範例</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://geekflare.com/netstat/" target="_blank" rel="noopener">netstat Command Usage on Linux</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> lsof </tag>
            
            <tag> netstat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 的 &quot;init&quot; 行程</title>
      <link href="/posts/linux/init-number.html"/>
      <url>/posts/linux/init-number.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="init-行程">init 行程<a class="header-anchor" href="#init-行程">#</a></h2><p>init 行程（process/task）是 Linux 內核下的第一個行程，內核會在初始化完硬體後建立該行程。</p><blockquote><p>如 <a href="https://blog.lusw.dev/starting-xv6/#toc-heading-3">XV6 啟動流程</a> 中提到的 <code>userinit()</code></p></blockquote><p>正常來說 init 應該被放在 <code>/sbin/init</code> 中，如果內核找不到，會試著在 <code>/bin/sh</code> 中尋找，若都失敗則將導致<strong>啟動失敗</strong>。</p><h2 id="init-等級">init 等級<a class="header-anchor" href="#init-等級">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>等級</th><th>用途</th></tr></thead><tbody><tr><td>0</td><td>關機</td></tr><tr><td>1</td><td>single user mode</td></tr><tr><td>6</td><td>重新啟動</td></tr></tbody></table></div><ul><li>對於 2 ~ 5，不同的發行版有不同的解釋，大部分的系統中：<ul><li>3 代表正常啟動 CLI</li><li>5 代表正常啟動 GUI</li></ul></li></ul><hr><ul><li>Reference<ul><li><a href="https://blog.csdn.net/cougar_mountain/article/details/9798191" target="_blank" rel="noopener">linux 下的init 0，1，2，3，4，5，6知识介绍</a></li><li><a href="http://felix-lin.com/linux/init%E6%BC%94%E5%8C%96%E6%AD%B7%E7%A8%8B-%E8%BD%89%E8%B2%BC-%E6%B7%BA%E6%9E%90-linux-%E5%88%9D%E5%A7%8B%E5%8C%96-init-%E7%B3%BB%E7%B5%B1%EF%BC%8C%E7%AC%AC-1-%E9%83%A8%E5%88%86-sysvinit/" target="_blank" rel="noopener">init演化歷程 – [轉貼] 淺析 Linux 初始化 init 系統，第 1 部分: sysvinit</a></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> Linux </tag>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Xcode 中為免費開發者帳戶重新建立憑證</title>
      <link href="/posts/renew-xcode-profile.html"/>
      <url>/posts/renew-xcode-profile.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="免費帳戶憑證">免費帳戶憑證<a class="header-anchor" href="#免費帳戶憑證">#</a></h2><p>免費版開發者帳戶的憑證有效期限只有 7 天，可以參考此連結。<br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%85%8D%E8%B2%BB%E9%96%8B%E7%99%BC%E5%B8%B3%E8%99%9F%E7%9A%84-ios-app-%E5%91%BD%E4%B8%AD%E6%B3%A8%E5%AE%9A%E5%8F%AA%E8%83%BD%E6%B4%BB%E4%B8%83%E5%A4%A9-8fd2cc849bfb" target="_blank" rel="noopener">免費開發帳號的 iOS App 命中注定只能活七天 !</a></p><p>理論上來說，超過期限只要重新從 Xcode 安裝 App 就會自動重簽 (renew)，但如果在期限內想要直接延期呢？</p><h2 id="建立新的憑證">建立新的憑證<a class="header-anchor" href="#建立新的憑證">#</a></h2><p>如果想要直接延期，唯一的方法只有重新建立一個憑證：</p><ul><li><p>從 Preference 中的 Accounts<br><div class="img-item" data-src="https://i.imgur.com/JfTJGet.png" data-sub-html=".caption"><img src="https://i.imgur.com/JfTJGet.png" alt="Preference ></div> Accounts"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">Preference ></div> Accounts</span></div></p></li><li><p>選擇右下角的 Manage Certificates…<br><div class="img-item" data-src="https://i.imgur.com/r5PAFur.png" data-sub-html=".caption"><img src="https://i.imgur.com/r5PAFur.png" alt="黃框處"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">黃框處</span></div></div></p></li><li><p>按下去，選擇左下角的 <code>+</code><br><div class="img-item" data-src="https://i.imgur.com/Q59J2Tj.png" data-sub-html=".caption"><img src="https://i.imgur.com/Q59J2Tj.png" alt="黃框處"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">黃框處</span></div></div></p></li><li><p>選擇 Apple Development<br><div class="img-item" data-src="https://i.imgur.com/bSelwuz.png" data-sub-html=".caption"><img src="https://i.imgur.com/bSelwuz.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p></li></ul><p>之後就會新增一個憑證，可以回去 Targets 看憑證的確更新了。<br><div class="img-item" data-src="https://i.imgur.com/9MsNUqd.png" data-sub-html=".caption"><img src="https://i.imgur.com/9MsNUqd.png" alt="紅字"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">紅字</span></div></div></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3選擇器 :not()</title>
      <link href="/posts/css-not-selecter.html"/>
      <url>/posts/css-not-selecter.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="用途">用途<a class="header-anchor" href="#用途">#</a></h2><p>假設有多個一樣 <code>label</code> 的元素要套用一種樣式，但又有幾個需要排除在外時使用。</p><h3 id="例子">例子<a class="header-anchor" href="#例子">#</a></h3><div class="card bg-default  my-3"><div class="card-body"><style>.ex-box {    text-align: center;}.ex {    color: #f00;    font-style: italic;    font-weight: bold;}</style><div class="ex-box"><span class="ex">1</span>    <span class="ex">2</span>    <span class="ex">3</span>    <span class="ex">4</span></div></div><div class="card-footer"><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ex-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ex"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.ex-box</span> {</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.ex</span> {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="alert alert-info"><p>可以看到上面：1~4 都有<em>斜體</em>跟<strong>粗體</strong>，為了方便觀察，這裡讓文字變為紅色</p></div><hr><div class="card bg-default  my-3"><div class="card-header"><p>接著將 3 號加上 <code>not-ex-ignored</code> 的 id，並將此 id 略過（使用 <code>:not</code> 選擇器）</p></div><div class="card-body"><style>.not-ex-box {    text-align: center;}.not-ex:not(#not-ex-ignored) {    color: #f00;    font-style: italic;    font-weight: bold;}</style><div class="not-ex-box"><span class="not-ex">1</span>    <span class="not-ex">2</span>    <span class="not-ex" id="not-ex-ignored">3</span>    <span class="not-ex">4</span></div></div><div class="card-footer"><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"not-ex-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span> <span class="attr">id</span>=<span class="string">"not-ex-ignored"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"not-ex"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.not-ex-box</span> {</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.not-ex</span><span class="selector-pseudo">:not(</span><span class="selector-id">#not-ex-ignored</span>) {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="alert alert-info"><p>如此一來，就只有三號沒有套用到屬性。</p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl 模組安裝</title>
      <link href="/posts/perl-install-module.html"/>
      <url>/posts/perl-install-module.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="使用自動安裝的環境">使用自動安裝的環境<a class="header-anchor" href="#使用自動安裝的環境">#</a></h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> perl -MCPAN -e shell</span></span><br></pre></td></tr></tbody></table></figure><ul><li>類似於 <code>apt</code>、<code>brew</code> 的好用套件，輸入指令會進入此環境中，成功的話終端機會顯示此畫面:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cman&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安裝">安裝<a class="header-anchor" href="#安裝">#</a></h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cman&gt; install Module::Name</span></span><br></pre></td></tr></tbody></table></figure><ul><li>直接下 install 指令 後面接模組名稱即可。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Arduino 上使用中斷</title>
      <link href="/posts/arduino-interrupt.html"/>
      <url>/posts/arduino-interrupt.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="新增中斷">新增中斷<a class="header-anchor" href="#新增中斷">#</a></h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">attachInterrupt</span>(digitalPinToInterrupt(pin), ISR, mode);</span><br><span class="line"><span class="built_in">attachInterrupt</span>(interrupt, ISR, mode);</span><br><span class="line"><span class="built_in">attachInterrupt</span>(pin, ISR, mode);</span><br></pre></td></tr></tbody></table></figure><ul><li>有三種可選：<ul><li>第一個參數代表幾號中斷或是幾號 pin，通常用第一種寫法最保險</li><li>第二個參數放 ISR，當中斷發生時要做的事</li><li>第三個參數為發生中斷的模式，下面有詳細介紹</li></ul></li></ul><h3 id="模式">模式<a class="header-anchor" href="#模式">#</a></h3><ul><li>LOW：當 pin 處於低電位的時候觸發中斷</li><li>RISING：當 pin 從低電位轉為高電位時觸發中斷</li><li>FALLING：當 pin 從高電位轉為高電位時觸發中斷</li><li>CHANGE：當 pin 的電位發生改變時觸發中斷</li><li>HIGH：當 pin 處於高電位時觸發中斷（只適用 arduino due）</li></ul><h2 id="移除中斷">移除中斷<a class="header-anchor" href="#移除中斷">#</a></h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">detachInterrupt</span>(digitalPinToInterrupt(pin));</span><br><span class="line"><span class="built_in">detachInterrupt</span>(interrupt);</span><br><span class="line"><span class="built_in">detachInterrupt</span>(pin);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣有三個寫法，與新增中斷的第一個參數相同。</li></ul><h2 id="關閉-開啟中斷">關閉/開啟中斷<a class="header-anchor" href="#關閉-開啟中斷">#</a></h2><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">noInterrupts</span>();</span><br><span class="line"><span class="built_in">interrupts</span>();</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-warning"><p><code>noInterrupts</code> 不會將 <code>reset</code> 中斷關閉。</p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
            <tag> interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 ANSI 跳脫碼印出有色文字</title>
      <link href="/posts/ascii-color.html"/>
      <url>/posts/ascii-color.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ANSI-跳脫碼">ANSI 跳脫碼<a class="header-anchor" href="#ANSI-跳脫碼">#</a></h2><p>ANSI 跳脫碼，即 ASCII Escape Code，標準 CSI 格式為</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">CSI n1 [;n2 [;...]] m</span><br></pre></td></tr></tbody></table></figure><ul><li><code>n1</code> 通常填入 <code>\x1b</code>，在 ASCII 表中 <code>0x1b</code> 代表著 escape。</li><li><code>n1</code>、<code>n2</code> 為 <strong>SGR (Select Graphic Rendition)</strong>，可參考表格對應相對的值。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[[Linux C] ANSI逃脫碼與printf顏色教學](http://naeilproj.blogspot.com/2015/08/linux-c-c-printf.html)">[1]</span></a></sup></li></ul><h2 id="顏色輸出">顏色輸出<a class="header-anchor" href="#顏色輸出">#</a></h2><h3 id="範例：粗紅體">範例：粗紅體<a class="header-anchor" href="#範例：粗紅體">#</a></h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">\x1b[;<span class="number">31</span>;<span class="number">1</span>m</span><br></pre></td></tr></tbody></table></figure><ul><li>SGR 30~37 代表著顏色，可參照此表格<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[ANSI跳脫序列](https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)">[2]</span></a></sup><br><div class="img-item" data-src="https://i.imgur.com/8HEFwxZ.png" data-sub-html=".caption"><img src="https://i.imgur.com/8HEFwxZ.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li><li>後面的 1 代表粗體，不寫則為一般字型；通常一般的終端機會將粗體顯示成較亮的顏色，而非粗體。</li><li>有些終端機提供用高位的數字指定較亮的顏色，90-97 及 100-107，如下圖<br><div class="img-item" data-src="https://i.imgur.com/mEP8AjU.png" data-sub-html=".caption"><img src="https://i.imgur.com/mEP8AjU.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li></ul><h3 id="xterm-256color">xterm-256color<a class="header-anchor" href="#xterm-256color">#</a></h3><ul><li>使用 8 位元的 SGR，進而提供 256 色的輸出。<br><div class="img-item" data-src="https://i.imgur.com/hjjHfve.png" data-sub-html=".caption"><img src="https://i.imgur.com/hjjHfve.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li></ul><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://naeilproj.blogspot.com/2015/08/linux-c-c-printf.html" target="_blank" rel="noopener">[Linux C] ANSI逃脫碼與printf顏色教學</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">ANSI跳脫序列</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C語言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C語言 </tag>
            
            <tag> ANSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread GUI -  Drawable Canvas HW</title>
      <link href="/posts/RT-Thread/gui-dc-hw.html"/>
      <url>/posts/RT-Thread/gui-dc-hw.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>rtgui 中的 dc 也就是繪圖引擎，可以說是 rtgui 中最重要的一個部分，其中分成 3 個部分：給硬體的 dc_hw、給 buffer 的 dc_buffer 以及給 client 的。</p><p>接下來將會追蹤 dc_hw 中的程式碼，分析 rtgui 是如何在螢幕上面描繪點線面。</p><hr><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><h3 id="dc">dc<a class="header-anchor" href="#dc">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> dc.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The abstract device context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Normally, a DC is a drawable canvas, user can draw point/line/cycle etc</span></span><br><span class="line"><span class="comment"> * on the DC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are several kinds of DC:</span></span><br><span class="line"><span class="comment"> * - Hardware DC;</span></span><br><span class="line"><span class="comment"> * - Client DC;</span></span><br><span class="line"><span class="comment"> * - Buffer DC;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* type of device context */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dc engine */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> *<span class="title">engine</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="dc-engine">dc_engine<a class="header-anchor" href="#dc-engine">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* interface */</span></span><br><span class="line">    <span class="keyword">void</span> (*draw_point)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">void</span> (*draw_color_point)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">rtgui_color_t</span> color);</span><br><span class="line">    <span class="keyword">void</span> (*draw_vline)(struct rtgui_dc *dc, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2);</span><br><span class="line">    <span class="keyword">void</span> (*draw_hline)(struct rtgui_dc *dc, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">void</span> (*fill_rect)(struct rtgui_dc *dc, <span class="keyword">rtgui_rect_t</span> *rect);</span><br><span class="line">    <span class="keyword">void</span> (*blit_line)(struct rtgui_dc *dc, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y, <span class="keyword">rt_uint8_t</span> *line_data);</span><br><span class="line">    <span class="keyword">void</span> (*blit)(struct rtgui_dc *dc, struct rtgui_point *dc_point, struct rtgui_dc *dest, <span class="keyword">rtgui_rect_t</span> *rect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*fini)(struct rtgui_dc *dc);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="dc-hw">dc_hw<a class="header-anchor" href="#dc-hw">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The hardware device context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The hardware DC is a context based on hardware device, for examle the</span></span><br><span class="line"><span class="comment"> * LCD device. The operations on the hardware DC are reflected to the real</span></span><br><span class="line"><span class="comment"> * hardware.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> <span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *owner;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_graphic_driver</span> *<span class="title">hw_driver</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="hw-engine">hw_engine<a class="header-anchor" href="#hw-engine">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> dc_hw.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> <span class="title">dc_hw_engine</span> =</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    rtgui_dc_hw_draw_point,</span><br><span class="line">    rtgui_dc_hw_draw_color_point,</span><br><span class="line">    rtgui_dc_hw_draw_vline,</span><br><span class="line">    rtgui_dc_hw_draw_hline,</span><br><span class="line">    rtgui_dc_hw_fill_rect,</span><br><span class="line">    rtgui_dc_hw_blit_line,</span><br><span class="line">    rtgui_dc_hw_blit,</span><br><span class="line"></span><br><span class="line">    rtgui_dc_hw_fini,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="啟動-dc">啟動 dc<a class="header-anchor" href="#啟動-dc">#</a></h2><p>我們可以從 rtgui 官方提供的範例發現，在使用 dc 前，需要先利用 <code>rtgui_dc_begin_drawing</code> 來啟動引擎，並在結束時呼叫 <code>rtgui_dc_end_drawing</code>；而啟動時，會判斷要使用哪種 dc，並啟動，如 1866 至 1871 行</p><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create client or hardware DC */</span></span><br><span class="line">    <span class="keyword">if</span> ((rtgui_region_is_flat(&amp;owner-&gt;clip) == RT_EOK) &amp;&amp;</span><br><span class="line">            rtgui_rect_is_equal(&amp;(owner-&gt;extent), &amp;(owner-&gt;clip.extents)) == RT_EOK)</span><br><span class="line">        dc = rtgui_dc_hw_create(owner);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dc = rtgui_dc_client_create(owner);</span><br></pre></td></tr></tbody></table></figure><p>如果判斷為 hw，則進入 <code>rtgui_dc_hw_create</code></p><hr><h2 id="建立-dc">建立 dc<a class="header-anchor" href="#建立-dc">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*owner</code></th></tr></thead><tbody><tr><td>建立 dc</td><td>dc 指標</td><td>dc 擁有者</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtgui_dc *<span class="title">rtgui_dc_hw_create</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *owner)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjudge owner */</span></span><br><span class="line">    <span class="keyword">if</span> (owner == RT_NULL || owner-&gt;toplevel == RT_NULL) <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create DC */</span></span><br><span class="line">    dc = (struct rtgui_dc_hw *) rtgui_malloc(<span class="keyword">sizeof</span>(struct rtgui_dc_hw));</span><br><span class="line">    <span class="keyword">if</span> (dc)</span><br><span class="line">    {</span><br><span class="line">        dc-&gt;parent.type = RTGUI_DC_HW;</span><br><span class="line">        dc-&gt;parent.engine = &amp;dc_hw_engine;</span><br><span class="line">        dc-&gt;owner = owner;</span><br><span class="line">        dc-&gt;hw_driver = rtgui_graphic_driver_get_default();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &amp;(dc-&gt;parent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="運作-dc-畫圖">運作 dc (畫圖)<a class="header-anchor" href="#運作-dc-畫圖">#</a></h2><h3 id="點">點<a class="header-anchor" href="#點">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>畫點</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*self</code></th><th><code>x</code></th><th><code>y</code></th></tr></thead><tbody><tr><td>dc 本體</td><td>座標 x</td><td>座標 y</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic point on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_point</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw this point */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;set_pixel(&amp;(dc-&gt;owner-&gt;gc.foreground), x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先傳進去的座標一律為邏輯位置，也就是以此 dc 所屬物件（有可能是視窗、元件等）的 $(x_1,y_1)$ 為原點之座標；由於 $(x_1,y_1)$ 為該物件（通常為矩形）的左下角，所以傳入的座標不會有負號。</p><p>接著將邏輯座標轉為實際座標（也就是螢幕上的真正位置），所以把 $(x,y)$ 轉成 $(x+x_1,y+y_1)$；由於 dc 是跟隨物件的，所以新座標不可超過 $(x_2,y_2)$，也就是右上角。</p><p>最後利用驅動中設定好的 <code>set_pixel</code> 函數來上色，這裡使用預設顏色。</p><hr><h3 id="彩色點">彩色點<a class="header-anchor" href="#彩色點">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>畫彩色點</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*self</code></th><th><code>x</code></th><th><code>y</code></th><th><code>color</code></th></tr></thead><tbody><tr><td>dc 本體</td><td>座標 x</td><td>座標 y</td><td>所選的顏色</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_color_point</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">rtgui_color_t</span> color)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw this point */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;set_pixel(&amp;color, x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟上面最大的不同是可以選顏色 (131)。</p><hr><h3 id="水平線">水平線<a class="header-anchor" href="#水平線">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic vertical line on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_vline</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    x = x + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y1 = y1 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    y2 = y2 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; y2)</span><br><span class="line">        _int_swap(y1, y2);</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; dc-&gt;owner-&gt;extent.y2 || y2 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y1 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        y1 = dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y2 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        y2 = dc-&gt;owner-&gt;extent.y2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw vline */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_vline(&amp;(dc-&gt;owner-&gt;gc.foreground), x, y1, y2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="鉛直線">鉛直線<a class="header-anchor" href="#鉛直線">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * draw a logic horizontal line on device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_draw_hline</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    x1 = x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">        _int_swap(x1, x2);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2 || x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* draw hline */</span></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_hline(&amp;(dc-&gt;owner-&gt;gc.foreground), x1, x2, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="矩形">矩形<a class="header-anchor" href="#矩形">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_fill_rect</span><span class="params">(struct rtgui_dc *self, struct rtgui_rect *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_color_t</span> color;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> y1, y2, x1, x2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    RT_ASSERT(rect);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get background color */</span></span><br><span class="line">    color = dc-&gt;owner-&gt;gc.background;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    x1 = rect-&gt;x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = rect-&gt;x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    y1 = rect-&gt;y1 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y1 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        y1 = dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    y2 = rect-&gt;y2 + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y2 &lt; dc-&gt;owner-&gt;extent.y1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y2 &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        y2 = dc-&gt;owner-&gt;extent.y2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill rect */</span></span><br><span class="line">    <span class="keyword">for</span> (; y1 &lt; y2; y1++)</span><br><span class="line">    {</span><br><span class="line">        dc-&gt;hw_driver-&gt;ops-&gt;draw_hline(&amp;color, x1, x2, y1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="blit">blit(?)<a class="header-anchor" href="#blit">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_blit_line</span><span class="params">(struct rtgui_dc *self, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y, <span class="keyword">rt_uint8_t</span> *line_data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_hw</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(self != RT_NULL);</span><br><span class="line">    dc = (struct rtgui_dc_hw *) self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert logic to device */</span></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    y = y + dc-&gt;owner-&gt;extent.y1;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; dc-&gt;owner-&gt;extent.y2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    x1 = x1 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    x2 = x2 + dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">        _int_swap(x1, x2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; dc-&gt;owner-&gt;extent.x2 || x2 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; dc-&gt;owner-&gt;extent.x1)</span><br><span class="line">        x1 = dc-&gt;owner-&gt;extent.x1;</span><br><span class="line">    <span class="keyword">if</span> (x2 &gt; dc-&gt;owner-&gt;extent.x2)</span><br><span class="line">        x2 = dc-&gt;owner-&gt;extent.x2;</span><br><span class="line"></span><br><span class="line">    dc-&gt;hw_driver-&gt;ops-&gt;draw_raw_hline(line_data, x1, x2, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_dc_hw_blit</span><span class="params">(struct rtgui_dc *dc,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct rtgui_point *dc_point,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct rtgui_dc *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* not blit in hardware dc */</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> GUI </tag>
            
            <tag> dc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread GUI - Server</title>
      <link href="/posts/RT-Thread/gui-server.html"/>
      <url>/posts/RT-Thread/gui-server.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基本事件結構">基本事件結構<a class="header-anchor" href="#基本事件結構">#</a></h2><p>server 掌管整個 GUI system 的所有事件 (event)，而根據不同的事件定義不同的結構；在每個不同的結構中都有基本的欄位 <code>_RTGUI_EVENT_WIN_ELEMENTS</code>：</p><div class="alert alert-success"><p><strong>File:</strong> event.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RTGUI Window Event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTGUI_EVENT_WIN_ELEMENTS \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span> <span class="title">parent</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">wid</span>;</span></span><br></pre></td></tr></tbody></table></figure><p><code>rtgui_event</code> 即為事件的基本結構：</p><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* the event type */</span></span><br><span class="line">    <span class="keyword">enum</span> _rtgui_event_type type;</span><br><span class="line">    <span class="comment">/* user field of event */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the event sender */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">sender</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox to acknowledge request */</span></span><br><span class="line">    <span class="keyword">rt_mailbox_t</span> ack;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event</span> <span class="title">rtgui_event_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="基本結構設定">基本結構設定<a class="header-anchor" href="#基本結構設定">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTGUI_EVENT_INIT(e, t)  do      \</span></span><br><span class="line">{                                       \</span><br><span class="line">    (e)-&gt;type = (t);                    \</span><br><span class="line">    (e)-&gt;user = <span class="number">0</span>;                      \</span><br><span class="line">    (e)-&gt;sender = rtgui_app_self();     \</span><br><span class="line">    (e)-&gt;ack = RT_NULL;                 \</span><br><span class="line">} <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="啟動-server">啟動 server<a class="header-anchor" href="#啟動-server">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> server.c</p></div><p>首先，定義一個 app 名叫 server :</p><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">rtgui_server_app</span> = <span class="title">RT_NULL</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>接著透過 <code>rtgui_server_entry</code> 啟動 app，也就是 server:</p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*parameter</code></th></tr></thead><tbody><tr><td>啟動 server</td><td>void</td><td>未使用</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rtgui server thread's entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtgui_server_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32_NATIVE</span></span><br><span class="line">    <span class="comment">/* set the server thread to highest */</span></span><br><span class="line">    HANDLE hCurrentThread = GetCurrentThread();</span><br><span class="line">    SetThreadPriority(hCurrentThread, THREAD_PRIORITY_HIGHEST);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create rtgui server application */</span></span><br><span class="line">    rtgui_server_app = rtgui_app_create(<span class="string">"rtgui"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_app == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"Create GUI server failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_object_set_event_handler(RTGUI_OBJECT(rtgui_server_app),</span><br><span class="line">                                   rtgui_server_event_handler);</span><br><span class="line">    <span class="comment">/* init mouse and show */</span></span><br><span class="line">    rtgui_mouse_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_USING_MOUSE_CURSOR</span></span><br><span class="line">    rtgui_mouse_show_cursor();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    rtgui_app_run(rtgui_server_app);</span><br><span class="line"></span><br><span class="line">    rtgui_app_destroy(rtgui_server_app);</span><br><span class="line">    rtgui_server_app = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最後會進入 <code>rtgui_app_run</code> 並正式開始執行 server，也就是進入所屬的 event handler</p><hr><h2 id="Event-Handler">Event Handler<a class="header-anchor" href="#Event-Handler">#</a></h2><p>Event handler 也就是 server 的進入點</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> GUI </tag>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread GUI - Window</title>
      <link href="/posts/RT-Thread/gui-window.html"/>
      <url>/posts/RT-Thread/gui-window.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> window.h</p></div><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* inherit from container */</span></span><br><span class="line">    <span class="keyword">rtgui_container_t</span> parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update count */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* drawing count */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> drawing;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">drawing_rect</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parent window. RT_NULL if the window is a top level window */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">parent_window</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_region</span> <span class="title">outer_clip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">outer_extent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget that will grab the focus in current window */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">focused_widget</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* which app I belong */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">app</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window style */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> style;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window state flag */</span></span><br><span class="line">    <span class="keyword">enum</span> rtgui_win_flag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rtgui_modal_code_t</span> modal_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* last mouse event handled widget */</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *last_mevent_widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* window title */</span></span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_wintitle</span> *_<span class="title">title_wgt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call back */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_activate)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_deactivate)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_close)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="comment">/* the key is sent to the focused widget by default. If the focused widget</span></span><br><span class="line"><span class="comment">     * and all of it's parents didn't handle the key event, it will be handled</span></span><br><span class="line"><span class="comment">     * by @func on_key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you want to handle key event on your own, it's better to overload</span></span><br><span class="line"><span class="comment">     * this function other than handle EVENT_KBD in event_handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_key)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved user data */</span></span><br><span class="line">    <span class="keyword">void</span> *user_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Private data. */</span></span><br><span class="line">    <span class="keyword">rt_base_t</span> (*_do_show)(struct rtgui_win *win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* app ref_count */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> app_ref_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* win magic flag, magic value is 0xA5A55A5A */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>magic;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="定義物件類型">定義物件類型<a class="header-anchor" href="#定義物件類型">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> window.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CLASS_TYPE(win, <span class="string">"win"</span>,</span><br><span class="line">                  RTGUI_PARENT_TYPE(container),</span><br><span class="line">                  _rtgui_win_constructor,</span><br><span class="line">                  _rtgui_win_destructor,</span><br><span class="line">                  <span class="keyword">sizeof</span>(struct rtgui_win));</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="建立視窗">建立視窗<a class="header-anchor" href="#建立視窗">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立視窗</td><td>視窗指標</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>*rect</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>上層視窗</td><td>視窗標題</td><td>視窗的大小</td><td>一些風格</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_win_t</span> *rtgui_win_create(struct rtgui_win *parent_window,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">char</span> *title,</span><br><span class="line">                              <span class="keyword">rtgui_rect_t</span> *rect,</span><br><span class="line">                              <span class="keyword">rt_uint16_t</span> style)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">win</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate win memory */</span></span><br><span class="line">    win = RTGUI_WIN(rtgui_widget_create(RTGUI_WIN_TYPE));</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_win_init(win, parent_window, title, rect, style) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_destroy(RTGUI_WIDGET(win));</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> win;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_create);</span><br></pre></td></tr></tbody></table></figure><p>透過 <code>rtgui_win_init</code> 完成設定</p><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化視窗</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>*rect</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>上層視窗</td><td>視窗標題</td><td>視窗的大小</td><td>一些風格</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rtgui_win_init</span><span class="params">(struct rtgui_win *win, struct rtgui_win *parent_window,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *title,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rtgui_rect_t</span> *rect,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rt_uint16_t</span> style)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent window */</span></span><br><span class="line">    win-&gt;parent_window = parent_window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set title, rect and style */</span></span><br><span class="line">    <span class="keyword">if</span> (title != RT_NULL)</span><br><span class="line">        win-&gt;title = rt_strdup(title);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        win-&gt;title = RT_NULL;</span><br><span class="line"></span><br><span class="line">    rtgui_widget_set_rect(RTGUI_WIDGET(win), rect);</span><br><span class="line">    win-&gt;style = style;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((style &amp; RTGUI_WIN_STYLE_NO_TITLE) &amp;&amp; (style &amp; RTGUI_WIN_STYLE_NO_BORDER)))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">trect</span> = *<span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line">        win-&gt;_title_wgt = rtgui_wintitle_create(win);</span><br><span class="line">        <span class="keyword">if</span> (!win-&gt;_title_wgt)</span><br><span class="line">            <span class="keyword">goto</span> __on_err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(style &amp; RTGUI_WIN_STYLE_NO_BORDER))</span><br><span class="line">        {</span><br><span class="line">            rtgui_rect_inflate(&amp;trect, WINTITLE_BORDER_SIZE);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!(style &amp; RTGUI_WIN_STYLE_NO_TITLE))</span><br><span class="line">        {</span><br><span class="line">            trect.y1 -= WINTITLE_HEIGHT;</span><br><span class="line">        }</span><br><span class="line">        rtgui_widget_set_rect(RTGUI_WIDGET(win-&gt;_title_wgt), &amp;trect);</span><br><span class="line">        <span class="comment">/* Update the clip of the wintitle manually. */</span></span><br><span class="line">        rtgui_region_subtract_rect(&amp;(RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip),</span><br><span class="line">                                   &amp;(RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip),</span><br><span class="line">                                   &amp;(RTGUI_WIDGET(win)-&gt;extent));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The window title is always un-hidden for simplicity. */</span></span><br><span class="line">        rtgui_widget_show(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line">        rtgui_region_init_with_extents(&amp;win-&gt;outer_clip, &amp;trect);</span><br><span class="line">        win-&gt;outer_extent = trect;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        rtgui_region_init_with_extents(&amp;win-&gt;outer_clip, rect);</span><br><span class="line">        win-&gt;outer_extent = *rect;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_rtgui_win_create_in_server(win) == RT_FALSE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> __on_err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    win-&gt;app-&gt;window_cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__on_err:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_init);</span><br></pre></td></tr></tbody></table></figure><h3 id="建立主視窗">建立主視窗<a class="header-anchor" href="#建立主視窗">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立主視窗</td><td>視窗指標</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*parent_window</code></th><th><code>*title</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>上層視窗</td><td>視窗標題</td><td>一些風格</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_win_t</span> *rtgui_mainwin_create(struct rtgui_win *parent_window, <span class="keyword">const</span> <span class="keyword">char</span> *title, <span class="keyword">rt_uint16_t</span> style)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rect</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get rect of main window */</span></span><br><span class="line">    rtgui_get_mainwin_rect(&amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtgui_win_create(parent_window, title, &amp;rect, style);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_mainwin_create);</span><br></pre></td></tr></tbody></table></figure><p>建立一個固定大小的視窗，這個大小被設定在 <code>_mainwin_rect</code> 這個全域變數裡面，可以透過 <code>rtgui_get_mainwin_rect</code> 來取得這個值。</p><hr><h2 id="刪除視窗">刪除視窗<a class="header-anchor" href="#刪除視窗">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>刪除視窗</td><td>void</td><td>目標視窗</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_destroy</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* close the window first if it's not. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_CLOSED))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_close</span> <span class="title">eclose</span>;</span></span><br><span class="line"></span><br><span class="line">        RTGUI_EVENT_WIN_CLOSE_INIT(&amp;eclose);</span><br><span class="line">        eclose.wid = win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;style &amp; RTGUI_WIN_STYLE_DESTROY_ON_CLOSE)</span><br><span class="line">        {</span><br><span class="line">            _rtgui_win_deal_close(win,</span><br><span class="line">                                  (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                  RT_TRUE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _rtgui_win_deal_close(win,</span><br><span class="line">                                  (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                  RT_TRUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set the RTGUI_WIN_STYLE_DESTROY_ON_CLOSE flag so the window will be</span></span><br><span class="line"><span class="comment">         * destroyed after the event_loop */</span></span><br><span class="line">        win-&gt;style |= RTGUI_WIN_STYLE_DESTROY_ON_CLOSE;</span><br><span class="line">        rtgui_win_end_modal(win, RTGUI_MODAL_CANCEL);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_destroy(RTGUI_WIDGET(win));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_destroy);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="關閉視窗">關閉視窗<a class="header-anchor" href="#關閉視窗">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>關閉視窗</td><td>void</td><td>目標視窗</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* send a close event to myself to get a consistent behavior */</span></span><br><span class="line"><span class="keyword">rt_bool_t</span> rtgui_win_close(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_close</span> <span class="title">eclose</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_CLOSE_INIT(&amp;eclose);</span><br><span class="line">    eclose.wid = win;</span><br><span class="line">    <span class="keyword">return</span> _rtgui_win_deal_close(win,</span><br><span class="line">                                 (struct rtgui_event *)&amp;eclose,</span><br><span class="line">                                 RT_FALSE);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_close);</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>_rtgui_win_deal_close</code> 完成關閉動作</p><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>刪除視窗</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>*event</code></th><th><code>force_close</code></th></tr></thead><tbody><tr><td>目標視窗</td><td>關閉事件</td><td>是否要強致關閉</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_bool_t</span> _rtgui_win_deal_close(struct rtgui_win *win,</span><br><span class="line">                                       struct rtgui_event *event,</span><br><span class="line">                                       <span class="keyword">rt_bool_t</span> force_close)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;on_close != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((win-&gt;on_close(RTGUI_OBJECT(win), event) == RT_FALSE) &amp;&amp; !force_close)</span><br><span class="line">            <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_win_hide(win);</span><br><span class="line"></span><br><span class="line">    win-&gt;flag |= RTGUI_WIN_FLAG_CLOSED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* rtgui_win_end_modal cleared the RTGUI_WIN_FLAG_MODAL in win-&gt;flag so</span></span><br><span class="line"><span class="comment">         * we have to record it. */</span></span><br><span class="line">        rtgui_win_end_modal(win, RTGUI_MODAL_CANCEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    win-&gt;app-&gt;window_cnt--;</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;app-&gt;window_cnt == <span class="number">0</span> &amp;&amp; !(win-&gt;app-&gt;state_flag &amp; RTGUI_APP_FLAG_KEEP))</span><br><span class="line">    {</span><br><span class="line">        rtgui_app_exit(rtgui_app_self(), <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;style &amp; RTGUI_WIN_STYLE_DESTROY_ON_CLOSE)</span><br><span class="line">    {</span><br><span class="line">        rtgui_win_destroy(win);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="設定視窗">設定視窗<a class="header-anchor" href="#設定視窗">#</a></h2><h3 id="大小">大小<a class="header-anchor" href="#大小">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定視窗大小</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>新大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_rect</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_resize</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL || rect == RT_NULL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET(win)-&gt;extent = *rect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set window resize event to server */</span></span><br><span class="line">        RTGUI_EVENT_WIN_RESIZE_INIT(&amp;event);</span><br><span class="line">        event.wid = win;</span><br><span class="line">        event.rect = *rect;</span><br><span class="line"></span><br><span class="line">        rtgui_server_post_event(&amp;(event.parent), <span class="keyword">sizeof</span>(struct rtgui_event_win_resize));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_rect);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnActive-函式">OnActive 函式<a class="header-anchor" href="#OnActive-函式">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnActive 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnActive 函式</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onactivate</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_activate = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onactivate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnDeactive-函式">OnDeactive 函式<a class="header-anchor" href="#OnDeactive-函式">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnDeactive 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnDeactive 函式</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_ondeactivate</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_deactivate = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_ondeactivate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnClose-函式">OnClose 函式<a class="header-anchor" href="#OnClose-函式">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnClose 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnClose 函式</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onclose</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_close = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onclose);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnKey">OnKey<a class="header-anchor" href="#OnKey">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 OnKey 函式</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>OnKey 函式</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_set_onkey</span><span class="params">(<span class="keyword">rtgui_win_t</span> *win, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (win != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        win-&gt;on_key = handler;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_set_onkey);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="視窗的行為">視窗的行為<a class="header-anchor" href="#視窗的行為">#</a></h2><h3 id="動態模式">動態模式<a class="header-anchor" href="#動態模式">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>進入動態模式</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_enter_modal(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> exit_code = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_modal_enter</span> <span class="title">emodal</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_MODAL_ENTER_INIT(&amp;emodal);</span><br><span class="line">    emodal.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_post_event_sync((struct rtgui_event *)&amp;emodal,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(emodal)) != RT_EOK)</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">    win-&gt;flag |= RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">    win-&gt;app_ref_count = win-&gt;app-&gt;ref_count + <span class="number">1</span>;</span><br><span class="line">    exit_code = rtgui_app_run(win-&gt;app);</span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_MODAL;</span><br><span class="line"></span><br><span class="line">    rtgui_win_hide(win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_enter_modal);</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>離開動態模式</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>modal_code</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>動態模式編號</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_end_modal</span><span class="params">(struct rtgui_win *win, <span class="keyword">rtgui_modal_code_t</span> modal_code)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL || !(win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (win-&gt;app_ref_count &lt; win-&gt;app-&gt;ref_count)</span><br><span class="line">    {</span><br><span class="line">        rtgui_app_exit(win-&gt;app, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1000</span>)</span><br><span class="line">        {</span><br><span class="line">            rt_kprintf(<span class="string">" =*=&gt; rtgui_win_end_modal while (win-&gt;app_ref_count &lt; win-&gt;app-&gt;ref_count) \n"</span>);</span><br><span class="line">            RT_ASSERT(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_app_exit(win-&gt;app, modal_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove modal mode */</span></span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_end_modal);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="現身">現身<a class="header-anchor" href="#現身">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>現身該視窗</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>is_modal</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>是否為動態模式</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_show(struct rtgui_win *win, <span class="keyword">rt_bool_t</span> is_modal)</span><br><span class="line">{</span><br><span class="line">    RTGUI_WIDGET_UNHIDE(win);</span><br><span class="line"></span><br><span class="line">    win-&gt;magic = RTGUI_WIN_MAGIC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_modal)</span><br><span class="line">        win-&gt;flag |= RTGUI_WIN_FLAG_MODAL;</span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_do_show)</span><br><span class="line">        <span class="keyword">return</span> win-&gt;_do_show(win);</span><br><span class="line">    <span class="keyword">return</span> rtgui_win_do_show(win);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_show);</span><br></pre></td></tr></tbody></table></figure><p>如果視窗本身有設定 <code>_do_show</code> 函式的話，則呼叫本身的；否則呼叫 <code>rtgui_win_do_show</code></p><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>視窗現身</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_base_t</span> rtgui_win_do_show(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> exit_code = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_app</span> *<span class="title">app</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_show</span> <span class="title">eshow</span>;</span></span><br><span class="line"></span><br><span class="line">    RTGUI_EVENT_WIN_SHOW_INIT(&amp;eshow);</span><br><span class="line">    eshow.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_CLOSED;</span><br><span class="line">    win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_CB_PRESSED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it does not register into server, create it in server */</span></span><br><span class="line">    <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (_rtgui_win_create_in_server(win) == RT_FALSE)</span><br><span class="line">            <span class="keyword">return</span> exit_code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set window unhidden before notify the server */</span></span><br><span class="line">    rtgui_widget_show(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;eshow),</span><br><span class="line">                                     <span class="keyword">sizeof</span>(struct rtgui_event_win_show)) != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* It could not be shown if a parent window is hidden. */</span></span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line">        <span class="keyword">return</span> exit_code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;focused_widget == RT_NULL)</span><br><span class="line">        rtgui_widget_focus(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">    app = win-&gt;app;</span><br><span class="line">    RT_ASSERT(app != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set main window */</span></span><br><span class="line">    <span class="keyword">if</span> (app-&gt;main_object == RT_NULL)</span><br><span class="line">        rtgui_app_set_main_win(app, win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_MODAL)</span><br><span class="line">    {</span><br><span class="line">        exit_code = rtgui_win_enter_modal(win);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_do_show);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="隱藏">隱藏<a class="header-anchor" href="#隱藏">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>隱藏視窗</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_hide</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(win != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_HIDE(win) &amp;&amp;</span><br><span class="line">            win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* send hidden message to server */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_hide</span> <span class="title">ehide</span>;</span></span><br><span class="line">        RTGUI_EVENT_WIN_HIDE_INIT(&amp;ehide);</span><br><span class="line">        ehide.wid = win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;ehide),</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct rtgui_event_win_hide)) != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            rt_kprintf(<span class="string">"hide win: %s failed\n"</span>, win-&gt;title);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line">        win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_hide);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="啟動">啟動<a class="header-anchor" href="#啟動">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>啟動視窗</td><td>檢查碼</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rtgui_win_activate(struct rtgui_win *win)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_activate</span> <span class="title">eact</span>;</span></span><br><span class="line">    RTGUI_EVENT_WIN_ACTIVATE_INIT(&amp;eact);</span><br><span class="line">    eact.wid = win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtgui_server_post_event_sync(RTGUI_EVENT(&amp;eact),</span><br><span class="line">                                        <span class="keyword">sizeof</span>(eact));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_activate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="移動">移動<a class="header-anchor" href="#移動">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>進入動態模式</td><td>檢查碼</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*win</code></th><th><code>x</code></th><th><code>y</code></th></tr></thead><tbody><tr><td>視窗本體</td><td>目標 x</td><td>目標 y</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_move</span><span class="params">(struct rtgui_win *win, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">wgt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_move</span> <span class="title">emove</span>;</span></span><br><span class="line">    <span class="keyword">int</span> dx, dy;</span><br><span class="line">    RTGUI_EVENT_WIN_MOVE_INIT(&amp;emove);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">    {</span><br><span class="line">        wgt = RTGUI_WIDGET(win-&gt;_title_wgt);</span><br><span class="line">        dx = x - wgt-&gt;extent.x1;</span><br><span class="line">        dy = y - wgt-&gt;extent.y1;</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line"></span><br><span class="line">        wgt = RTGUI_WIDGET(win);</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        wgt = RTGUI_WIDGET(win);</span><br><span class="line">        dx = x - wgt-&gt;extent.x1;</span><br><span class="line">        dy = y - wgt-&gt;extent.y1;</span><br><span class="line">        rtgui_widget_move_to_logic(wgt, dx, dy);</span><br><span class="line">    }</span><br><span class="line">    rtgui_rect_move(&amp;win-&gt;outer_extent, dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CONNECTED)</span><br><span class="line">    {</span><br><span class="line">        rtgui_widget_hide(RTGUI_WIDGET(win));</span><br><span class="line"></span><br><span class="line">        emove.wid   = win;</span><br><span class="line">        emove.x     = x;</span><br><span class="line">        emove.y     = y;</span><br><span class="line">        <span class="keyword">if</span> (rtgui_server_post_event_sync(RTGUI_EVENT(&amp;emove),</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct rtgui_event_win_move)) != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rtgui_widget_show(RTGUI_WIDGET(win));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_move);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="OnDraw">OnDraw<a class="header-anchor" href="#OnDraw">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>OnDraw</td><td>boolean</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> rt_bool_t <span class="title">rtgui_win_ondraw</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> *<span class="title">dc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rect</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_paint</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* begin drawing */</span></span><br><span class="line">    dc = rtgui_dc_begin_drawing(RTGUI_WIDGET(win));</span><br><span class="line">    <span class="keyword">if</span> (dc == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get window rect */</span></span><br><span class="line">    rtgui_widget_get_rect(RTGUI_WIDGET(win), &amp;rect);</span><br><span class="line">    <span class="comment">/* fill area */</span></span><br><span class="line">    rtgui_dc_fill_rect(dc, &amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget drawing */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* paint each widget */</span></span><br><span class="line">    RTGUI_EVENT_PAINT_INIT(&amp;event);</span><br><span class="line">    event.wid = RT_NULL;</span><br><span class="line"></span><br><span class="line">    rtgui_container_dispatch_event(RTGUI_CONTAINER(win),</span><br><span class="line">                                   (<span class="keyword">rtgui_event_t</span> *)&amp;event);</span><br><span class="line"></span><br><span class="line">    rtgui_dc_end_drawing(dc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="更新重疊區域">更新重疊區域<a class="header-anchor" href="#更新重疊區域">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*win</code></th></tr></thead><tbody><tr><td>更新重疊區域</td><td>void</td><td>視窗本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_win_update_clip</span><span class="params">(struct rtgui_win *win)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_container</span> *<span class="title">cnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_CLOSED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Reset the inner clip of title. */</span></span><br><span class="line">        RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;extent = win-&gt;outer_extent;</span><br><span class="line">        rtgui_region_copy(&amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip, &amp;win-&gt;outer_clip);</span><br><span class="line">        rtgui_region_subtract_rect(&amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip,</span><br><span class="line">                                   &amp;RTGUI_WIDGET(win-&gt;_title_wgt)-&gt;clip,</span><br><span class="line">                                   &amp;RTGUI_WIDGET(win)-&gt;extent);</span><br><span class="line">        <span class="comment">/* Reset the inner clip of window. */</span></span><br><span class="line">        rtgui_region_intersect_rect(&amp;RTGUI_WIDGET(win)-&gt;clip,</span><br><span class="line">                                    &amp;win-&gt;outer_clip,</span><br><span class="line">                                    &amp;RTGUI_WIDGET(win)-&gt;extent);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        RTGUI_WIDGET(win)-&gt;extent = win-&gt;outer_extent;</span><br><span class="line">        rtgui_region_copy(&amp;RTGUI_WIDGET(win)-&gt;clip, &amp;win-&gt;outer_clip);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the clip info of each child */</span></span><br><span class="line">    cnt = RTGUI_CONTAINER(win);</span><br><span class="line">    rtgui_list_foreach(node, &amp;(cnt-&gt;children))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_widget_t</span> *child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">        rtgui_widget_update_clip(child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_update_clip);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Event-Handler">Event Handler<a class="header-anchor" href="#Event-Handler">#</a></h2><p>此 event handler 也就是 window 的函式進入點</p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>window 函式進入點</td><td>boolean</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*object</code></th><th><code>*event</code></th></tr></thead><tbody><tr><td>物件本體</td><td>行為本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_bool_t</span> rtgui_win_event_handler(struct rtgui_object *object, struct rtgui_event *event)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">win</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(object != RT_NULL);</span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line"></span><br><span class="line">    win = RTGUI_WIN(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;type)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_SHOW:</span><br><span class="line">        rtgui_win_do_show(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_HIDE:</span><br><span class="line">        rtgui_win_hide(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_CLOSE:</span><br><span class="line">        _rtgui_win_deal_close(win, event, RT_FALSE);</span><br><span class="line">        <span class="comment">/* don't broadcast WIN_CLOSE event to others */</span></span><br><span class="line">        <span class="keyword">return</span> RT_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_MOVE:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_win_move</span> *<span class="title">emove</span> = (<span class="title">struct</span> <span class="title">rtgui_event_win_move</span> *)<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* move window */</span></span><br><span class="line">        rtgui_win_move(win, emove-&gt;x, emove-&gt;y);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_ACTIVATE:</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;flag &amp; RTGUI_WIN_FLAG_UNDER_MODAL ||</span><br><span class="line">                RTGUI_WIDGET_IS_HIDE(win))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* activate a hide window */</span></span><br><span class="line">            <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        win-&gt;flag |= RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">        <span class="comment">/* There are many cases where the paint event will follow this activate</span></span><br><span class="line"><span class="comment">         * event and just repaint the title is not a big deal. So just repaint</span></span><br><span class="line"><span class="comment">         * the title if there is one. If you want to update the content of the</span></span><br><span class="line"><span class="comment">         * window, do it in the on_activate callback.*/</span></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;on_activate != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            win-&gt;on_activate(RTGUI_OBJECT(object), event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_DEACTIVATE:</span><br><span class="line">        win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_ACTIVATE;</span><br><span class="line">        <span class="comment">/* No paint event follow the deactive event. So we have to update</span></span><br><span class="line"><span class="comment">         * the title manually to reflect the change. */</span></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;on_deactivate != RT_NULL)</span><br><span class="line">            win-&gt;on_deactivate(RTGUI_OBJECT(object), event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_WIN_UPDATE_END:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_CLIP_INFO:</span><br><span class="line">        <span class="comment">/* update win clip */</span></span><br><span class="line">        rtgui_win_update_clip(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_PAINT:</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">            rtgui_widget_update(RTGUI_WIDGET(win-&gt;_title_wgt));</span><br><span class="line">        rtgui_win_ondraw(win);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GUIENGIN_USING_VFRAMEBUFFER</span></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_VPAINT_REQ:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_vpaint_req</span> *<span class="title">req</span> = (<span class="title">struct</span> <span class="title">rtgui_event_vpaint_req</span> *)<span class="title">event</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc</span> *<span class="title">dc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get drawing dc */</span></span><br><span class="line">        dc = rtgui_win_get_drawing(win);</span><br><span class="line"></span><br><span class="line">        req-&gt;sender-&gt;buffer = dc;</span><br><span class="line">        rt_completion_done(req-&gt;sender-&gt;cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_MOUSE_BUTTON:</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_mouse</span> *<span class="title">emouse</span> = (<span class="title">struct</span> <span class="title">rtgui_event_mouse</span>*)<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rtgui_rect_contains_point(&amp;RTGUI_WIDGET(win)-&gt;extent,</span><br><span class="line">                                      emouse-&gt;x, emouse-&gt;y) == RT_EOK)</span><br><span class="line">            <span class="keyword">return</span> _win_handle_mouse_btn(win, event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (win-&gt;_title_wgt)</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span> *<span class="title">tobj</span> = <span class="title">RTGUI_OBJECT</span>(<span class="title">win</span>-&gt;_<span class="title">title_wgt</span>);</span></span><br><span class="line">            <span class="keyword">return</span> tobj-&gt;event_handler(tobj, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_MOUSE_MOTION:</span><br><span class="line">        <span class="keyword">return</span> rtgui_container_dispatch_mouse_event(RTGUI_CONTAINER(win),</span><br><span class="line">                (struct rtgui_event_mouse *)event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_KBD:</span><br><span class="line">        <span class="comment">/* we should dispatch key event firstly */</span></span><br><span class="line">        <span class="keyword">if</span> (!(win-&gt;flag &amp; RTGUI_WIN_FLAG_HANDLE_KEY))</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">widget</span>;</span></span><br><span class="line">            <span class="keyword">rt_bool_t</span> res = RT_FALSE;</span><br><span class="line">            <span class="comment">/* we should dispatch the key event just once. Once entered the</span></span><br><span class="line"><span class="comment">             * dispatch mode, we should swtich to key handling mode. */</span></span><br><span class="line">            win-&gt;flag |= RTGUI_WIN_FLAG_HANDLE_KEY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* dispatch the key event */</span></span><br><span class="line">            <span class="keyword">for</span> (widget = win-&gt;focused_widget;</span><br><span class="line">                    widget &amp;&amp; !res;</span><br><span class="line">                    widget = widget-&gt;parent)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">                    res = RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                              RTGUI_OBJECT(widget), event);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            win-&gt;flag &amp;= ~RTGUI_WIN_FLAG_HANDLE_KEY;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* in key handling mode(it may reach here in</span></span><br><span class="line"><span class="comment">             * win-&gt;focused_widget-&gt;event_handler call) */</span></span><br><span class="line">            <span class="keyword">if</span> (win-&gt;on_key != RT_NULL)</span><br><span class="line">                <span class="keyword">return</span> win-&gt;on_key(RTGUI_OBJECT(win), event);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTGUI_EVENT_COMMAND:</span><br><span class="line">        <span class="keyword">if</span> (rtgui_container_dispatch_event(RTGUI_CONTAINER(object), event) != RT_TRUE)</span><br><span class="line">        {</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> RT_TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> rtgui_container_event_handler(object, event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_FALSE;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_win_event_handler);</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> GUI </tag>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread GUI - Widget</title>
      <link href="/posts/RT-Thread/gui-widget.html"/>
      <url>/posts/RT-Thread/gui-widget.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇我們說明了 RTGUI 是如何透過 C 實現物件導向的設計邏輯，這篇將會說明在 RTGUI 中的最小物件 “widget” 是如何創建、運行及刪除的。</p><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> widget.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the base widget object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* inherit from rtgui_object */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span> <span class="title">object</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget that contains this widget */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* the window that contains this widget */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_win</span> *<span class="title">toplevel</span>;</span></span><br><span class="line">    <span class="comment">/* the widget children and sibling */</span></span><br><span class="line">    <span class="keyword">rtgui_list_t</span> sibling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget flag */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hardware device context */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> dc_type;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_dc_engine</span> *<span class="title">dc_engine</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the graphic context of widget */</span></span><br><span class="line">    <span class="keyword">rtgui_gc_t</span> gc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the widget extent */</span></span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> extent;</span><br><span class="line">    <span class="comment">/* the visiable extent (includes the rectangles of children) */</span></span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> extent_visiable;</span><br><span class="line">    <span class="comment">/* the rect clip information */</span></span><br><span class="line">    <span class="keyword">rtgui_region_t</span> clip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* minimal width and height of widget */</span></span><br><span class="line">    <span class="keyword">rt_int16_t</span> min_width, min_height;</span><br><span class="line">    <span class="comment">/* widget align */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span> align;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> border;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> border_style;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call back */</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_focus_in)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line">    <span class="keyword">rt_bool_t</span> (*on_focus_out)(struct rtgui_object *widget, struct rtgui_event *event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* user private data */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> user_data;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> <span class="title">rtgui_widget_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>記錄包含他的 widget、所在的 window、一些屬性等</p><h3 id="四方形結構體">四方形結構體<a class="header-anchor" href="#四方形結構體">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> rtgui.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rectangle structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_int16_t</span> x1, y1, x2, y2;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_rect</span> <span class="title">rtgui_rect_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>對角線 (x1,y1)、(x2,y2)</p><hr><h3 id="定義物件類型">定義物件類型<a class="header-anchor" href="#定義物件類型">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> widget.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CLASS_TYPE(widget, <span class="string">"widget"</span>,</span><br><span class="line">                  RTGUI_PARENT_TYPE(object),</span><br><span class="line">                  _rtgui_widget_constructor,</span><br><span class="line">                  _rtgui_widget_destructor,</span><br><span class="line">                  <span class="keyword">sizeof</span>(struct rtgui_widget));</span><br><span class="line">RTM_EXPORT(_rtgui_widget);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="建立-widget">建立 widget<a class="header-anchor" href="#建立-widget">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget_type</code></th></tr></thead><tbody><tr><td>建立 widget</td><td>widget 指標</td><td>欲建立的 widget 種類</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_create(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *widget_type)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">widget</span>;</span></span><br><span class="line"></span><br><span class="line">    widget = RTGUI_WIDGET(rtgui_object_create(widget_type));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> widget;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_create);</span><br></pre></td></tr></tbody></table></figure><p>呼叫 <code>rtgui_object_create</code>，型態為 widget 完成，並透過 <code>RTGUI_WIDGET</code> 檢查正確性</p><hr><h2 id="刪除-widget">刪除 widget<a class="header-anchor" href="#刪除-widget">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>刪除 widget</td><td>void</td><td>欲刪除的 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_destroy</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rtgui_object_destroy(RTGUI_OBJECT(widget));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_destroy);</span><br></pre></td></tr></tbody></table></figure><p>一樣透過 <code>rtgui_object_destroy</code> 來完成</p><hr><h2 id="設定-widget">設定 widget<a class="header-anchor" href="#設定-widget">#</a></h2><p>RTT GUI 提供一些 API 給使用者去設定 widget 的樣式與行為</p><h3 id="大小">大小<a class="header-anchor" href="#大小">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的大小</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>x</code></th><th><code>y</code></th><th><code>width</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>起始座標 x</td><td>y</td><td>寬度</td><td>高度</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_rectangle</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line"></span><br><span class="line">    rect.x1 = x;</span><br><span class="line">    rect.y1 = y;</span><br><span class="line">    rect.x2 = x + width;</span><br><span class="line">    rect.y2 = y + height;</span><br><span class="line"></span><br><span class="line">    rtgui_widget_set_rect(widget, &amp;rect);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_rectangle);</span><br></pre></td></tr></tbody></table></figure><p>填入正確的 (x1,y1)、(x2,y2)</p><hr><h3 id="Parent">Parent<a class="header-anchor" href="#Parent">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的上層元素</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>parent</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>上層元素 (widget)</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_parent</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_widget_t</span> *parent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* set parent and toplevel widget */</span></span><br><span class="line">    widget-&gt;parent = parent;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_parent);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="大小下界">大小下界<a class="header-anchor" href="#大小下界">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的大小下界</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>width</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>寬度</td><td>高度</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minsize</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line">    widget-&gt;min_width = width;</span><br><span class="line">    widget-&gt;min_height = height;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minsize);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="寬度下界">寬度下界<a class="header-anchor" href="#寬度下界">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的寬度下界</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>width</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>寬度</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minwidth</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;min_width = width;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minwidth);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="高度下界">高度下界<a class="header-anchor" href="#高度下界">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的高度下界</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>height</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>高度</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_minheight</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;min_height = height;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_minheight);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="邊框風格">邊框風格<a class="header-anchor" href="#邊框風格">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的邊框風格</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>風格</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set widget draw style</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_border</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rt_uint32_t</span> style)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;border_style = style;</span><br><span class="line">    <span class="keyword">switch</span> (style)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_NONE:</span><br><span class="line">        widget-&gt;border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_SIMPLE:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_UP:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_DOWN:</span><br><span class="line">        widget-&gt;border = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_STATIC:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_RAISE:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_SUNKEN:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_BOX:</span><br><span class="line">    <span class="keyword">case</span> RTGUI_BORDER_EXTRA:</span><br><span class="line">        widget-&gt;border = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        widget-&gt;border = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_border);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Focus-函式">Focus 函式<a class="header-anchor" href="#Focus-函式">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的 focus func</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>focus func</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_onfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;on_focus_in = handler;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_onfocus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Unfocus-函式">Unfocus 函式<a class="header-anchor" href="#Unfocus-函式">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 widget 的 unfocus func</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>handler</code></th></tr></thead><tbody><tr><td>欲設定的 widget</td><td>focus func</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_set_onunfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, rtgui_event_handler_ptr handler)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    widget-&gt;on_focus_out = handler;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_set_onunfocus);</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>這裡是用<strong>指標函數</strong>的方式將行為函式填入結構中，要使用時可直接呼叫結構中的元素使用。</p></div><hr><h2 id="Widget-的行為">Widget 的行為<a class="header-anchor" href="#Widget-的行為">#</a></h2><p>上一節整理了設定 widget 的風格，接下來整理 widget 的行為</p><h3 id="移動到相對位置">移動到相對位置<a class="header-anchor" href="#移動到相對位置">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>移動 widget 到相對位置</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center"><code>*widget</code></th><th style="text-align:center"><code>dx</code></th><th style="text-align:center"><code>dy</code></th></tr></thead><tbody><tr><td style="text-align:center">欲移動的 widget</td><td style="text-align:center">位移量 x</td><td style="text-align:center">y</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function moves widget and its children to a logic point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_move_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* give clip of this widget back to parent */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get the parent rect, even if it's a transparent parent. */</span></span><br><span class="line">        rect = parent-&gt;extent_visiable;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we should find out the none-transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) parent = parent-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset clip info */</span></span><br><span class="line">        rtgui_region_init_with_extents(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line">        rtgui_region_intersect_rect(&amp;(widget-&gt;clip), &amp;(widget-&gt;clip), &amp;rect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* give back the extent */</span></span><br><span class="line">        rtgui_region_union(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;clip));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move this widget (and its children if it's a container) to destination point */</span></span><br><span class="line">    _widget_move(widget, dx, dy);</span><br><span class="line">    <span class="comment">/* update this widget */</span></span><br><span class="line">    rtgui_widget_update_clip(widget);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_move_to_logic);</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="移動-widget">移動 widget<a class="header-anchor" href="#移動-widget">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>移動 widget</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>dx</code></th><th><code>dy</code></th></tr></thead><tbody><tr><td>欲移動的 widget</td><td>位移量 x</td><td>y</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _widget_move(struct rtgui_widget* widget, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *child, *parent;</span><br><span class="line"></span><br><span class="line">rtgui_rect_move(&amp;(widget-&gt;extent), dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle visiable extent */</span></span><br><span class="line">    widget-&gt;extent_visiable = widget-&gt;extent;</span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="comment">/* we should find out the none-transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) parent = parent-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;parent)</span><br><span class="line">        rtgui_rect_intersect(&amp;(widget-&gt;parent-&gt;extent_visiable), &amp;(widget-&gt;extent_visiable));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset clip info */</span></span><br><span class="line">    rtgui_region_init_with_extents(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move each child */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">            _widget_move(child, dx, dy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Focus-widget">Focus widget<a class="header-anchor" href="#Focus-widget">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>focus widget</td><td>void</td><td>欲 focus 的 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Focuses the widget. The focused widget is the widget which can receive the keyboard events</span></span><br><span class="line"><span class="comment"> * @param widget a widget</span></span><br><span class="line"><span class="comment"> * @note The widget has to be attached to a toplevel widget, otherwise it will have no effect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_focus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_widget</span> *<span class="title">old_focus</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line">    RT_ASSERT(widget-&gt;toplevel != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_FOCUSABLE(widget) || !RTGUI_WIDGET_IS_ENABLE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    old_focus = RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget;</span><br><span class="line">    <span class="keyword">if</span> (old_focus == widget)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* it's the same focused widget */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unfocused the old widget */</span></span><br><span class="line">    <span class="keyword">if</span> (old_focus != RT_NULL)</span><br><span class="line">        rtgui_widget_unfocus(old_focus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set widget as focused */</span></span><br><span class="line">    widget-&gt;flag |= RTGUI_WIDGET_FLAG_FOCUS;</span><br><span class="line">    RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget = widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* invoke on focus in call back */</span></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;on_focus_in != RT_NULL)</span><br><span class="line">        widget-&gt;on_focus_in(RTGUI_OBJECT(widget), RT_NULL);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_focus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Unfocus-widget">Unfocus widget<a class="header-anchor" href="#Unfocus-widget">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>focus widget</td><td>void</td><td>欲 unfocus 的 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Unfocused the widget</span></span><br><span class="line"><span class="comment"> * @param widget a widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_unfocus</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!widget-&gt;toplevel || !RTGUI_WIDGET_IS_FOCUSED(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    widget-&gt;flag &amp;= ~RTGUI_WIDGET_FLAG_FOCUS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;on_focus_out != RT_NULL)</span><br><span class="line">        widget-&gt;on_focus_out(RTGUI_OBJECT(widget), RT_NULL);</span><br><span class="line"></span><br><span class="line">    RTGUI_WIN(widget-&gt;toplevel)-&gt;focused_widget = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ergodic constituent widget, make child loss of focus */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_list_t</span> *node;</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">rtgui_widget_t</span> *child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line">            <span class="keyword">if</span> (RTGUI_WIDGET_IS_HIDE(child)) <span class="keyword">continue</span>;</span><br><span class="line">            rtgui_widget_unfocus(child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_unfocus);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="位移-widget">位移 widget<a class="header-anchor" href="#位移-widget">#</a></h3><h4 id="點向上位移">點向上位移<a class="header-anchor" href="#點向上位移">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>*point</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標點</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_point_to_device</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_point_t</span> *point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (point != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        point-&gt;x += widget-&gt;extent.x1;</span><br><span class="line">        point-&gt;y += widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_point_to_device);</span><br></pre></td></tr></tbody></table></figure><h4 id="點向下位移">點向下位移<a class="header-anchor" href="#點向下位移">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>*point</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標點</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_point_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_point_t</span> *point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (point != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        point-&gt;x -= widget-&gt;extent.x1;</span><br><span class="line">        point-&gt;y -= widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_point_to_logic);</span><br></pre></td></tr></tbody></table></figure><h4 id="矩形向上位移">矩形向上位移<a class="header-anchor" href="#矩形向上位移">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標矩形</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_rect_to_device</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rect != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rect-&gt;x1 += widget-&gt;extent.x1;</span><br><span class="line">        rect-&gt;x2 += widget-&gt;extent.x1;</span><br><span class="line"></span><br><span class="line">        rect-&gt;y1 += widget-&gt;extent.y1;</span><br><span class="line">        rect-&gt;y2 += widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_rect_to_device);</span><br></pre></td></tr></tbody></table></figure><h4 id="矩形向下位移">矩形向下位移<a class="header-anchor" href="#矩形向下位移">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>點向上位移</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*widget</code></th><th><code>*rect</code></th></tr></thead><tbody><tr><td>目標 widget</td><td>目標矩形</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_rect_to_logic</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget, <span class="keyword">rtgui_rect_t</span> *rect)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rect != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rect-&gt;x1 -= widget-&gt;extent.x1;</span><br><span class="line">        rect-&gt;x2 -= widget-&gt;extent.x1;</span><br><span class="line"></span><br><span class="line">        rect-&gt;y1 -= widget-&gt;extent.y1;</span><br><span class="line">        rect-&gt;y2 -= widget-&gt;extent.y1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_rect_to_logic);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="更新重疊區域">更新重疊區域<a class="header-anchor" href="#更新重疊區域">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>更新重疊區域</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function updates the clip info of widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_update_clip</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_rect_t</span> rect;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no widget or widget is hide, no update clip */</span></span><br><span class="line">    <span class="keyword">if</span> (widget == RT_NULL || RTGUI_WIDGET_IS_HIDE(widget) || widget-&gt;parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="comment">/* reset visiable extent */</span></span><br><span class="line">    widget-&gt;extent_visiable = widget-&gt;extent;</span><br><span class="line">    rtgui_rect_intersect(&amp;(parent-&gt;extent_visiable), &amp;(widget-&gt;extent_visiable));</span><br><span class="line"></span><br><span class="line">    rect = parent-&gt;extent_visiable;</span><br><span class="line">    <span class="comment">/* reset clip to extent */</span></span><br><span class="line">    rtgui_region_reset(&amp;(widget-&gt;clip), &amp;(widget-&gt;extent));</span><br><span class="line">    <span class="comment">/* limit widget extent in parent extent */</span></span><br><span class="line">    rtgui_region_intersect_rect(&amp;(widget-&gt;clip), &amp;(widget-&gt;clip), &amp;rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the no transparent parent */</span></span><br><span class="line">    <span class="keyword">while</span> (parent != RT_NULL &amp;&amp; parent-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT)</span><br><span class="line">    {</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* give my clip back to parent */</span></span><br><span class="line">        rtgui_region_union(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;clip));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* subtract widget clip in parent clip */</span></span><br><span class="line">        <span class="keyword">if</span> (!(widget-&gt;flag &amp; RTGUI_WIDGET_FLAG_TRANSPARENT) &amp;&amp; RTGUI_IS_CONTAINER(parent))</span><br><span class="line">        {</span><br><span class="line">            rtgui_region_subtract_rect(&amp;(parent-&gt;clip), &amp;(parent-&gt;clip), &amp;(widget-&gt;extent_visiable));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * note: since the layout widget introduction, the sibling widget should not intersect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's a container object, update the clip info of children */</span></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_IS_CONTAINER(widget))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rtgui_widget_t</span> *child;</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(widget)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            child = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">            rtgui_widget_update_clip(child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_update_clip);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="顯示-widget">顯示 widget<a class="header-anchor" href="#顯示-widget">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>顯示 widget</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_show</span><span class="params">(struct rtgui_widget *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_show</span> <span class="title">eshow</span>;</span></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTGUI_WIDGET_IS_HIDE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET_UNHIDE(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        RTGUI_EVENT_SHOW_INIT(&amp;eshow);</span><br><span class="line">        <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                RTGUI_OBJECT(widget),</span><br><span class="line">                &amp;eshow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_show);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="隱藏-widget">隱藏 widget<a class="header-anchor" href="#隱藏-widget">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>隱藏 widget</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_widget_hide</span><span class="params">(struct rtgui_widget *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_event_hide</span> <span class="title">ehide</span>;</span></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RTGUI_WIDGET_IS_HIDE(widget))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        RTGUI_EVENT_HIDE_INIT(&amp;ehide);</span><br><span class="line">        <span class="keyword">if</span> (RTGUI_OBJECT(widget)-&gt;event_handler != RT_NULL)</span><br><span class="line">        {</span><br><span class="line">            RTGUI_OBJECT(widget)-&gt;event_handler(</span><br><span class="line">                RTGUI_OBJECT(widget),</span><br><span class="line">                &amp;ehide);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RTGUI_WIDGET_HIDE(widget);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_hide);</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="取得-widget-資訊">取得 widget 資訊<a class="header-anchor" href="#取得-widget-資訊">#</a></h2><p>最後整理一些取得 widget 資訊的 API</p><h3 id="Top-Level">Top Level<a class="header-anchor" href="#Top-Level">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得 top level</td><td>所在 window</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtgui_win *<span class="title">rtgui_widget_get_toplevel</span><span class="params">(<span class="keyword">rtgui_widget_t</span> *widget)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *r;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(widget != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;toplevel)</span><br><span class="line">        <span class="keyword">return</span> widget-&gt;toplevel;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"widget-&gt;toplevel not properly set\n"</span>);</span><br><span class="line">    r = widget;</span><br><span class="line">    <span class="comment">/* get the toplevel widget */</span></span><br><span class="line">    <span class="keyword">while</span> (r-&gt;parent != RT_NULL)</span><br><span class="line">        r = r-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set toplevel */</span></span><br><span class="line">    widget-&gt;toplevel = RTGUI_WIN(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIN(r);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_toplevel);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上層前景">上層前景<a class="header-anchor" href="#上層前景">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上層前景</td><td>顏色</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_color_t</span> rtgui_widget_get_parent_foreground(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent widget */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RTGUI_WIDGET_FOREGROUND(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;parent != RT_NULL &amp;&amp; (RTGUI_WIDGET_FLAG(parent) &amp; RTGUI_WIDGET_FLAG_TRANSPARENT))</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent's color */</span></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIDGET_FOREGROUND(parent);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_parent_foreground);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上層背景">上層背景<a class="header-anchor" href="#上層背景">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上層背景</td><td>顏色</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_color_t</span> rtgui_widget_get_parent_background(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent widget */</span></span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RTGUI_WIDGET_BACKGROUND(widget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;parent != RT_NULL &amp;&amp; (RTGUI_WIDGET_FLAG(parent) &amp; RTGUI_WIDGET_FLAG_TRANSPARENT))</span><br><span class="line">        parent = parent-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get parent's color */</span></span><br><span class="line">    <span class="keyword">return</span> RTGUI_WIDGET_BACKGROUND(parent);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_parent_background);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="下一個兄弟">下一個兄弟<a class="header-anchor" href="#下一個兄弟">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得下一個兄弟</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_get_next_sibling(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *sibling = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget-&gt;sibling.next != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        sibling = rtgui_list_entry(widget-&gt;sibling.next, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sibling;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_widget_get_next_sibling);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="上一個兄弟">上一個兄弟<a class="header-anchor" href="#上一個兄弟">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*widget</code></th></tr></thead><tbody><tr><td>取得上一個兄弟</td><td>void</td><td>目標 widget</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rtgui_widget_t</span> *rtgui_widget_get_prev_sibling(<span class="keyword">rtgui_widget_t</span> *widget)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">rtgui_widget_t</span> *sibling, *parent;</span><br><span class="line"></span><br><span class="line">    node = RT_NULL;</span><br><span class="line">    sibling = RT_NULL;</span><br><span class="line">    parent = widget-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rtgui_list_foreach(node, &amp;(RTGUI_CONTAINER(parent)-&gt;children))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next == &amp;(widget-&gt;sibling))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != RT_NULL)</span><br><span class="line">        sibling = rtgui_list_entry(node, <span class="keyword">rtgui_widget_t</span>, sibling);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sibling;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> GUI </tag>
            
            <tag> widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread GUI - Object</title>
      <link href="/posts/RT-Thread/gui-object.html"/>
      <url>/posts/RT-Thread/gui-object.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="RT-Thread-GUI-物件架構">RT-Thread GUI 物件架構<a class="header-anchor" href="#RT-Thread-GUI-物件架構">#</a></h2><p>在 RTGUI 中，最小的物件為 widget，再來是 window，window 也是一個 widget；而每個 widget 也是一個 object，這是為了仿造 C++ 的物件導向所設計的，相同的概念我們在 RT-Thread 中已經看過許多次了，在 GUI engine 中也是相同的設計，其中在 object 結構中又串在 type 的結構上，type 中定義了兩個函式：<code>constructor</code> 與 <code>destructor</code>，在 C++ 的 class 中，常使用 <code>init</code> 函式來初始化新建的 class，這裡的 <code>constructor</code> 與 <code>destructor</code> 即用來初始化新建立的物件，及在刪除物件時，釋放該釋放的記憶體。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[RTGUI粗讲（个人见解篇之三、RTGUI WIDGET （2））](https://blog.csdn.net/xuzhenglim/article/details/11883351)">[1]</span></a></sup></p><hr><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> rtgui_object.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rtgui base object */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_object</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* object type */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the event handler */</span></span><br><span class="line">    rtgui_event_handler_ptr event_handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> rtgui_object_flag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> id;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rtgui type structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* type name */</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parent type link */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constructor and destructor */</span></span><br><span class="line">    <span class="keyword">rtgui_constructor_t</span> constructor;</span><br><span class="line">    <span class="keyword">rtgui_destructor_t</span> destructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of type */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="定義物件類型">定義物件類型<a class="header-anchor" href="#定義物件類型">#</a></h2><p>RTGUI 設計了一個巨集函數來定義不同的物件，如下：</p><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_CLASS_TYPE(type, name, parent, constructor, destructor, size) \</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtgui_type</span> _<span class="title">rtgui_</span>##<span class="title">type</span> = {</span> \</span><br><span class="line">name, \</span><br><span class="line">parent, \</span><br><span class="line">RTGUI_CONSTRUCTOR(constructor), \</span><br><span class="line">RTGUI_DESTRUCTOR(destructor), \</span><br><span class="line">size }; \</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *_rtgui_#<span class="meta">#type##_get_type(void) { return &amp;_rtgui_##type; } \</span></span><br><span class="line">RTM_EXPORT(_rtgui_##type##_get_type)</span><br></pre></td></tr></tbody></table></figure><p><code>##</code> 為連字符，在<a href="/rt-thread-RTM-EXPORT">RT-Thread 理解 RTM_EXPORT</a>裡有提過了，基本上就是填入值進去結構體</p><hr><h2 id="建立物件">建立物件<a class="header-anchor" href="#建立物件">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> rtgui_object.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object_type</code></th></tr></thead><tbody><tr><td>建立物件</td><td>物件指標</td><td>要建立的物件種類</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Creates a new object: it calls the corresponding constructors</span></span><br><span class="line"><span class="comment"> * (from the constructor of the base class to the constructor of the more</span></span><br><span class="line"><span class="comment"> * derived class) and then sets the values of the given properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object_type the type of object to create</span></span><br><span class="line"><span class="comment"> * @return the created object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rtgui_object_t</span> *rtgui_object_create(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *object_type)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rtgui_object_t</span> *new_object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!object_type)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    new_object = rtgui_malloc(object_type-&gt;size);</span><br><span class="line">    <span class="keyword">if</span> (new_object == RT_NULL) <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_OBJECT_TRACE</span></span><br><span class="line">    obj_info.objs_number ++;</span><br><span class="line">    obj_info.allocated_size += object_type-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (obj_info.allocated_size &gt; obj_info.max_allocated)</span><br><span class="line">        obj_info.max_allocated = obj_info.allocated_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    new_object-&gt;type = object_type;</span><br><span class="line"></span><br><span class="line">    rtgui_type_object_construct(object_type, new_object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_object;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_object_create);</span><br></pre></td></tr></tbody></table></figure><p>建立物件相當簡單，透過欲建立的物件類型所定意義的 <code>construct</code> 函數來建立，其中 <code>rtgui_type_object_construct</code> 會呼叫正確的建立函式來初始化資料。</p><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>呼叫正確的 <code>construct</code> 函式來初始化物件</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*type</code></th><th><code>*object</code></th></tr></thead><tbody><tr><td>欲初始化的物件類型</td><td>物件本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_type_object_construct</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type, <span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* construct from parent to children */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;parent != RT_NULL)</span><br><span class="line">        rtgui_type_object_construct(type-&gt;parent, object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;constructor)</span><br><span class="line">        type-&gt;constructor(object);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果欲建立的物件類型在某一個物件類型的底下，如 window 之於 widget，則先呼叫在上層的 <code>construct</code>；接著呼叫自己的 <code>construct</code> 來完成建立的動作。</p><hr><p>再仔細的看一下 “object” 的 <code>construct</code> 函式，其動作為：填入 vaild 的旗標，並將 id 填入 object 的記憶體指標；以上動作在 <code>_rtgui_object_constructor</code> 完成</p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>“object” 建立函式</td><td>void</td><td>要建立的物件</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtgui_object_constructor(<span class="keyword">rtgui_object_t</span> *object)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!object)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    object-&gt;flag = RTGUI_OBJECT_FLAG_VALID;</span><br><span class="line">    object-&gt;id   = (<span class="keyword">rt_uint32_t</span>)object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="刪除物件">刪除物件<a class="header-anchor" href="#刪除物件">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>刪除物件</td><td>void</td><td>要刪除的物件</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Destroys the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The object destructors will be called in inherited type order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object the object to destroy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_object_destroy</span><span class="params">(<span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!object || object-&gt;flag &amp; RTGUI_OBJECT_FLAG_STATIC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTGUI_OBJECT_TRACE</span></span><br><span class="line">    obj_info.objs_number --;</span><br><span class="line">    obj_info.allocated_size -= object-&gt;type-&gt;size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call destructor */</span></span><br><span class="line">    RT_ASSERT(object-&gt;type != RT_NULL);</span><br><span class="line">    rtgui_type_destructors_call(object-&gt;type, object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release object */</span></span><br><span class="line">    rtgui_free(object);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rtgui_object_destroy);</span><br></pre></td></tr></tbody></table></figure><p>這裡一樣透過 <code>rtgui_type_destructors_call</code> 來呼叫正確的 <code>destruct</code> 函式，<code>destruct</code> 負責釋放該釋放的記憶體；最後透過 <code>rtgui_free</code> 釋放整個物件。<code>regui_free</code> 則簡單的呼叫 <code>rt_free</code> 釋放記憶體，我們在前幾篇文章有討論過了（<a href="/rt-mem#Code-free">mempool</a>、<a href="/rt-memheap#%E9%87%8B%E6%94%BE%E8%A8%98%E6%86%B6%E9%AB%94">memheap</a>、<a href="/rt-small-mem#%E9%87%8B%E6%94%BE%E8%A8%98%E6%86%B6%E9%AB%94">small mem</a>、<a href="/rt-slab#%E9%87%8B%E6%94%BE%E8%A8%98%E6%86%B6%E9%AB%94">slab</a>）</p><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>呼叫正確的 <code>destructor</code> 函式來清除物件</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*type</code></th><th><code>*object</code></th></tr></thead><tbody><tr><td>欲清除的物件類型</td><td>物件本體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtgui_type_destructors_call</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtgui_type_t</span> *type, <span class="keyword">rtgui_object_t</span> *object)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* destruct from children to parent */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;destructor)</span><br><span class="line">        type-&gt;destructor(object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;parent)</span><br><span class="line">        rtgui_type_destructors_call(type-&gt;parent, object);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同樣的如果此物件類型是在某個物件類型的底下，先呼叫上層的 <code>destruct</code>；接著呼叫自己的 <code>desturct</code> 完成清除的動作。</p><hr><p>最後來看一下 “object” 的刪除函式：填入 none 的旗標，並將物件種類設為 NULL；動作在 <code>_rtgui_object_destructor</code> 完成</p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*object</code></th></tr></thead><tbody><tr><td>“object” 的刪除函式</td><td>void</td><td>欲清除的物件</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destroys the object */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rtgui_object_destructor(<span class="keyword">rtgui_object_t</span> *object)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Any valid objest should both have valid flag _and_ valid type. Only use</span></span><br><span class="line"><span class="comment">     * flag is not enough because the chunk of memory may be reallocted to other</span></span><br><span class="line"><span class="comment">     * object and thus the flag will become valid. */</span></span><br><span class="line">    object-&gt;flag = RTGUI_OBJECT_FLAG_NONE;</span><br><span class="line">    object-&gt;type = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/xuzhenglim/article/details/11883351" target="_blank" rel="noopener">RTGUI粗讲（个人见解篇之三、RTGUI WIDGET （2））</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread GUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 crontab 自動備份網站原始碼</title>
      <link href="/posts/hexo/auto-backup-with-crontab.html"/>
      <url>/posts/hexo/auto-backup-with-crontab.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="shell-script">shell script<a class="header-anchor" href="#shell-script">#</a></h2><p>透過 git 備份時，一定是使用下列指令</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'log'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></tbody></table></figure><p>而使用 shell script 可以讓我們一次執行一大串指令，因此我們來寫一個 shell script</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/zsh</span></span><br><span class="line">nowTime="$(date +'%Y-%m-%d %H:%M:%S')"</span><br><span class="line">echo "# Using crontab with auto.sh"</span><br><span class="line">echo "# File in ~/Desktop/auto.sh"</span><br><span class="line">echo "# Log  in ~/Desktop/cront.log"</span><br><span class="line">echo "#"</span><br><span class="line">echo "# Auto backup at ${nowTime}"</span><br><span class="line">echo "# --------------------------------------------------\n"</span><br><span class="line"></span><br><span class="line">cd /Users/username</span><br><span class="line">cd $1</span><br><span class="line">echo "Now at $(pwd)\n"</span><br><span class="line"></span><br><span class="line">log="auto backup at "${nowTime}</span><br><span class="line">git add .</span><br><span class="line">git commit -m "$log"</span><br><span class="line">result=$(git push site hexo_source_new 2&gt;&amp;1)</span><br><span class="line"></span><br><span class="line">case $result in</span><br><span class="line">    "Everything up-to-date")</span><br><span class="line">        osascript -e 'display notification "Everything up-to-date." with title "Automatically backup" sound name "basso"'</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        osascript -e 'display notification "Done!" with title "Automatically backup" sound name "hero"'</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">echo ${result}</span><br><span class="line">echo "Backup complete."</span><br></pre></td></tr></tbody></table></figure><p>其中我們為了方便整理，在提交的紀錄上增加了時間；並且在 push 完根據結果有不同的通知</p><div class="alert alert-danger"><p>此通知是基於 mac 上的 applescript 所寫的，在 linux 上會產生錯誤</p></div><h2 id="建立-crontab">建立 crontab<a class="header-anchor" href="#建立-crontab">#</a></h2><p>寫好 script shell 後，再來就是要定時的執行它。使用 crontab 可以在指定的時間，或是固定的區間內執行。</p><p>使用方式，輸入指令 <code>crontab -e</code>，接著會跳進 vim，寫入</p><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">@hourly chmod +<span class="keyword">x</span> /Users/PATH_TO_YOUR.<span class="keyword">sh</span></span><br><span class="line">@hourly /Users/PATH_TO_YOUR.<span class="keyword">sh</span> PATH_TO_YOUR_SOURCE &gt;&gt; /Users/PATH_TO_YOUR.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>這裡首先提升一次權限，並設定每一次整點都備份一次 <code>@hourly</code>，並將結果寫入 log 中。我們需要先建立一個 .log 檔：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /Users/PATH_TO_YOUR.log</span></span><br></pre></td></tr></tbody></table></figure><p>當然這裡的所有路徑因人而異，檔名也無所謂，最後 <code>:wq</code> 存檔退出，安裝完畢</p><p><div class="img-item" data-src="https://i.imgur.com/w3qGjus.png" data-sub-html=".caption"><img src="https://i.imgur.com/w3qGjus.png" alt="" title="大功告成"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> crontab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自訂網域名稱：Google Domain</title>
      <link href="/posts/hexo/custom-domain.html"/>
      <url>/posts/hexo/custom-domain.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="購買網域">購買網域<a class="header-anchor" href="#購買網域">#</a></h2><p>網路上已經有很多如何在 <a href="https://domains.google.com/m/registrar/omuskywalker.com?hl=en#" target="_blank" rel="noopener">Google Domain</a> 上買網域的文章了，在此就不特別贅述，放上我看的幾篇文章：</p><ul><li><a href="https://free.com.tw/google-domains/" target="_blank" rel="noopener">台灣用戶也能在 Google Domains 註冊購買網域名稱，詳細申請設定教學</a></li><li><a href="https://sofree.cc/google-domains/" target="_blank" rel="noopener">[教學]如何用 Google Domains 買網址、註冊網域？ - 香腸炒魷魚</a></li></ul><div class="alert alert-secondary"><p>比較特別的的地方是，現在只開放部分國家可使用，所以在填地址的時候，可以去 google map 搜尋隨便一個美國的地址，然後使用</p></div><h2 id="設定-DNS">設定 DNS<a class="header-anchor" href="#設定-DNS">#</a></h2><p>根據 Github 官方的說明，需設定 type <code>A</code> 的 IP 位址為</p><ul><li>185.199.108.153</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul><p>以及一個 CNAME，name 可以填任意字串，此字串就是你的 subdomain（像是我填 blog），如果不知道填什麼，可以填 www。最後你的畫面會長這樣：<br><div class="img-item" data-src="https://i.imgur.com/OTJsgaX.png" data-sub-html=".caption"><img src="https://i.imgur.com/OTJsgaX.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div><br>CNAME 的 data 請填 <code>你的 github ID</code>+<code>.github.io.</code>，注意最後有一個點</p><p>這些都設定完，之後你的網址就會變成 <code>subdomain.domain.com</code></p><h2 id="設定-github-CNAME">設定 github CNAME<a class="header-anchor" href="#設定-github-CNAME">#</a></h2><p>Github 官方有提供 301 轉址功能，只要在網頁的 branch 下建立一個 <code>CNAME</code> 檔案，就會把舊網址轉址到新網址。你的 CNAME 應該要填以下內容：</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">subdomain<span class="selector-class">.domain</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>其中 <code>subdomain</code> 與 <code>domain</code> 與自己的有關，像我的就是</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">blog<span class="selector-class">.omuskywalker</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>如果你上面的 subdomain 設定為 www，而你的頂級網域（也就是你買的 domain 名字）沒有要給特別的網站用的話，也可以這樣寫：</p><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">domain.com</span><br><span class="line">subdomain<span class="selector-class">.domain</span><span class="selector-class">.com</span></span><br></pre></td></tr></tbody></table></figure><p>這麼一來不管是上面哪兩種，都會連到你的 blog</p><div class="alert alert-info"><p>如果跟我一樣是用 hexo 的人，CNAME 請放在 /source 底下，這樣每次 <code>hexo d</code> 才不會被蓋掉</p></div><p>如果這些都有設定好，你的 github 應該會長這樣：<br><div class="img-item" data-src="https://i.imgur.com/e5GzzZH.png" data-sub-html=".caption"><img src="https://i.imgur.com/e5GzzZH.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><p>大概過幾個小時，你的新網址就可以用了（大功告成）!</p><h2 id="補充：HTTPS">補充：HTTPS<a class="header-anchor" href="#補充：HTTPS">#</a></h2><p>Github page 有提供內建的 HTTPS，只要你的網站設定好一陣子（不會很久，一天內），會有這個選項可以按：<br><div class="img-item" data-src="https://i.imgur.com/z9HdVbV.png" data-sub-html=".caption"><img src="https://i.imgur.com/z9HdVbV.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div><br>按下去，就會獲得 HTTPS 了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> CNAME </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - SLAB</title>
      <link href="/posts/RT-Thread/slab.html"/>
      <url>/posts/RT-Thread/slab.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SLAB</code></p></blockquote><p>SLAB 將記憶體根據不同的對象切成不同的區 (zone)，對象通常是大小，也可看成是一個 zone 代表一個 pool，不同的 zone 放在一個 array 管理。</p><p>一個 zone 大小介於 32kB~128kB 之間，最多可以有 72 種 zone；zone 對象大小上上限 16kB，超過由頁分配器分配</p><ul><li>alloc：根據需要的大小，找到對應的 zone 取得記憶體；如假設需要 32kB，我們去尋找對象為 32kB 的 zone。<ul><li>若是該 zone 為空（找不到），直接向頁分配器分配一個新的 zone，取得第一塊 free chunk</li><li>若非空，直接取得第一塊，如果拿完該 zone 已經沒有 free chunk 頁分配器須將此 zone 刪除</li></ul></li><li>free：找到對應的 zone 插入至 free list，如果該 zone 的所有 free chunk 都已經釋放完畢，則須將此 zone 整個釋放到分配器裡</li></ul><p><div class="img-item" data-src="https://i.imgur.com/GZdBl7V.png" data-sub-html=".caption"><img src="https://i.imgur.com/GZdBl7V.png" alt="" title="SLAB example"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><hr><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> slab.c</p></div><h3 id="Zone">Zone<a class="header-anchor" href="#Zone">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The IN-BAND zone header is placed at the beginning of each zone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_magic;        <span class="comment">/* magic number for sanity check */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_nfree;        <span class="comment">/* total free chunks / ualloc space in zone */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_nmax;         <span class="comment">/* maximum free chunks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> *<span class="title">z_next</span>;</span>   <span class="comment">/* zoneary[] link if z_nfree non-zero */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  *z_baseptr;     <span class="comment">/* pointer to start of chunk array */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_uindex;       <span class="comment">/* current initial allocation index */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_chunksize;    <span class="comment">/* chunk size for validation */</span></span><br><span class="line">    <span class="keyword">rt_int32_t</span>  z_zoneindex;    <span class="comment">/* zone index */</span></span><br><span class="line">    slab_chunk  *z_freechunk;   <span class="comment">/* free chunk list */</span></span><br><span class="line">} slab_zone;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Chunk structure for free elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_chunk</span> *<span class="title">c_next</span>;</span></span><br><span class="line">} slab_chunk;</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Page-Allocator">Page Allocator<a class="header-anchor" href="#Page-Allocator">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page allocator */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">next</span>;</span>      <span class="comment">/* next valid page */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span> page;                 <span class="comment">/* number of page  */</span></span><br><span class="line">    <span class="comment">/* dummy */</span></span><br><span class="line">    <span class="keyword">char</span> dummy[RT_MM_PAGE_SIZE - (<span class="keyword">sizeof</span>(struct rt_page_head *) + <span class="keyword">sizeof</span>(<span class="keyword">rt_size_t</span>))];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="Descriptor">Descriptor<a class="header-anchor" href="#Descriptor">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array of descriptors that describe the contents of each page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_FREE      0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_SMALL     0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_TYPE_LARGE     0x02</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memusage</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> type: <span class="number">2</span> ;       <span class="comment">/* page type */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> size: <span class="number">30</span>;       <span class="comment">/* pages allocated or offset from zone */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="初始化-heap">初始化 heap<a class="header-anchor" href="#初始化-heap">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 heap</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>記憶體起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will init system heap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system page</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> limsize, npages;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align begin and end addr to page */</span></span><br><span class="line">    heap_start = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_MM_PAGE_SIZE);</span><br><span class="line">    heap_end   = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap_start &gt;= heap_end)</span><br><span class="line">    {</span><br><span class="line">        rt_kprintf(<span class="string">"rt_system_heap_init, wrong address[0x%x - 0x%x]\n"</span>,</span><br><span class="line">                   (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊起始位址，向下對其結束位址</li><li>檢查是否合法</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line">limsize = heap_end - heap_start;</span><br><span class="line">npages  = limsize / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算最大的 size，設定頁數量</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize heap semaphore */</span></span><br><span class="line">rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"heap[0x%x - 0x%x], size 0x%x, 0x%x pages\n"</span>,</span><br><span class="line">                             heap_start, heap_end, limsize, npages));</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 semaphore，值為 1</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init pages */</span></span><br><span class="line">rt_page_init((<span class="keyword">void</span> *)heap_start, npages);</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 page</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* calculate zone size */</span></span><br><span class="line">zone_size = ZALLOC_MIN_ZONE_SIZE;</span><br><span class="line"><span class="keyword">while</span> (zone_size &lt; ZALLOC_MAX_ZONE_SIZE &amp;&amp; (zone_size &lt;&lt; <span class="number">1</span>) &lt; (limsize / <span class="number">1024</span>))</span><br><span class="line">    zone_size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">zone_limit = zone_size / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (zone_limit &gt; ZALLOC_ZONE_LIMIT)</span><br><span class="line">    zone_limit = ZALLOC_ZONE_LIMIT;</span><br><span class="line"></span><br><span class="line">zone_page_cnt = zone_size / RT_MM_PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算 zone 的大小、對象大小的上限及總頁數</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"zone size 0x%x, zone page count 0x%x\n"</span>,</span><br><span class="line">                                 zone_size, zone_page_cnt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate memusage array */</span></span><br><span class="line">    limsize  = npages * <span class="keyword">sizeof</span>(struct memusage);</span><br><span class="line">    limsize  = RT_ALIGN(limsize, RT_MM_PAGE_SIZE);</span><br><span class="line">    memusage = rt_page_alloc(limsize / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"memusage 0x%x, size 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)memusage, limsize));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後建立一個陣列紀錄頁的資訊</li></ul><hr><h3 id="rt-page-init">rt_page_init<a class="header-anchor" href="#rt-page-init">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化頁分配器</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*addr</code></th><th><code>npages</code></th></tr></thead><tbody><tr><td>存放頁的記憶體位址</td><td>頁的總數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize the page allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rt_page_init</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rt_page_list = RT_NULL;</span><br><span class="line">    rt_page_free(addr, npages);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>將 page list 設為空，釋放所有的 page</li></ul><hr><h2 id="分配記憶體">分配記憶體<a class="header-anchor" href="#分配記憶體">#</a></h2><h3 id="rt-malloc">rt_malloc<a class="header-anchor" href="#rt-malloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求記憶體</td><td>記憶體位址</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will allocate a block from system heap memory.</span></span><br><span class="line"><span class="comment"> * - If the nbytes is less than zero,</span></span><br><span class="line"><span class="comment"> * or</span></span><br><span class="line"><span class="comment"> * - If there is no nbytes sized memory valid in system,</span></span><br><span class="line"><span class="comment"> * the RT_NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size the size of memory to be allocated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="keyword">rt_int32_t</span> zi;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero size, return RT_NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size = 0，回傳 NULL</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle large allocations directly.  There should not be very many of</span></span><br><span class="line"><span class="comment"> * these so performance is not a big issue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= zone_limit)</span><br><span class="line">{</span><br><span class="line">    size = RT_ALIGN(size, RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    chunk = rt_page_alloc(size &gt;&gt; RT_MM_PAGE_BITS);</span><br><span class="line">    <span class="keyword">if</span> (chunk == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size 超過一個 chunk 的上限，則透過頁分配器來分配</li><li>且如果失敗了，直接回傳 <code>NULL</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set kup */</span></span><br><span class="line">kup = btokup(chunk);</span><br><span class="line">kup-&gt;type = PAGE_TYPE_LARGE;</span><br><span class="line">kup-&gt;size = size &gt;&gt; RT_MM_PAGE_BITS;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定頁的資訊：<ul><li>type：<code>PAGE_TYPE_LARGE</code></li><li>size：用了幾頁</li></ul></li><li>btokup：<code>&amp;memusage[((rt_uint32_t)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS]</code><ul><li>找到陣列中與起始位置的差值，位移 12-bit，即除一頁的大小</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"malloc a large memory 0x%x, page cnt %d, kup %d\n"</span>,</span><br><span class="line">                      size,</span><br><span class="line">                      size &gt;&gt; RT_MM_PAGE_BITS,</span><br><span class="line">                      ((<span class="keyword">rt_uint32_t</span>)chunk - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += size;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>要鎖，更新使用大小，跳到 <code>__done</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock heap */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to allocate out of an existing zone.  First try the free list,</span></span><br><span class="line"><span class="comment"> * then allocate out of unallocated space.  If we find a good zone move</span></span><br><span class="line"><span class="comment"> * it to the head of the list so later allocations find it quickly</span></span><br><span class="line"><span class="comment"> * (we might have thousands of zones in the list).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: zoneindex() will panic of size is too large.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">zi = zoneindex(&amp;size);</span><br><span class="line">RT_ASSERT(zi &lt; NZONES);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 size 小於一個 chunk 的上限，尋找此大小對應的 zone</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"try to malloc 0x%x on zone: %d\n"</span>, size, zi));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((z = zone_array[zi]) != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(z-&gt;z_nfree &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove us from the zone_array[] when we become empty */</span></span><br><span class="line">    <span class="keyword">if</span> (--z-&gt;z_nfree == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        zone_array[zi] = z-&gt;z_next;</span><br><span class="line">        z-&gt;z_next = RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果該 zone 不為空，且此 zone 剩最後一顆可用時，將此 zone 刪除</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No chunks are available but nfree said we had some memory, so</span></span><br><span class="line"><span class="comment">         * it must be available in the never-before-used-memory area</span></span><br><span class="line"><span class="comment">         * governed by uindex.  The consequences are very serious if our zone</span></span><br><span class="line"><span class="comment">         * got corrupted so we use an explicit rt_kprintf rather then a KASSERT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;z_uindex + <span class="number">1</span> != z-&gt;z_nmax)</span><br><span class="line">        {</span><br><span class="line">            z-&gt;z_uindex = z-&gt;z_uindex + <span class="number">1</span>;</span><br><span class="line">            chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* find on free chunk list */</span></span><br><span class="line">            chunk = z-&gt;z_freechunk;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* remove this chunk from list */</span></span><br><span class="line">            z-&gt;z_freechunk = z-&gt;z_freechunk-&gt;c_next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>取得一塊，跳至 done<ul><li>從 <code>uindex</code> 找，這種方式取得的屬於此 zone 最初的 chunk</li><li>如果不行，從 free list 中取得，並從 free list 移除此 chunk；這種的 chunk 是已經被要過，又還回來的</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If all zones are exhausted we need to allocate a new zone for this</span></span><br><span class="line"><span class="comment"> * index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * At least one subsystem, the tty code (see CROUND) expects power-of-2</span></span><br><span class="line"><span class="comment"> * allocations to be power-of-2 aligned.  We maintain compatibility by</span></span><br><span class="line"><span class="comment"> * adjusting the base offset below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_int32_t</span> off;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = zone_free) != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* remove zone from free zone list */</span></span><br><span class="line">        zone_free = z-&gt;z_next;</span><br><span class="line">        -- zone_free_cnt;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到的 zone 為空，且 <code>zone_free</code> 不為空：代表有可用的空 zone 可以使用</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* unlock heap, since page allocator will think about lock */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a zone from page */</span></span><br><span class="line">    z = rt_page_alloc(zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (z == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        chunk = RT_NULL;</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>否則需要重新與頁分配器要一個 zone</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"alloc a new zone: 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)z));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set message usage */</span></span><br><span class="line">    <span class="keyword">for</span> (off = <span class="number">0</span>, kup = btokup(z); off &lt; zone_page_cnt; off ++)</span><br><span class="line">    {</span><br><span class="line">        kup-&gt;type = PAGE_TYPE_SMALL;</span><br><span class="line">        kup-&gt;size = off;</span><br><span class="line"></span><br><span class="line">        kup ++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定每一頁的資訊</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear to zero */</span></span><br><span class="line">rt_memset(z, <span class="number">0</span>, <span class="keyword">sizeof</span>(slab_zone));</span><br></pre></td></tr></tbody></table></figure><ul><li>清空整個 zone</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset of slab zone struct in zone */</span></span><br><span class="line">off = <span class="keyword">sizeof</span>(slab_zone);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Guarentee power-of-2 alignment for power-of-2-sized chunks.</span></span><br><span class="line"><span class="comment"> * Otherwise just 8-byte align the data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((size | (size - <span class="number">1</span>)) + <span class="number">1</span> == (size &lt;&lt; <span class="number">1</span>))</span><br><span class="line">    off = (off + size - <span class="number">1</span>) &amp; ~(size - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    off = (off + MIN_CHUNK_MASK) &amp; ~MIN_CHUNK_MASK;</span><br></pre></td></tr></tbody></table></figure><ul><li>計算我們要用的對齊法：<ul><li>如果 size 是二的次方，將 off (zone 的頭) 與 size 向上對齊</li><li>否則直接與 8 向上對齊</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br></pre></td><td class="code"><pre><span class="line">z-&gt;z_magic     = ZALLOC_SLAB_MAGIC;</span><br><span class="line">z-&gt;z_zoneindex = zi;</span><br><span class="line">z-&gt;z_nmax      = (zone_size - off) / size;</span><br><span class="line">z-&gt;z_nfree     = z-&gt;z_nmax - <span class="number">1</span>;</span><br><span class="line">z-&gt;z_baseptr   = (<span class="keyword">rt_uint8_t</span> *)z + off;</span><br><span class="line">z-&gt;z_uindex    = <span class="number">0</span>;</span><br><span class="line">z-&gt;z_chunksize = size;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic、對應 <code>zone_array</code> 的 index<ul><li>最大數量為 <code>zone_size</code> - off 再除以一個 chunk 的大小</li><li>目前可用的數量則為最大數量減 1，因為待會會拿走一塊</li><li>基址為起始位址加上 <code>off，uindex</code> 為 0，這是之後 alloc 時可直接使用這兩個來找到 free chunk</li><li>最後設定 chunk size</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">        chunk = (slab_chunk *)(z-&gt;z_baseptr + z-&gt;z_uindex * size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* link to zone array */</span></span><br><span class="line">        z-&gt;z_next = zone_array[zi];</span><br><span class="line">        zone_array[zi] = z;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem += z-&gt;z_chunksize;</span><br><span class="line">        <span class="keyword">if</span> (used_mem &gt; max_mem)</span><br><span class="line">            max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>拿走第一塊，並將這個 zone 插上對應的 zone array entry</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line">done:</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_malloc_hook, ((<span class="keyword">char</span> *)chunk, size));</span><br><span class="line"></span><br><span class="line">__exit:</span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳找到的 chunk</li></ul><hr><h4 id="zoneindex">zoneindex<a class="header-anchor" href="#zoneindex">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*bytes</code></th></tr></thead><tbody><tr><td>尋找傳入的 size 對應 zone array 的 index</td><td>index</td><td>傳入的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the zone index for the allocation request size and set the</span></span><br><span class="line"><span class="comment"> * allocation request size to that particular zone's chunk size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">rt_inline <span class="keyword">int</span> <span class="title">zoneindex</span><span class="params">(<span class="keyword">rt_uint32_t</span> *bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* unsigned for shift opt */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> n = (<span class="keyword">rt_uint32_t</span>) * bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">128</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">7</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 8 byte chunks, 16 zones */</span></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">256</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">15</span>) &amp; ~<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">16</span> + <span class="number">7</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">8192</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">512</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">31</span>) &amp; ~<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">32</span> + <span class="number">15</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1024</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">64</span> + <span class="number">23</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2048</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">127</span>) &amp; ~<span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">128</span> + <span class="number">31</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4096</span>)</span><br><span class="line">        {</span><br><span class="line">            *bytes = n = (n + <span class="number">255</span>) &amp; ~<span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (n / <span class="number">256</span> + <span class="number">39</span>);</span><br><span class="line">        }</span><br><span class="line">        *bytes = n = (n + <span class="number">511</span>) &amp; ~<span class="number">511</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">512</span> + <span class="number">47</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">16384</span>)</span><br><span class="line">    {</span><br><span class="line">        *bytes = n = (n + <span class="number">1023</span>) &amp; ~<span class="number">1023</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n / <span class="number">1024</span> + <span class="number">55</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"Unexpected byte count %d"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根據不同的 range，將傳入的大小對齊，並平均分配每個 range 有 16 個 zone index</p><hr><h4 id="rt-page-alloc">rt_page_alloc<a class="header-anchor" href="#rt-page-alloc">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>npages</code></th></tr></thead><tbody><tr><td>要求頁記憶體</td><td>頁</td><td>欲要求的頁數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_page_alloc</span><span class="params">(<span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (npages == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;page &gt; npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* splite pages */</span></span><br><span class="line">            n       = b + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            n-&gt;page = b-&gt;page - npages;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到一個頁數大於需求的，選擇此頁，並分割</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (b-&gt;page == npages)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* this node fit, remove this node */</span></span><br><span class="line">            *prev = b-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有一個剛剛好，選擇此頁</li><li>最後回傳選擇的頁</li></ul><hr><h3 id="rt-realloc">rt_realloc<a class="header-anchor" href="#rt-realloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/縮減記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*rmem</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲增長/縮減的記憶體位址</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the size of previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the previously allocated memory block</span></span><br><span class="line"><span class="comment"> * @param size the new size of memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *nptr;</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的 <code>ptr</code> 為空，<code>malloc(size)</code></li><li>如果傳入的 <code>size</code> 為 0，<code>free(ptr)</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the original allocation's zone.  If the new request winds up</span></span><br><span class="line"><span class="comment"> * using the same chunk size we do not have to do anything.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kup = btokup((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line"><span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_size_t</span> osize;</span><br><span class="line"></span><br><span class="line">    osize = kup-&gt;size &lt;&lt; RT_MM_PAGE_BITS;</span><br><span class="line">    <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    rt_memcpy(nptr, ptr, size &gt; osize ? osize : size);</span><br><span class="line">    rt_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查此 <code>ptr</code> 所在的頁資訊，如果是 LARGE，代表原來的 <code>ptr</code> 是由頁分配器所分配的</li><li>新 <code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_SMALL)</span><br><span class="line">{</span><br><span class="line">    z = (slab_zone *)(((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    zoneindex(&amp;size);</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_chunksize == size)</span><br><span class="line">        <span class="keyword">return</span> (ptr); <span class="comment">/* same chunk */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果是 SMALL，首先找到歸屬得 zone：<ul><li>透過減掉頁資訊上的 size 乘以頁的大小，即可找到zone的初始位址</li><li>在 <code>malloc</code> 中，建立 zone 時 size 是從 0 開始填，一頁一頁加一</li><li>如果新的大小與原本的 chunk 相同，不做事</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Allocate memory for the new request size.  Note that zoneindex has</span></span><br><span class="line"><span class="comment">         * already adjusted the request size to the appropriate chunk size, which</span></span><br><span class="line"><span class="comment">         * should optimize our bcopy().  Then copy and return the new pointer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((nptr = rt_malloc(size)) == RT_NULL)</span><br><span class="line">            <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">        rt_memcpy(nptr, ptr, size &gt; z-&gt;z_chunksize ? z-&gt;z_chunksize : size);</span><br><span class="line">        rt_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不同，<code>malloc(size)</code>，並還原資料，釋放舊的記憶體</li></ul><hr><h3 id="rt-calloc">rt_calloc<a class="header-anchor" href="#rt-calloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一段連續的記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>一塊的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 memheap 相同，一次要一塊 <code>count</code> 乘 <code>size</code> 的記憶體</li><li>清 0 並回傳起始位址</li></ul><hr><h2 id="釋放記憶體">釋放記憶體<a class="header-anchor" href="#釋放記憶體">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*ptr</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previous allocated memory block by rt_malloc.</span></span><br><span class="line"><span class="comment"> * The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ptr the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    slab_zone *z;</span><br><span class="line">    slab_chunk *chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> *<span class="title">kup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free a RT_NULL pointer */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_free_hook, (ptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get memory usage */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_DEBUG_SLAB</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_uint32_t</span> addr = ((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free a memory 0x%x and align to 0x%x, kup index %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)ptr,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)addr,</span><br><span class="line">                      ((<span class="keyword">rt_uint32_t</span>)(addr) - heap_start) &gt;&gt; RT_MM_PAGE_BITS));</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    kup = btokup((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK);</span><br><span class="line">    <span class="comment">/* release large allocation */</span></span><br><span class="line">    <span class="keyword">if</span> (kup-&gt;type == PAGE_TYPE_LARGE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_uint32_t</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* lock heap */</span></span><br><span class="line">        rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">/* clear page counter */</span></span><br><span class="line">        size = kup-&gt;size;</span><br><span class="line">        kup-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= size * RT_MM_PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SLAB,</span><br><span class="line">                     (<span class="string">"free large memory block 0x%x, page count %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)ptr, size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free this page */</span></span><br><span class="line">        rt_page_free(ptr, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果要釋放的記憶體是由頁分配器分配的，根據頁資訊中的 size 來釋放，並清 0</li><li>實際呼叫 <code>rt_page_free(ptr, size)</code> 來完成</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone case. get out zone. */</span></span><br><span class="line">    z = (slab_zone *)(((<span class="keyword">rt_uint32_t</span>)ptr &amp; ~RT_MM_PAGE_MASK) -</span><br><span class="line">                      kup-&gt;size * RT_MM_PAGE_SIZE);</span><br><span class="line">    RT_ASSERT(z-&gt;z_magic == ZALLOC_SLAB_MAGIC);</span><br><span class="line"></span><br><span class="line">    chunk          = (slab_chunk *)ptr;</span><br><span class="line">    chunk-&gt;c_next  = z-&gt;z_freechunk;</span><br><span class="line">    z-&gt;z_freechunk = chunk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= z-&gt;z_chunksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果是由 zone 分配，找到歸屬的 zone，並將需要釋放的 chunk 插到 free list 上</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bump the number of free chunks.  If it becomes non-zero the zone</span></span><br><span class="line"><span class="comment"> * must be added back onto the appropriate list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree++ == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    z-&gt;z_next = zone_array[z-&gt;z_zoneindex];</span><br><span class="line">    zone_array[z-&gt;z_zoneindex] = z;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>nfree</code>，如果本來為 0 ，則需要將此 zone 插回 zone array</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the zone becomes totally free, and there are other zones we</span></span><br><span class="line"><span class="comment"> * can allocate from, move this zone to the FreeZones list.  Since</span></span><br><span class="line"><span class="comment"> * this code can be called from an IPI callback, do *NOT* try to mess</span></span><br><span class="line"><span class="comment"> * with kernel_map here.  Hysteresis will be performed at malloc() time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (z-&gt;z_nfree == z-&gt;z_nmax &amp;&amp;</span><br><span class="line">    (z-&gt;z_next || zone_array[z-&gt;z_zoneindex] != z))</span><br><span class="line">{</span><br><span class="line">    slab_zone **pz;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SLAB, (<span class="string">"free zone 0x%x\n"</span>,</span><br><span class="line">                                 (<span class="keyword">rt_uint32_t</span>)z, z-&gt;z_zoneindex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove zone from zone array list */</span></span><br><span class="line">    <span class="keyword">for</span> (pz = &amp;zone_array[z-&gt;z_zoneindex]; z != *pz; pz = &amp;(*pz)-&gt;z_next)</span><br><span class="line">        ;</span><br><span class="line">    *pz = z-&gt;z_next;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果釋放完這個 chunk 後整個 zone 都釋放完了，我們需要釋放整個 zone</li><li>這裡還同時確保在同一個 zone array entry 中還有其他的 zone 可以分配</li><li>接著我們把這個 zone 從 zone array 移除</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset zone */</span></span><br><span class="line">z-&gt;z_magic = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* insert to free zone list */</span></span><br><span class="line">z-&gt;z_next = zone_free;</span><br><span class="line">zone_free = z;</span><br><span class="line"></span><br><span class="line">++ zone_free_cnt;</span><br></pre></td></tr></tbody></table></figure><ul><li>重設 magic，將這個 zone 插上 free zone，free count 加一</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release zone to page allocator */</span></span><br><span class="line">        <span class="keyword">if</span> (zone_free_cnt &gt; ZONE_RELEASE_THRESH)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">rt_base_t</span> i;</span><br><span class="line"></span><br><span class="line">            z         = zone_free;</span><br><span class="line">            zone_free = z-&gt;z_next;</span><br><span class="line">            -- zone_free_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set message usage */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>, kup = btokup(z); i &lt; zone_page_cnt; i ++)</span><br><span class="line">            {</span><br><span class="line">                kup-&gt;type = PAGE_TYPE_FREE;</span><br><span class="line">                kup-&gt;size = <span class="number">0</span>;</span><br><span class="line">                kup ++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* unlock heap */</span></span><br><span class="line">            rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* release pages */</span></span><br><span class="line">            rt_page_free(z, zone_size / RT_MM_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果已經有 <code>ZONE_RELEASE_THRESH</code> (2) 個以上的 free zone，完全釋放一個 zone 給頁分配器<ul><li>從 free zone 中移除，free count 減一</li><li>重設頁資訊：type free、size 0</li><li>透過 <code>rt_page_free</code> 完成</li></ul></li></ul><hr><h3 id="rt-page-free">rt_page_free<a class="header-anchor" href="#rt-page-free">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>釋放頁記憶體</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*addr</code></th><th><code>pages</code></th></tr></thead><tbody><tr><td>欲釋放的頁</td><td>欲釋放的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_free</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">b</span>, *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> **<span class="title">prev</span>;</span></span><br><span class="line">    RT_ASSERT(addr != RT_NULL);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint32_t</span>)addr % RT_MM_PAGE_SIZE == <span class="number">0</span>);</span><br><span class="line">    RT_ASSERT(npages != <span class="number">0</span>);</span><br><span class="line">    n = (struct rt_page_head *)addr;</span><br><span class="line">    <span class="comment">/* lock heap */</span></span><br><span class="line">    rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;rt_page_list; (b = *prev) != RT_NULL; prev = &amp;(b-&gt;next))</span><br><span class="line">    {</span><br><span class="line">        RT_ASSERT(b-&gt;page &gt; <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT(b &gt; n || b + b-&gt;page &lt;= n);</span><br><span class="line">        <span class="keyword">if</span> (b + b-&gt;page == n)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (b + (b-&gt;page += npages) == b-&gt;next)</span><br><span class="line">            {</span><br><span class="line">                b-&gt;page += b-&gt;next-&gt;page;</span><br><span class="line">                b-&gt;next  = b-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b == n + npages)</span><br><span class="line">        {</span><br><span class="line">            n-&gt;page = b-&gt;page + npages;</span><br><span class="line">            n-&gt;next = b-&gt;next;</span><br><span class="line">            *prev   = n;</span><br><span class="line">            <span class="keyword">goto</span> _return;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b &gt; n + npages)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    n-&gt;page = npages;</span><br><span class="line">    n-&gt;next = b;</span><br><span class="line">    *prev   = n;</span><br><span class="line">_return:</span><br><span class="line">    <span class="comment">/* unlock heap */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> 記憶體管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Small Memory Manager</title>
      <link href="/posts/RT-Thread/small-mem.html"/>
      <url>/posts/RT-Thread/small-mem.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#defined RT_USING_HEAP &amp;&amp; #defined RT_USING_SMALL_MEM</code></p></blockquote><ul><li>與 memory heap 的做法類似，一開始是一塊大的記憶體，包含 header</li><li>分配記憶體時適當的切割</li><li>所有的記憶體塊透過 header 串起來，形成一個雙向鏈結</li></ul><p><div class="img-item" data-src="https://i.imgur.com/tbptSYO.png" data-sub-html=".caption"><img src="https://i.imgur.com/tbptSYO.png" alt="" title="small memory example"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><hr><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> mem.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* magic and used flag */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> magic;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> next, prev;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> thread[<span class="number">4</span>];   <span class="comment">/* thread name */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>此結構即為一個記憶體塊的 header</li><li>包含了<ul><li>magic 碼 <code>0x1ea0</code></li><li>使用中標記</li><li>前一顆與下一顆</li><li>使用此記憶體的 thread 名稱（選）</li></ul></li></ul><hr><h2 id="初始化-heap">初始化 heap<a class="header-anchor" href="#初始化-heap">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 heap</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>記憶體起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will initialize system heap memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param begin_addr the beginning address of system heap memory.</span></span><br><span class="line"><span class="comment"> * @param end_addr the end address of system heap memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> begin_align = RT_ALIGN((<span class="keyword">rt_uint32_t</span>)begin_addr, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> end_align = RT_ALIGN_DOWN((<span class="keyword">rt_uint32_t</span>)end_addr, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊起始位址與向下對齊結束位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alignment addr */</span></span><br><span class="line"><span class="keyword">if</span> ((end_align &gt; (<span class="number">2</span> * SIZEOF_STRUCT_MEM)) &amp;&amp;</span><br><span class="line">    ((end_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM) &gt;= begin_align))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* calculate the aligned memory size */</span></span><br><span class="line">    mem_size_aligned = end_align - begin_align - <span class="number">2</span> * SIZEOF_STRUCT_MEM;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"mem init, error begin address 0x%x, and end address 0x%x\n"</span>,</span><br><span class="line">               (<span class="keyword">rt_uint32_t</span>)begin_addr, (<span class="keyword">rt_uint32_t</span>)end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查起始與結束位址是否合法</li><li>如果合法，給定 <code>mem_size</code> 為結束位址 - 起始位址 - 2 倍的 <code>struct mem</code> 大小</li><li>也就是與 <code>mem_heap</code> 相同，一開始的記憶體設定為一大塊，頭與尾都要有一個 header</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to begin address of heap */</span></span><br><span class="line">heap_ptr = (<span class="keyword">rt_uint8_t</span> *)begin_align;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"mem init, heap begin address 0x%x, size %d\n"</span>,</span><br><span class="line">                            (<span class="keyword">rt_uint32_t</span>)heap_ptr, mem_size_aligned));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the start of the heap */</span></span><br><span class="line">mem        = (struct heap_mem *)heap_ptr;</span><br><span class="line">mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line">mem-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">mem-&gt;prev  = <span class="number">0</span>;</span><br><span class="line">mem-&gt;used  = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定前面的 header：<ul><li>設定 magic 碼</li><li>下一塊為結尾的 header</li><li>上一塊為自己</li><li>以及沒有使用過</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the end of the heap */</span></span><br><span class="line">    heap_end        = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    heap_end-&gt;magic = HEAP_MAGIC;</span><br><span class="line">    heap_end-&gt;used  = <span class="number">1</span>;</span><br><span class="line">    heap_end-&gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line">    heap_end-&gt;prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(heap_end, <span class="string">"INIT"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定結尾的 header<ul><li>magic 碼</li><li>已被使用過</li><li>上一塊與下一塊指向自己</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_init(&amp;heap_sem, <span class="string">"heap"</span>, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize the lowest-free pointer to the start of the heap */</span></span><br><span class="line">    lfree = (struct heap_mem *)heap_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 semaphore</li><li>把這一塊掛上 <code>lfree</code></li></ul><hr><h2 id="分配記憶體">分配記憶體<a class="header-anchor" href="#分配記憶體">#</a></h2><h3 id="Code-rt-malloc">Code: rt_malloc<a class="header-anchor" href="#Code-rt-malloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求記憶體</td><td>記憶體位址</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a block of memory with a minimum of 'size' bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size is the minimum size of the requested block in bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory or NULL if no free memory was found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>size</code> 為 0，回傳 NULL</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != RT_ALIGN(size, RT_ALIGN_SIZE))</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d, but align to %d\n"</span>,</span><br><span class="line">                                size, RT_ALIGN(size, RT_ALIGN_SIZE)));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"malloc size %d\n"</span>, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alignment size */</span></span><br><span class="line">size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; mem_size_aligned)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"no memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 <code>size</code>，如果超過可用大小，回傳 NULL</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* every data block must be at least MIN_SIZE_ALIGNED long */</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; MIN_SIZE_ALIGNED)</span><br><span class="line">    size = MIN_SIZE_ALIGNED;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果小於 min size，設為 min size</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* take memory semaphore */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得 semaphore</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr = (<span class="keyword">rt_uint8_t</span> *)lfree - heap_ptr;</span><br><span class="line">     ptr &lt; mem_size_aligned - size;</span><br><span class="line">     ptr = ((struct heap_mem *)&amp;heap_ptr[ptr])-&gt;next)</span><br><span class="line">{</span><br><span class="line">    mem = (struct heap_mem *)&amp;heap_ptr[ptr];</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p>這裡特別的說明一下 for 迴圈：<br>首先起點是 <code>lfree</code> - <code>heap_ptr</code>，這裡代表最左邊的 free block 與 heap 起點的距離。 我們把 <code>heap_ptr</code> 看成是一個 <code>rt_uint8_t</code> 的陣列，也就是一格一個 byte 的陣列。 再來把 <code>lfree</code> - <code>heap_ptr</code> 看成是差量 (offset)，單位是 byte。 如此一來，<code>&amp;heap_ptr[ptr]</code> 就會是 <code>lfree</code> 的起始位置了。</p><p>再來我們看 <code>next</code>，在初始化的時候，<code>next</code> 是指向 0，這個意思是下一顆在陣列的第 0 個，也就是自己；所以 <code>next</code> 存放的是下一顆的 index，而不是起始位置。</p><p>最後來看上界，理論上我們需要從 lfree 找到最後一顆，實際上如果最後幾顆不夠大的話是不需要檢查的，所以這裡上界設在 <code>mem_size_aligned</code> - <code>size</code> 的意思就是說如果最後幾顆的大小總和不夠大，我們可以略過。</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!mem-&gt;used) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mem is not used and at least perfect fit is possible:</span></span><br><span class="line"><span class="comment">     * mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>first fit，如果找到第一顆可用的就進去</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;=</span><br><span class="line">    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))</span><br><span class="line">{</span><br></pre></td></tr></tbody></table></figure><ul><li>又，如果這顆夠大到可以切割的話</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing</span></span><br><span class="line"><span class="comment">                 * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')</span></span><br><span class="line"><span class="comment">                 * -&gt; split large block, create empty remainder,</span></span><br><span class="line"><span class="comment">                 * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if</span></span><br><span class="line"><span class="comment">                 * mem-&gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,</span></span><br><span class="line"><span class="comment">                 * struct heap_mem would fit in but no data between mem2 and mem2-&gt;next</span></span><br><span class="line"><span class="comment">                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty</span></span><br><span class="line"><span class="comment">                 *       region that couldn't hold data, but when mem-&gt;next gets freed,</span></span><br><span class="line"><span class="comment">                 *       the 2 regions would be combined, resulting in more free memory</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* create mem2 struct */</span></span><br><span class="line">                mem2       = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">                mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">                mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">                mem2-&gt;next = mem-&gt;next;</span><br><span class="line">                mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">                rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>設定下一顆的資料，同時把 <code>next</code> 與 <code>prev</code> 接到正確位置</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* and insert it between mem and mem-&gt;next */</span></span><br><span class="line">mem-&gt;next = ptr2;</span><br><span class="line">mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">{</span><br><span class="line">    ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把原本那塊的 <code>next</code> 指向新的那塊，設為使用中</li><li>如果新的那塊 <code>next</code> 不是最後一塊，設定 <code>prev</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += (size + SIZEOF_STRUCT_MEM);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>used_mem</code> 與 <code>max_mem</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* (a mem2 struct does no fit into the user data space of mem and mem-&gt;next will always</span></span><br><span class="line"><span class="comment">                 * be used at this point: if not we have 2 unused structs in a row, plug_holes should have</span></span><br><span class="line"><span class="comment">                 * take care of this).</span></span><br><span class="line"><span class="comment">                 * -&gt; near fit or excact fit: do not split, no mem2 creation</span></span><br><span class="line"><span class="comment">                 * also can't move mem-&gt;next directly behind mem, since mem-&gt;next</span></span><br><span class="line"><span class="comment">                 * will always be used at this point!</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mem-&gt;used = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">                used_mem += mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr);</span><br><span class="line">                <span class="keyword">if</span> (max_mem &lt; used_mem)</span><br><span class="line">                    max_mem = used_mem;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可切割，只需設定使用中即可</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* set memory block magic */</span></span><br><span class="line">            mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">            <span class="keyword">if</span> (rt_thread_self())</span><br><span class="line">                rt_mem_setname(mem, rt_thread_self()-&gt;name);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rt_mem_setname(mem, <span class="string">"NONE"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mem == lfree)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* Find next free block after mem and update lowest free pointer */</span></span><br><span class="line">                <span class="keyword">while</span> (lfree-&gt;used &amp;&amp; lfree != heap_end)</span><br><span class="line">                    lfree = (struct heap_mem *)&amp;heap_ptr[lfree-&gt;next];</span><br><span class="line"></span><br><span class="line">                RT_ASSERT(((lfree == heap_end) || (!lfree-&gt;used)));</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>視情況更新 <code>lfree</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line">        rt_sem_release(&amp;heap_sem);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)mem + SIZEOF_STRUCT_MEM + size &lt;= (<span class="keyword">rt_uint32_t</span>)heap_end);</span><br><span class="line">        RT_ASSERT((<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == <span class="number">0</span>);</span><br><span class="line">        RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)mem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">                     (<span class="string">"allocate memory at 0x%x, size: %d\n"</span>,</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM),</span><br><span class="line">                      (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_malloc_hook,</span><br><span class="line">                            (((<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM)), size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* return the memory data except mem struct */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>還鎖，並回傳找到的記憶體位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>沒找到一樣還鎖，並回傳 NULL</li></ul><hr><h3 id="Code-rt-realloc">Code: rt_realloc<a class="header-anchor" href="#Code-rt-realloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/縮減記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*rmeme</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲增長/縮減的記憶體位址</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will change the previously allocated memory block.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem pointer to memory allocated by rt_malloc</span></span><br><span class="line"><span class="comment"> * @param newsize the required new size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the changed memory block address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="keyword">rt_size_t</span> ptr, ptr2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>, *<span class="title">mem2</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *nmem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alignment size */</span></span><br><span class="line">    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (newsize &gt; mem_size_aligned)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"realloc: out of memory\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 size，如果：<ul><li>大於可用大小，回傳 NULL</li><li>等於 0，free 記憶體，回傳 NULL</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate a new memory block */</span></span><br><span class="line"><span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">    <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如原來的記憶體為空，直接 <code>malloc</code>，並回傳</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* illegal memory */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著取得鎖，檢查傳入的記憶體是否合法</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br><span class="line"></span><br><span class="line">ptr = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">size = mem-&gt;next - ptr - SIZEOF_STRUCT_MEM;</span><br><span class="line"><span class="keyword">if</span> (size == newsize)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* the size is the same as */</span></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>找到記憶體塊的起始位址，算出 size，如果記憶體大小不需要變動，不做事，回傳原本的記憶體位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* split memory block */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">        used_mem -= (size - newsize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;</span><br><span class="line">        mem2 = (struct heap_mem *)&amp;heap_ptr[ptr2];</span><br><span class="line">        mem2-&gt;magic = HEAP_MAGIC;</span><br><span class="line">        mem2-&gt;used = <span class="number">0</span>;</span><br><span class="line">        mem2-&gt;next = mem-&gt;next;</span><br><span class="line">        mem2-&gt;prev = ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">        rt_mem_setname(mem2, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        mem-&gt;next = ptr2;</span><br><span class="line">        <span class="keyword">if</span> (mem2-&gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)</span><br><span class="line">        {</span><br><span class="line">            ((struct heap_mem *)&amp;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以切割，與上面的動作相同</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">    plug_holes(mem2);</span><br><span class="line"></span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>plug_holes</code> 來合併 free block</li><li>還鎖，回傳更新後的記憶體位置</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br></pre></td><td class="code"><pre><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expand memory */</span></span><br><span class="line">    nmem = rt_malloc(newsize);</span><br><span class="line">    <span class="keyword">if</span> (nmem != RT_NULL) <span class="comment">/* check memory */</span></span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(nmem, rmem, size &lt; newsize ? size : newsize);</span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可切割，或是需要增長，直接要一塊 new size，釋放原本的記憶體</li><li>最後回傳新的記憶體位址</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*mem</code></th></tr></thead><tbody><tr><td>合併 free block</td><td>void</td><td>欲合併的記憶體位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">plug_holes</span><span class="params">(struct heap_mem *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">nmem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">pmem</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &gt;= heap_ptr);</span><br><span class="line">    RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)mem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line">    RT_ASSERT(mem-&gt;used == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* plug hole forward */</span></span><br><span class="line">    nmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;next];</span><br><span class="line">    <span class="keyword">if</span> (mem != nmem &amp;&amp;</span><br><span class="line">        nmem-&gt;used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">rt_uint8_t</span> *)nmem != (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;next is unused and not end of heap_ptr,</span></span><br><span class="line"><span class="comment">         * combine mem and mem-&gt;next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == nmem)</span><br><span class="line">        {</span><br><span class="line">            lfree = mem;</span><br><span class="line">        }</span><br><span class="line">        mem-&gt;next = nmem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[nmem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以與下一顆合併</li><li>檢查是否需要更新 <code>lfree</code></li><li>重新接上 <code>next</code> 與 <code>prev</code> (<code>next</code> 的 <code>prev</code>)</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* plug hole backward */</span></span><br><span class="line">    pmem = (struct heap_mem *)&amp;heap_ptr[mem-&gt;prev];</span><br><span class="line">    <span class="keyword">if</span> (pmem != mem &amp;&amp; pmem-&gt;used == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* if mem-&gt;prev is unused, combine mem and mem-&gt;prev */</span></span><br><span class="line">        <span class="keyword">if</span> (lfree == mem)</span><br><span class="line">        {</span><br><span class="line">            lfree = pmem;</span><br><span class="line">        }</span><br><span class="line">        pmem-&gt;next = mem-&gt;next;</span><br><span class="line">        ((struct heap_mem *)&amp;heap_ptr[mem-&gt;next])-&gt;prev = (<span class="keyword">rt_uint8_t</span> *)pmem - heap_ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以與上一顆合併，動作一樣</li></ul><hr><h3 id="Code-rt-calloc">Code: rt_calloc<a class="header-anchor" href="#Code-rt-calloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一段連續的記憶體</td><td>記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>一塊的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will contiguously allocate enough space for count objects</span></span><br><span class="line"><span class="comment"> * that are size bytes of memory each and returns a pointer to the allocated</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated memory is filled with bytes of value zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param count number of objects to allocate</span></span><br><span class="line"><span class="comment"> * @param size size of the objects to allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pointer to allocated memory / NULL pointer if there is an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate 'count' objects of size 'size' */</span></span><br><span class="line">    p = rt_malloc(count * size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero the memory */</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        rt_memset(p, <span class="number">0</span>, count * size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 memheap 相同，一次要一塊 count 乘 size 的記憶體</li><li>清 0 並回傳起始位址</li></ul><hr><h2 id="釋放記憶體">釋放記憶體<a class="header-anchor" href="#釋放記憶體">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*rmem</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release the previously allocated memory block by</span></span><br><span class="line"><span class="comment"> * rt_malloc. The released memory block is taken back to system heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rmem the address of memory which will be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap_mem</span> *<span class="title">mem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要釋放得記憶體為空，不做事</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">RT_ASSERT((((<span class="keyword">rt_uint32_t</span>)rmem) &amp; (RT_ALIGN_SIZE - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">RT_ASSERT((<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_ptr &amp;&amp;</span><br><span class="line">          (<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_end);</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">rt_uint8_t</span> *)rmem &lt; (<span class="keyword">rt_uint8_t</span> *)heap_ptr ||</span><br><span class="line">    (<span class="keyword">rt_uint8_t</span> *)rmem &gt;= (<span class="keyword">rt_uint8_t</span> *)heap_end)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="string">"illegal memory\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the corresponding struct heap_mem ... */</span></span><br><span class="line">mem = (struct heap_mem *)((<span class="keyword">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);</span><br></pre></td></tr></tbody></table></figure><ul><li>檢查記憶體位址是否合法，並找到真正的記憶體區塊位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEM,</span><br><span class="line">             (<span class="string">"release memory 0x%x, size: %d\n"</span>,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)rmem,</span><br><span class="line">              (<span class="keyword">rt_uint32_t</span>)(mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr))));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* protect the heap from concurrent access */</span></span><br><span class="line">rt_sem_take(&amp;heap_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... which has to be in a used state ... */</span></span><br><span class="line"><span class="keyword">if</span> (!mem-&gt;used || mem-&gt;magic != HEAP_MAGIC)</span><br><span class="line">{</span><br><span class="line">    rt_kprintf(<span class="string">"to free a bad data block:\n"</span>);</span><br><span class="line">    rt_kprintf(<span class="string">"mem: 0x%08x, used flag: %d, magic code: 0x%04x\n"</span>, mem, mem-&gt;used, mem-&gt;magic);</span><br><span class="line">}</span><br><span class="line">RT_ASSERT(mem-&gt;used);</span><br><span class="line">RT_ASSERT(mem-&gt;magic == HEAP_MAGIC);</span><br></pre></td></tr></tbody></table></figure><ul><li>要鎖，檢查是否是使用中的區塊，及是否屬於 heap</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* ... and is now unused. */</span></span><br><span class="line">    mem-&gt;used  = <span class="number">0</span>;</span><br><span class="line">    mem-&gt;magic = HEAP_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMTRACE</span></span><br><span class="line">    rt_mem_setname(mem, <span class="string">"    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem &lt; lfree)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* the newly freed struct is now the lowest */</span></span><br><span class="line">        lfree = mem;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設為可使用，及更新 <code>lfree</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_MEM_STATS</span></span><br><span class="line">    used_mem -= (mem-&gt;next - ((<span class="keyword">rt_uint8_t</span> *)mem - heap_ptr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finally, see if prev or next are free also */</span></span><br><span class="line">    plug_holes(mem);</span><br><span class="line">    rt_sem_release(&amp;heap_sem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後合併記憶體塊，並還鎖</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> 記憶體管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Memory Heap</title>
      <link href="/posts/RT-Thread/memheap.html"/>
      <url>/posts/RT-Thread/memheap.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#define RT_USING_MEMHEAP_AS_HEAP</code></p></blockquote><ul><li>memheap 的管理方法（動態管理）:<ul><li>從 RAM 中要一塊記憶體</li><li>根據使用者需要的大小進行切割</li><li>剩下的以雙向鏈結的方式接起來，形成 free list</li></ul></li></ul><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMHEAP</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * memory item on the heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             magic;                      <span class="comment">/**&lt; magic number for memheap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span>      *<span class="title">pool_ptr</span>;</span>                   <span class="comment">/**&lt; point of pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next</span>;</span>                       <span class="comment">/**&lt; next memheap item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">prev</span>;</span>                       <span class="comment">/**&lt; prev memheap item */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next_free</span>;</span>                  <span class="comment">/**&lt; next free memheap item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">prev_free</span>;</span>                  <span class="comment">/**&lt; prev free memheap item */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base structure of memory heap object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span>        <span class="title">parent</span>;</span>                     <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                   *start_addr;                 <span class="comment">/**&lt; pool start address and size */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             pool_size;                  <span class="comment">/**&lt; pool size */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             available_size;             <span class="comment">/**&lt; available size */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>             max_used_size;              <span class="comment">/**&lt; maximum allocated size */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">block_list</span>;</span>                 <span class="comment">/**&lt; used block list */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">free_list</span>;</span>                  <span class="comment">/**&lt; free block list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span>  <span class="title">free_header</span>;</span>                <span class="comment">/**&lt; free block list header */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span>     <span class="title">lock</span>;</span>                       <span class="comment">/**&lt; semaphore lock */</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>*start_addr</code> 指向可用的記憶體<br><br></li><li><code>pool_size</code> 代表總共可用的大小</li><li><code>available_size</code> 目前可用的大小</li><li><code>max_used_size</code> 已使用的歷史中，最大的使用大小<br><br></li><li><code>*block_list</code> 所有切割過的區塊（包含 header）<br><br></li><li><code>*free_list</code> 目前所有可用的區塊</li><li><code>*free_list</code> 的第一顆<br><br></li><li><code>lock</code> semaphore</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> memheap.c</p></div><h2 id="建立-memory-heap">建立 memory heap<a class="header-anchor" href="#建立-memory-heap">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 memheap</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*begin_addr</code></th><th><code>*end_addr</code></th></tr></thead><tbody><tr><td>起始位址（欲分配的）</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span> *end_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* initialize a default heap in the system */</span></span><br><span class="line">    rt_memheap_init(&amp;_heap,</span><br><span class="line">                    <span class="string">"heap"</span>,</span><br><span class="line">                    begin_addr,</span><br><span class="line">                    (<span class="keyword">rt_uint32_t</span>)end_addr - (<span class="keyword">rt_uint32_t</span>)begin_addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>將起始位置，大小，結構體傳入 <code>rt_memheap_init</code></li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 memheap</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*memheap</code></th><th><code>*name</code></th><th><code>*start_addr</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>memheap 結構</td><td>名字</td><td>欲分配的記憶體起始位址</td><td>記憶體大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initialized memory pool will be:</span></span><br><span class="line"><span class="comment"> * +-----------------------------------+--------------------------+</span></span><br><span class="line"><span class="comment"> * | whole freed memory block          | Used Memory Block Tailer |</span></span><br><span class="line"><span class="comment"> * +-----------------------------------+--------------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * block_list --&gt; whole freed memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The length of Used Memory Block Tailer is 0,</span></span><br><span class="line"><span class="comment"> * which is prevents block merging across list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_memheap_init(struct rt_memheap *memheap,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span>        *name,</span><br><span class="line">                         <span class="keyword">void</span>              *start_addr,</span><br><span class="line">                         <span class="keyword">rt_uint32_t</span>        size)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">item</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(memheap != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize pool object */</span></span><br><span class="line">    rt_object_init(&amp;(memheap-&gt;parent), RT_Object_Class_MemHeap, name);</span><br><span class="line"></span><br><span class="line">    memheap-&gt;start_addr     = start_addr;</span><br><span class="line">    memheap-&gt;pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);</span><br><span class="line">    memheap-&gt;available_size = memheap-&gt;pool_size - (<span class="number">2</span> * RT_MEMHEAP_SIZE);</span><br><span class="line">    memheap-&gt;max_used_size  = memheap-&gt;pool_size - memheap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先填入 <code>start_addr</code></li><li>向下對齊 <code>size</code></li><li>設定可用大小為 <code>size</code> 減掉 2 個 header</li><li>設定最大已使用大小為目前已使用的大小（即 2 倍的 header）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize the free list header */</span></span><br><span class="line">item            = &amp;(memheap-&gt;free_header);</span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = RT_NULL;</span><br><span class="line">item-&gt;prev      = RT_NULL;</span><br><span class="line">item-&gt;next_free = item;</span><br><span class="line">item-&gt;prev_free = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>先初始化 free list：<ul><li>讓 item 指向 free list 的 header</li><li>設定 magic 碼</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向 <code>NULL</code></li><li><code>next_free</code>、<code>prev_free</code> 指向自己</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the free list to free list header */</span></span><br><span class="line">memheap-&gt;free_list = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>給定 free list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize the first big memory block */</span></span><br><span class="line">item            = (struct rt_memheap_item *)start_addr;</span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = RT_NULL;</span><br><span class="line">item-&gt;prev      = RT_NULL;</span><br><span class="line">item-&gt;next_free = item;</span><br><span class="line">item-&gt;prev_free = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著將整個 pool 設定為一個可用的 block<ul><li>讓 item 指向 起始位址</li><li>設定 magic 碼</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向 <code>NULL</code></li><li><code>next_free</code>、<code>prev_free</code> 指向自己</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">item-&gt;next = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)item + memheap-&gt;available_size + RT_MEMHEAP_SIZE);</span><br><span class="line">item-&gt;prev = item-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>讓 next 與 prev 指到結尾的 header</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* block list header */</span></span><br><span class="line">memheap-&gt;block_list = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>給定 block_list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place the big memory block to free list */</span></span><br><span class="line">item-&gt;next_free = memheap-&gt;free_list-&gt;next_free;</span><br><span class="line">item-&gt;prev_free = memheap-&gt;free_list;</span><br><span class="line">memheap-&gt;free_list-&gt;next_free-&gt;prev_free = item;</span><br><span class="line">memheap-&gt;free_list-&gt;next_free            = item;</span><br></pre></td></tr></tbody></table></figure><ul><li>將 free list (item) 的 <code>next</code> 指向 <code>memheap-&gt;free_list-&gt;next_free</code>，也就是 free list</li><li><code>prev</code> 同上</li><li>將 free list (heap) 的 <code>next</code> 指向 <code>item</code></li><li><code>prev</code> 同上</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move to the end of memory pool to build a small tailer block,</span></span><br><span class="line"><span class="comment"> * which prevents block merging</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">item = item-&gt;next;</span><br><span class="line"><span class="comment">/* it's a used memory block */</span></span><br><span class="line">item-&gt;magic     = RT_MEMHEAP_MAGIC | RT_MEMHEAP_USED;</span><br><span class="line">item-&gt;pool_ptr  = memheap;</span><br><span class="line">item-&gt;next      = (struct rt_memheap_item *)start_addr;</span><br><span class="line">item-&gt;prev      = (struct rt_memheap_item *)start_addr;</span><br><span class="line"><span class="comment">/* not in free list */</span></span><br><span class="line">item-&gt;next_free = item-&gt;prev_free = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定尾巴的 header<ul><li>讓 item 指向 free list 的 header</li><li>設定 magic 碼為<strong>使用過</strong>的</li><li>將 <code>pool_ptr</code> 指向 memheap 結構</li><li><code>next</code>、<code>prev</code> 指向起始位置</li><li><code>next_free</code>、<code>prev_free</code> 指向 <code>NULL</code></li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize semaphore lock */</span></span><br><span class="line">    rt_sem_init(&amp;(memheap-&gt;lock), name, <span class="number">1</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n"</span>,</span><br><span class="line">                  start_addr, size, &amp;(memheap-&gt;free_header)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 semaphore 並使用 FIFO</li></ul><hr><h2 id="刪除-memory-heap">刪除 memory heap<a class="header-anchor" href="#刪除-memory-heap">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*heap</code></th></tr></thead><tbody><tr><td>刪除 memheap</td><td><code>RT_EOK</code></td><td>欲刪除的 memheap</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_memheap_detach(struct rt_memheap *heap)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;heap-&gt;parent));</span><br><span class="line"></span><br><span class="line">    rt_object_detach(&amp;(heap-&gt;lock.parent.parent));</span><br><span class="line">    rt_object_detach(&amp;(heap-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return a successful completion. */</span></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>rt_object_detach</code> 刪除 semaphore 與 memheap</li></ul><hr><h2 id="分配記憶體">分配記憶體<a class="header-anchor" href="#分配記憶體">#</a></h2><h3 id="Code-rt-malloc">Code: rt_malloc<a class="header-anchor" href="#Code-rt-malloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>size</code></th></tr></thead><tbody><tr><td>要求一塊記憶體</td><td>取得的記憶體</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_malloc</span><span class="params">(<span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to allocate in system heap */</span></span><br><span class="line">    ptr = rt_memheap_alloc(&amp;_heap, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先嘗試從系統的 heap（<code>_heap</code>）要求記憶體（透過 <code>rt_memheap_alloc</code>）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to allocate on other memory heap */</span></span><br><span class="line">    information = rt_object_get_information(RT_Object_Class_MemHeap);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果失敗，嘗試從其他的 heap 要求</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line">RT_ASSERT(information != RT_NULL);</span><br><span class="line"><span class="keyword">for</span> (node  = information-&gt;object_list.next;</span><br><span class="line">     node != &amp;(information-&gt;object_list);</span><br><span class="line">     node  = node-&gt;next)</span><br><span class="line">{</span><br><span class="line">    object = rt_list_entry(node, struct rt_object, <span class="built_in">list</span>);</span><br><span class="line">    heap   = (struct rt_memheap *)object;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not allocate in the default system heap */</span></span><br><span class="line">    <span class="keyword">if</span> (heap == &amp;_heap)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>跳過系統的 heap</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br></pre></td><td class="code"><pre><span class="line">            ptr = rt_memheap_alloc(heap, size);</span><br><span class="line">            <span class="keyword">if</span> (ptr != RT_NULL)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_malloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣透過 <code>rt_memheap_alloc</code> 來完成</li><li>如果成功就跳出迴圈，最後回傳記憶體位址</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求一塊記憶體</td><td>取得的記憶體</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*heap</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>目標 heap</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_memheap_alloc</span><span class="params">(struct rt_memheap *heap, <span class="keyword">rt_uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> free_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align allocated size */</span></span><br><span class="line">    size = RT_ALIGN(size, RT_ALIGN_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; RT_MEMHEAP_MINIALLOC)</span><br><span class="line">        size = RT_MEMHEAP_MINIALLOC;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先向上對齊 <code>size</code></li><li>如果小於 <code>RT_MEMHEAP_MINIALLOC</code> (12)，設定為 <code>RT_MEMHEAP_MINIALLOC</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"allocate %d on heap:%8.*s"</span>,</span><br><span class="line">                                size, RT_NAME_MAX, heap-&gt;parent.name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; heap-&gt;available_size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* search on free list */</span></span><br><span class="line">    free_size = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 heap 還夠使用，先將 <code>free_size</code> 設為 0</li><li><code>free_size</code> 代表我們目前找到的可用大小</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著試著索取 semaphore</li><li>如果失敗，設定錯誤碼並回傳 NULL</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the first free memory block */</span></span><br><span class="line">header_ptr = heap-&gt;free_list-&gt;next_free;</span><br><span class="line"><span class="keyword">while</span> (header_ptr != heap-&gt;free_list &amp;&amp; free_size &lt; size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get current freed memory block size */</span></span><br><span class="line">    free_size = MEMITEM_SIZE(header_ptr);</span><br><span class="line">    <span class="keyword">if</span> (free_size &lt; size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* move to next free memory block */</span></span><br><span class="line">        header_ptr = header_ptr-&gt;next_free;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著從 free list 上一個一個找</li><li>使用 <em>first fit</em>，找到一個大魚的就退出迴圈</li><li><code>MEMITEM_SIZE(item)</code>：<code>((rt_uint32_t)item-&gt;next - (rt_uint32_t)item - RT_MEMHEAP_SIZE)</code></li><li>利用下一顆的位址減掉自己的位址取的總體大小，再減掉 header 的大小</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the memory is available. */</span></span><br><span class="line"><span class="keyword">if</span> (free_size &gt;= size)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* a block that satisfies the request has been found. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine if the block needs to be split. */</span></span><br><span class="line">    <span class="keyword">if</span> (free_size &gt;= (size + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">new_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* split the block. */</span></span><br><span class="line">        new_ptr = (struct rt_memheap_item *)</span><br><span class="line">                  (((<span class="keyword">rt_uint8_t</span> *)header_ptr) + size + RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有成功找到（不是因為走完迴圈才往下）</li><li>且這塊大到可以再切一塊，切割這塊：<ul><li>從找到的那塊開始往後一個 <code>size</code> 與一個 <code>RT_MEMHEAP_SIZE</code> 作為新的 header</li></ul></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"split: block[0x%08x] nextm[0x%08x] prevm[0x%08x] to new[0x%08x]\n"</span>,</span><br><span class="line">              header_ptr,</span><br><span class="line">              header_ptr-&gt;next,</span><br><span class="line">              header_ptr-&gt;prev,</span><br><span class="line">              new_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">new_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">new_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* break down the block list */</span></span><br><span class="line">new_ptr-&gt;prev          = header_ptr;</span><br><span class="line">new_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">header_ptr-&gt;next       = new_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>將此 block 插入 <code>block_list</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove header ptr from free list */</span></span><br><span class="line">header_ptr-&gt;next_free-&gt;prev_free = header_ptr-&gt;prev_free;</span><br><span class="line">header_ptr-&gt;prev_free-&gt;next_free = header_ptr-&gt;next_free;</span><br><span class="line">header_ptr-&gt;next_free = RT_NULL;</span><br><span class="line">header_ptr-&gt;prev_free = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 中移除找到的 block</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert new_ptr to free list */</span></span><br><span class="line">new_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">new_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = new_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = new_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new ptr: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                                new_ptr-&gt;next_free,</span><br><span class="line">                                new_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><ul><li>將分割好的 block 插入 free list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* decrement the available byte count.  */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size -</span><br><span class="line">                           size -</span><br><span class="line">                           RT_MEMHEAP_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* decrement the entire free size from the available bytes count. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - free_size;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不能切割，一樣更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove header_ptr from free list */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"one block: block[0x%08x], next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                  header_ptr,</span><br><span class="line">                  header_ptr-&gt;next_free,</span><br><span class="line">                  header_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">    header_ptr-&gt;next_free-&gt;prev_free = header_ptr-&gt;prev_free;</span><br><span class="line">    header_ptr-&gt;prev_free-&gt;next_free = header_ptr-&gt;next_free;</span><br><span class="line">    header_ptr-&gt;next_free = RT_NULL;</span><br><span class="line">    header_ptr-&gt;prev_free = RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 中移除找到的 block</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the allocated block as not available. */</span></span><br><span class="line">header_ptr-&gt;magic |= RT_MEMHEAP_USED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* release lock */</span></span><br><span class="line">rt_sem_release(&amp;(heap-&gt;lock));</span><br></pre></td></tr></tbody></table></figure><ul><li>標記為使用中，釋放 semaphore</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Return a memory address to the caller.  */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"alloc mem: memory[0x%08x], heap[0x%08x], size: %d\n"</span>,</span><br><span class="line">                  (<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)header_ptr + RT_MEMHEAP_SIZE),</span><br><span class="line">                  header_ptr,</span><br><span class="line">                  size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">rt_uint8_t</span> *)header_ptr + RT_MEMHEAP_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳 block 記憶體位址 + header</li><li>即回傳可用的區塊</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release lock */</span></span><br><span class="line">        rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"allocate memory: failed\n"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the completion status.  */</span></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_alloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找失敗，一樣釋放 semaphore</li><li>不論是找失敗，或是記憶體不足，皆回傳 NULL</li></ul><hr><h3 id="Code-rt-realloc">Code: rt_realloc<a class="header-anchor" href="#Code-rt-realloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>重新要求記憶體（增長或縮減）</td><td>新分配完的記憶體塊</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*rmem</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>欲重新分配的記憶體</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_realloc</span><span class="params">(<span class="keyword">void</span> *rmem, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *new_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rmem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的記憶體位置為空，直接 <code>rt_malloc(newsize)</code> 並回傳</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    rt_free(rmem);</span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>newsize</code> 為 0，free 傳入的記憶體位置，回傳 NULL</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get old memory item */</span></span><br><span class="line">header_ptr = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)rmem - RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得傳入的記憶體塊所屬的 header</li><li>malloc 時回傳的是可使用的起始位址，並不會包含 header，因此這裡減掉一個 header 的大小</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">671</span><br></pre></td><td class="code"><pre><span class="line">new_ptr = rt_memheap_realloc(header_ptr-&gt;pool_ptr, rmem, newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_memheap_realloc</code> 來完成</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_ptr == RT_NULL &amp;&amp; newsize != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* allocate memory block from other memheap */</span></span><br><span class="line">    new_ptr = rt_malloc(newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果無法在原本的 heap 完成增長（或縮減），直接從別的 heap 要一塊 <code>newsize</code> 大的記憶體</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (new_ptr != RT_NULL &amp;&amp; rmem != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">rt_size_t</span> oldsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the size of old memory block */</span></span><br><span class="line">        oldsize = MEMITEM_SIZE(header_ptr);</span><br><span class="line">        <span class="keyword">if</span> (newsize &gt; oldsize)</span><br><span class="line">            rt_memcpy(new_ptr, rmem, oldsize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rt_memcpy(new_ptr, rmem, newsize);</span><br><span class="line"></span><br><span class="line">        rt_free(rmem);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果最後有要成功，復原原本的資料</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> new_ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後回傳新的記憶體位址</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>重新要求記憶體（增長或縮減）</td><td>新分配完的記憶體塊</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>heap</code></th><th><code>*ptr</code></th><th><code>newsize</code></th></tr></thead><tbody><tr><td>目標 heap</td><td>欲重新分配的記憶體</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_memheap_realloc</span><span class="params">(struct rt_memheap *heap, <span class="keyword">void</span> *ptr, <span class="keyword">rt_size_t</span> newsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_size_t</span> oldsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">new_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_ASSERT(heap);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_memheap_free(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>newsize</code> 為 0，free 並回傳 NULL</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* align allocated size */</span></span><br><span class="line">newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);</span><br><span class="line"><span class="keyword">if</span> (newsize &lt; RT_MEMHEAP_MINIALLOC)</span><br><span class="line">    newsize = RT_MEMHEAP_MINIALLOC;</span><br></pre></td></tr></tbody></table></figure><ul><li>向上對齊 <code>newsize</code></li><li>如果小於 <code>RT_MEMHEAP_MINIALLOC</code> (12)，設定為 <code>RT_MEMHEAP_MINIALLOC</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_memheap_alloc(heap, newsize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入的記憶體位置為空，直接 malloc newsize 的大小並回傳</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get memory block header and get the size of memory block */</span></span><br><span class="line">header_ptr = (struct rt_memheap_item *)</span><br><span class="line">             ((<span class="keyword">rt_uint8_t</span> *)ptr - RT_MEMHEAP_SIZE);</span><br><span class="line">oldsize = MEMITEM_SIZE(header_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得傳入的 block 所屬的 header</li><li>一併計算這塊的大小</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* re-allocate memory */</span></span><br><span class="line"><span class="keyword">if</span> (newsize &gt; oldsize)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">void</span> *new_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">next_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock memheap */</span></span><br><span class="line">    result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line">    <span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        rt_set_errno(result);</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要增長記憶體，先取得 semaphore</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line">next_ptr = header_ptr-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* header_ptr should not be the tail */</span></span><br><span class="line">RT_ASSERT(next_ptr &gt; header_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check whether the following free space is enough to expand */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(next_ptr))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_int32_t</span> nextsize;</span><br><span class="line"></span><br><span class="line">    nextsize = MEMITEM_SIZE(next_ptr);</span><br><span class="line">    RT_ASSERT(next_ptr &gt; <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>先判斷下一顆可不可用</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Here is the ASCII art of the situation that we can make use of</span></span><br><span class="line"><span class="comment"> * the next free node without alloc/memcpy, |*| is the control</span></span><br><span class="line"><span class="comment"> * block:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      oldsize           free node</span></span><br><span class="line"><span class="comment"> * |*|-----------|*|----------------------|*|</span></span><br><span class="line"><span class="comment"> *         newsize          &gt;= minialloc</span></span><br><span class="line"><span class="comment"> * |*|----------------|*|-----------------|*|</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nextsize + oldsize &gt; newsize + RT_MEMHEAP_MINIALLOC)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* decrement the entire free size from the available bytes count. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - (newsize - oldsize);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;pool_size - heap-&gt;available_size &gt; heap-&gt;max_used_size)</span><br><span class="line">        heap-&gt;max_used_size = heap-&gt;pool_size - heap-&gt;available_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可用，而且下一顆足夠分割出一塊新的 block</li><li>更新 <code>available_size</code> 與 <code>max_used_size</code> (如果需要)</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove next_ptr from free list */</span></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"remove block: block[0x%08x], next_free 0x%08x, prev_free 0x%08x"</span>,</span><br><span class="line">              next_ptr,</span><br><span class="line">              next_ptr-&gt;next_free,</span><br><span class="line">              next_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">next_ptr-&gt;next_free-&gt;prev_free = next_ptr-&gt;prev_free;</span><br><span class="line">next_ptr-&gt;prev_free-&gt;next_free = next_ptr-&gt;next_free;</span><br><span class="line">next_ptr-&gt;next-&gt;prev = next_ptr-&gt;prev;</span><br><span class="line">next_ptr-&gt;prev-&gt;next = next_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 移除舊的下一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* build a new one on the right place */</span></span><br><span class="line">next_ptr = (struct rt_memheap_item *)((<span class="keyword">char</span> *)ptr + newsize);</span><br></pre></td></tr></tbody></table></figure><ul><li>重新定指新的下一顆（傳入的起始位址加上 <code>newsize</code>）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"new free block: block[0x%08x] nextm[0x%08x] prevm[0x%08x]"</span>,</span><br><span class="line">              next_ptr,</span><br><span class="line">              next_ptr-&gt;next,</span><br><span class="line">              next_ptr-&gt;prev));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">next_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">next_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line">next_ptr-&gt;prev          = header_ptr;</span><br><span class="line">next_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = next_ptr;</span><br><span class="line">header_ptr-&gt;next       = next_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入 block list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert next_ptr to free list */</span></span><br><span class="line">next_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">next_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = next_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = next_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new ptr: next_free 0x%08x, prev_free 0x%08x"</span>,</span><br><span class="line">                                next_ptr-&gt;next_free,</span><br><span class="line">                                next_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><p>插入 free list</p><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* release lock */</span></span><br><span class="line">        rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>釋放 semaphore 並回傳更新後的記憶體位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* re-allocate a memory block */</span></span><br><span class="line">    new_ptr = (<span class="keyword">void</span> *)rt_memheap_alloc(heap, newsize);</span><br><span class="line">    <span class="keyword">if</span> (new_ptr != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_memcpy(new_ptr, ptr, oldsize &lt; newsize ? oldsize : newsize);</span><br><span class="line">        rt_memheap_free(ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果下一顆不夠大，重新在原本的 heap 上要一塊 <code>newsize</code> 大的記憶體</li><li>成功的話還原資料，並釋放原本的記憶體</li><li>回傳新的記憶體位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* don't split when there is less than one node space left */</span></span><br><span class="line"><span class="keyword">if</span> (newsize + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC &gt;= oldsize)</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果是需要縮減，且縮減後剩下的大小不足以切成一塊</li><li>什麼事都不做，直接回傳原本的位址</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>可以分割的話先取得 semaphore</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* split the block. */</span></span><br><span class="line">new_ptr = (struct rt_memheap_item *)</span><br><span class="line">          (((<span class="keyword">rt_uint8_t</span> *)header_ptr) + newsize + RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>定址新的 block</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"split: block[0x%08x] nextm[0x%08x] prevm[0x%08x] to new[0x%08x]\n"</span>,</span><br><span class="line">              header_ptr,</span><br><span class="line">              header_ptr-&gt;next,</span><br><span class="line">              header_ptr-&gt;prev,</span><br><span class="line">              new_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark the new block as a memory block and freed. */</span></span><br><span class="line">new_ptr-&gt;magic = RT_MEMHEAP_MAGIC;</span><br><span class="line"><span class="comment">/* put the pool pointer into the new block. */</span></span><br><span class="line">new_ptr-&gt;pool_ptr = heap;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 magic 碼</li><li>設定所屬 heap</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* break down the block list */</span></span><br><span class="line">new_ptr-&gt;prev          = header_ptr;</span><br><span class="line">new_ptr-&gt;next          = header_ptr-&gt;next;</span><br><span class="line">header_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">header_ptr-&gt;next       = new_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>插入至 block list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the block can be merged with the next neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(new_ptr-&gt;next))</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">free_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge block with next neighbor. */</span></span><br><span class="line">    free_ptr = new_ptr-&gt;next;</span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size - MEMITEM_SIZE(free_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果新的 block 下一顆未使用，即可合併</li><li>先將可用大小減掉下一顆的大小，待會會加回來</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"merge: right node 0x%08x, next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">              header_ptr, header_ptr-&gt;next_free, header_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">free_ptr-&gt;next-&gt;prev = new_ptr;</span><br><span class="line">new_ptr-&gt;next   = free_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 block list 移除下一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove free ptr from free list */</span></span><br><span class="line">    free_ptr-&gt;next_free-&gt;prev_free = free_ptr-&gt;prev_free;</span><br><span class="line">    free_ptr-&gt;prev_free-&gt;next_free = free_ptr-&gt;next_free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>從 free list 移除下一顆，完成合併</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert the split block to free list */</span></span><br><span class="line">new_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">new_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">heap-&gt;free_list-&gt;next_free-&gt;prev_free = new_ptr;</span><br><span class="line">heap-&gt;free_list-&gt;next_free            = new_ptr;</span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"new free ptr: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                                new_ptr-&gt;next_free,</span><br><span class="line">                                new_ptr-&gt;prev_free));</span><br></pre></td></tr></tbody></table></figure><ul><li>無論下一顆是否可以合併，都把新的 block 插入 free list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* increment the available byte count.  */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + MEMITEM_SIZE(new_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return the old memory block */</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_realloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>更新可用大小，並釋放 semaphore</li><li>回傳更新後的記憶體位址</li></ul><hr><h3 id="Code-rt-calloc">Code: rt_calloc<a class="header-anchor" href="#Code-rt-calloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求多個連續的記憶體</td><td>第一塊的位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>count</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲要求的數量</td><td>欲要求的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_calloc</span><span class="params">(<span class="keyword">rt_size_t</span> count, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">rt_size_t</span> total_size;</span><br><span class="line"></span><br><span class="line">    total_size = count * size;</span><br><span class="line">    ptr = rt_malloc(total_size);</span><br><span class="line">    <span class="keyword">if</span> (ptr != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* clean memory */</span></span><br><span class="line">        rt_memset(ptr, <span class="number">0</span>, total_size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_calloc);</span><br></pre></td></tr></tbody></table></figure><ul><li>即要求一塊 <code>count * size</code> 大的記憶體</li></ul><hr><h2 id="釋放記憶體">釋放記憶體<a class="header-anchor" href="#釋放記憶體">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*rmem</code></th></tr></thead><tbody><tr><td>釋放一塊記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_free</span><span class="params">(<span class="keyword">void</span> *rmem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rt_memheap_free(rmem);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_memheap_free</code> 完成</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*ptr</code></th></tr></thead><tbody><tr><td>釋放一塊記憶體</td><td>void</td><td>欲釋放的記憶體</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_memheap_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_memheap_item</span> *<span class="title">header_ptr</span>, *<span class="title">new_ptr</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> insert_header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NULL check */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == RT_NULL) <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果傳入 NULL，什麼事都不用做</li><li><code>return</code> 退出副程式</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set initial status as OK */</span></span><br><span class="line">insert_header = <span class="number">1</span>;</span><br><span class="line">new_ptr       = RT_NULL;</span><br><span class="line">header_ptr    = (struct rt_memheap_item *)</span><br><span class="line">                ((<span class="keyword">rt_uint8_t</span> *)ptr - RT_MEMHEAP_SIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化一些參數，並找到傳入的 block 所屬的 header</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"free memory: memory[0x%08x], block[0x%08x]\n"</span>,</span><br><span class="line">                                ptr, header_ptr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check magic */</span></span><br><span class="line">RT_ASSERT((header_ptr-&gt;magic &amp; RT_MEMHEAP_MASK) == RT_MEMHEAP_MAGIC);</span><br><span class="line">RT_ASSERT(header_ptr-&gt;magic &amp; RT_MEMHEAP_USED);</span><br><span class="line"><span class="comment">/* check whether this block of memory has been over-written. */</span></span><br><span class="line">RT_ASSERT((header_ptr-&gt;next-&gt;magic &amp; RT_MEMHEAP_MASK) == RT_MEMHEAP_MAGIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get pool ptr */</span></span><br><span class="line">heap = header_ptr-&gt;pool_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>定址 heap</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br></pre></td><td class="code"><pre><span class="line">RT_ASSERT(heap);</span><br><span class="line">RT_ASSERT(rt_object_get_type(&amp;heap-&gt;parent) == RT_Object_Class_MemHeap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* lock memheap */</span></span><br><span class="line">result = rt_sem_take(&amp;(heap-&gt;lock), RT_WAITING_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (result != RT_EOK)</span><br><span class="line">{</span><br><span class="line">    rt_set_errno(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先取得 semaphore</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark the memory as available. */</span></span><br><span class="line">header_ptr-&gt;magic &amp;= ~RT_MEMHEAP_USED;</span><br><span class="line"><span class="comment">/* Adjust the available number of bytes. */</span></span><br><span class="line">heap-&gt;available_size = heap-&gt;available_size + MEMITEM_SIZE(header_ptr);</span><br></pre></td></tr></tbody></table></figure><ul><li>將使用中的標記清除，更新可用大小</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine if the block can be merged with the previous neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(header_ptr-&gt;prev))</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP, (<span class="string">"merge: left node 0x%08x\n"</span>,</span><br><span class="line">                                    header_ptr-&gt;prev));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjust the available number of bytes. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + RT_MEMHEAP_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以往前合併，更新可用大小（加一個 header 的大小）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* yes, merge block with previous neighbor. */</span></span><br><span class="line">(header_ptr-&gt;prev)-&gt;next = header_ptr-&gt;next;</span><br><span class="line">(header_ptr-&gt;next)-&gt;prev = header_ptr-&gt;prev;</span><br></pre></td></tr></tbody></table></figure><ul><li>從 block list 移除此 block</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* move header pointer to previous. */</span></span><br><span class="line">    header_ptr = header_ptr-&gt;prev;</span><br><span class="line">    <span class="comment">/* don't insert header to free list */</span></span><br><span class="line">    insert_header = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>重新定址 <code>header_ptr</code></li><li>設定 <code>insert_header</code> 為 0，表示待會不需要將此 block 插回 free list（現在此 block 是與前一塊合併的，已經在 free list 上了）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* determine if the block can be merged with the next neighbor. */</span></span><br><span class="line"><span class="keyword">if</span> (!RT_MEMHEAP_IS_USED(header_ptr-&gt;next))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* adjust the available number of bytes. */</span></span><br><span class="line">    heap-&gt;available_size = heap-&gt;available_size + RT_MEMHEAP_SIZE;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以往前合併，更新可用大小（加一個 header 的大小）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* merge block with next neighbor. */</span></span><br><span class="line">new_ptr = header_ptr-&gt;next;</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">             (<span class="string">"merge: right node 0x%08x, next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">              new_ptr, new_ptr-&gt;next_free, new_ptr-&gt;prev_free));</span><br><span class="line"></span><br><span class="line">new_ptr-&gt;next-&gt;prev = header_ptr;</span><br><span class="line">header_ptr-&gt;next    = new_ptr-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>定址下一塊，並從 block list 移除下一塊</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* remove new ptr from free list */</span></span><br><span class="line">    new_ptr-&gt;next_free-&gt;prev_free = new_ptr-&gt;prev_free;</span><br><span class="line">    new_ptr-&gt;prev_free-&gt;next_free = new_ptr-&gt;next_free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>一併從 free list 中移除</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (insert_header)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no left merge, insert to free list */</span></span><br><span class="line">    header_ptr-&gt;next_free = heap-&gt;free_list-&gt;next_free;</span><br><span class="line">    header_ptr-&gt;prev_free = heap-&gt;free_list;</span><br><span class="line">    heap-&gt;free_list-&gt;next_free-&gt;prev_free = header_ptr;</span><br><span class="line">    heap-&gt;free_list-&gt;next_free            = header_ptr;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_MEMHEAP,</span><br><span class="line">                 (<span class="string">"insert to free list: next_free 0x%08x, prev_free 0x%08x\n"</span>,</span><br><span class="line">                  header_ptr-&gt;next_free, header_ptr-&gt;prev_free));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要，插回 free list 上</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release lock */</span></span><br><span class="line">    rt_sem_release(&amp;(heap-&gt;lock));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_memheap_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後釋放 semaphore</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> 記憶體管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Memory Pool</title>
      <link href="/posts/RT-Thread/mem.html"/>
      <url>/posts/RT-Thread/mem.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>使用此管理方式： <code>#define RT_USING_MEMPOOL</code></p></blockquote><ul><li>分配記憶體的時間需固定，而且可確定（可預測）的</li><li>分配記憶體同時也要盡量避免碎片化，才能減少系統需重啟的次數</li><li>RT-Thread 使用了靜態與動態管理，其中動態又分為小記憶體管理，與大記憶體管理（SLAB)</li></ul><hr><ul><li>mempool 的管理方法（靜態管理）:<ul><li>從 RAM 中要一塊記憶體</li><li>將此記憶體切成<strong>固定大小</strong>的區塊</li><li>以間接定址的方式接起來，形成 free list</li></ul></li></ul><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> redef.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MEMPOOL</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base structure of Memory pool object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> <span class="title">parent</span>;</span>                            <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>            *start_address;                     <span class="comment">/**&lt; memory pool start */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span>        size;                              <span class="comment">/**&lt; size of memory pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span>        block_size;                        <span class="comment">/**&lt; size of memory blocks */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>      *block_list;                        <span class="comment">/**&lt; memory blocks list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span>        block_total_count;                 <span class="comment">/**&lt; numbers of memory block */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span>        block_free_count;                  <span class="comment">/**&lt; numbers of free memory block */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>        suspend_thread;                    <span class="comment">/**&lt; threads pended on this resource */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span>        suspend_thread_count;              <span class="comment">/**&lt; numbers of thread pended on this resource */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span> *<span class="title">rt_mp_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>我們從文本的圖來解釋結構：<br><div class="img-item" data-src="https://i.imgur.com/9KWhnUY.png" data-sub-html=".caption"><img src="https://i.imgur.com/9KWhnUY.png" alt="memory pool example" title="memory pool example"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">memory pool example</span></div></div></p><ul><li><code>start_address</code> 為每個 mempool 的起始位置，此圖為例則為<em>mempool 1</em> 的起始位置</li><li><code>size</code> 為 mempool 的大小，此圖為例則為<em>mempool 1</em> 的大小（灰色區塊）<br><br></li><li><code>block_size</code> 為由 mempool 產出的空閒鏈表中，每一塊的大小，以<em>mempool 1</em> 為例，則為 32k</li><li><code>block_list</code> 為空閒鏈表，此圖為例則為<em>mempool 1</em> 旁邊的鏈結<br><br></li><li><code>block_total_count</code> 為空閒鏈表創建時的總塊數，以<em>mempool 1</em> 為例，則為 128</li><li><code>block_free_count</code> 為為空閒鏈表現在可用的總塊數<br><br></li><li><code>suspend_thread</code> 則為等待隊伍，此圖為例為最右邊的鏈結</li><li><code>suspend_thread_count</code> 則為等待隊伍的總排隊數，以此圖為例為 3</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> mempool.c</p></div><h2 id="建立-memory-pool">建立 memory pool<a class="header-anchor" href="#建立-memory-pool">#</a></h2><ul><li>建立 memory pool 的方法一樣也可分為靜態的與動態的</li><li>這裡的動態是指從原先記憶體 heap 的區塊拿取記憶體</li></ul><h3 id="動態">動態<a class="header-anchor" href="#動態">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mempool（使用 heap）</td><td>mempool</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>block_count</code></th><th><code>block_size</code></th></tr></thead><tbody><tr><td>名字</td><td>要切割的總塊數</td><td>一塊 free block 的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a mempool object and allocate the memory pool from</span></span><br><span class="line"><span class="comment"> * heap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of memory pool</span></span><br><span class="line"><span class="comment"> * @param block_count the count of blocks in memory pool</span></span><br><span class="line"><span class="comment"> * @param block_size the size for each block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created mempool object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mp_t</span> rt_mp_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   block_count,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   block_size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *block_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);</span><br><span class="line">    <span class="comment">/* allocate object failed */</span></span><br><span class="line">    <span class="keyword">if</span> (mp == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先一樣先從 heap 取一塊記憶體作為 mempool 使用</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize memory pool */</span></span><br><span class="line">block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);</span><br><span class="line">mp-&gt;block_size = block_size;</span><br><span class="line">mp-&gt;size       = (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)) * block_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate memory */</span></span><br><span class="line">mp-&gt;start_address = rt_malloc((block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)) *</span><br><span class="line">                              block_count);</span><br><span class="line"><span class="keyword">if</span> (mp-&gt;start_address == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no memory, delete memory pool object */</span></span><br><span class="line">    rt_object_delete(&amp;(mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著對齊 <code>block_size</code> 後填入結構中，一併計算 mempool 的大小</li><li>並從 heap 中取出一塊待會做成 free list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">mp-&gt;block_total_count = block_count;</span><br><span class="line">mp-&gt;block_free_count  = mp-&gt;block_total_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize suspended thread list */</span></span><br><span class="line">rt_list_init(&amp;(mp-&gt;suspend_thread));</span><br><span class="line">mp-&gt;suspend_thread_count = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>填入總數，建立等待鏈</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize free block list */</span></span><br><span class="line">    block_ptr = (<span class="keyword">rt_uint8_t</span> *)mp-&gt;start_address;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; mp-&gt;block_total_count; offset ++)</span><br><span class="line">    {</span><br><span class="line">        *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + offset * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)))</span><br><span class="line">            = block_ptr + (offset + <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + (offset - <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)))</span><br><span class="line">        = RT_NULL;</span><br><span class="line"></span><br><span class="line">    mp-&gt;block_list = block_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後製作 free list：<ul><li>一個 free block 分成兩部分：前 8-bit (rt_uint8_t *）與一個 block_size</li><li>前 8-bit 存放下一個 free block 的位置</li></ul></li></ul><hr><h3 id="靜態">靜態<a class="header-anchor" href="#靜態">#</a></h3><ul><li>多傳了兩個參數 <code>size</code> 與 <code>*start</code></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mempool</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*mp</code></th><th><code>*name</code></th><th><code>*start</code></th></tr></thead><tbody><tr><td>結構位址</td><td>名字</td><td>所要使用的記憶體位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>size</code></th><th><code>block_size</code></th></tr></thead><tbody><tr><td>mempool 大小</td><td>一塊 free block 的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a memory pool object, normally which is used</span></span><br><span class="line"><span class="comment"> * for static object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> * @param name the name of memory pool</span></span><br><span class="line"><span class="comment"> * @param start the star address of memory pool</span></span><br><span class="line"><span class="comment"> * @param size the total size of memory pool</span></span><br><span class="line"><span class="comment"> * @param block_size the size for each block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mp_init(struct rt_mempool *mp,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>        *name,</span><br><span class="line">                    <span class="keyword">void</span>              *start,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>          size,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>          block_size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *block_ptr;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mp != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize object */</span></span><br><span class="line">    rt_object_init(&amp;(mp-&gt;parent), RT_Object_Class_MemPool, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize memory pool */</span></span><br><span class="line">    mp-&gt;start_address = start;</span><br><span class="line">    mp-&gt;size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* align the block size */</span></span><br><span class="line">    block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);</span><br><span class="line">    mp-&gt;block_size = block_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>可直接用 <code>rt_object_init</code> 初始化物件</li><li>同時用 <code>RT_ALIGN_DOWN</code> 對齊 size</li><li>填入 <code>block_size</code></li></ul><p><code>RT_ALIGN_DOWN</code> v.s. <code>RT_ALIGN</code></p><ul><li>當傳入 (13,4) 時：</li><li><code>RT_ALIGN_DOWN</code> 回傳 12，也就是在不超過 13 中，4 的倍數中最大的</li><li><code>RT_ALIGN</code> 回傳 16，也就是在大於等於 13 中，4 的倍數中最小的</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* align to align size byte */</span></span><br><span class="line">mp-&gt;block_total_count = mp-&gt;size / (mp-&gt;block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">mp-&gt;block_free_count  = mp-&gt;block_total_count;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著手動算出 block 的總數</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize suspended thread list */</span></span><br><span class="line">    rt_list_init(&amp;(mp-&gt;suspend_thread));</span><br><span class="line">    mp-&gt;suspend_thread_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize free block list */</span></span><br><span class="line">    block_ptr = (<span class="keyword">rt_uint8_t</span> *)mp-&gt;start_address;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; mp-&gt;block_total_count; offset ++)</span><br><span class="line">    {</span><br><span class="line">        *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + offset * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *))) =</span><br><span class="line">            (<span class="keyword">rt_uint8_t</span> *)(block_ptr + (offset + <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">rt_uint8_t</span> **)(block_ptr + (offset - <span class="number">1</span>) * (block_size + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *))) =</span><br><span class="line">        RT_NULL;</span><br><span class="line"></span><br><span class="line">    mp-&gt;block_list = block_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>其他的動作皆相同</li></ul><hr><h2 id="刪除-memory-pool">刪除 memory pool<a class="header-anchor" href="#刪除-memory-pool">#</a></h2><h3 id="動態-v2">動態<a class="header-anchor" href="#動態-v2">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>mp</code></th></tr></thead><tbody><tr><td>刪除 mempool（使用 heap）</td><td><code>RT_EOK</code></td><td>欲刪除的 mempool</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a memory pool and release the object memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mp_delete(<span class="keyword">rt_mp_t</span> mp)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mp != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mp-&gt;parent) == RT_Object_Class_MemPool);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mp-&gt;parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wake up all suspended threads */</span></span><br><span class="line">    <span class="keyword">while</span> (!rt_list_isempty(&amp;(mp-&gt;suspend_thread)))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* disable interrupt */</span></span><br><span class="line">        temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get next suspend thread */</span></span><br><span class="line">        thread = rt_list_entry(mp-&gt;suspend_thread.next, struct rt_thread, tlist);</span><br><span class="line">        <span class="comment">/* set error code to RT_ERROR */</span></span><br><span class="line">        thread-&gt;error = -RT_ERROR;</span><br></pre></td></tr></tbody></table></figure><ul><li>當要把 mempool 刪除前，先將正在等待分配記憶體的 thread 一個一個叫醒</li><li>叫醒前，先將錯誤碼改成 <code>ERROR</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * resume thread</span></span><br><span class="line"><span class="comment"> * In rt_thread_resume function, it will remove current thread from</span></span><br><span class="line"><span class="comment"> * suspend list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rt_thread_resume(thread);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著透過 <code>rt_thread_resume</code> 叫醒 thread</li></ul><p>從等待鏈上移出的動作，在 <code>rt_thread_resume</code> 中會實現。<br>（code in <a href="/2018/11/19/rt-thread-thread#%E6%9A%AB%E5%81%9C%E3%80%81%E5%BE%A9%E5%8E%9F-thread">RT-Thread Thread</a>）</p><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* decrease suspended thread count */</span></span><br><span class="line">    mp-&gt;suspend_thread_count --;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>suspend_thread_count</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release allocated room */</span></span><br><span class="line">    rt_free(mp-&gt;start_address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach object */</span></span><br><span class="line">    rt_object_delete(&amp;(mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>叫醒完，free 掉建立 mempool 時所要的記憶體</li><li>再透過 <code>rt_object_delete</code> 刪除</li></ul><hr><h3 id="靜態-v2">靜態<a class="header-anchor" href="#靜態-v2">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*mp</code></th></tr></thead><tbody><tr><td>刪除 mempool</td><td><code>RT_EOK</code></td><td>欲刪除的 mempool</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a memory pool from system object management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mp_detach(struct rt_mempool *mp)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mp != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mp-&gt;parent) == RT_Object_Class_MemPool);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wake up all suspended threads */</span></span><br><span class="line">    <span class="keyword">while</span> (!rt_list_isempty(&amp;(mp-&gt;suspend_thread)))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* disable interrupt */</span></span><br><span class="line">        temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get next suspend thread */</span></span><br><span class="line">        thread = rt_list_entry(mp-&gt;suspend_thread.next, struct rt_thread, tlist);</span><br><span class="line">        <span class="comment">/* set error code to RT_ERROR */</span></span><br><span class="line">        thread-&gt;error = -RT_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * resume thread</span></span><br><span class="line"><span class="comment">         * In rt_thread_resume function, it will remove current thread from</span></span><br><span class="line"><span class="comment">         * suspend list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rt_thread_resume(thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decrease suspended thread count */</span></span><br><span class="line">        mp-&gt;suspend_thread_count --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach object */</span></span><br><span class="line">    rt_object_detach(&amp;(mp-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果是靜態的，就不需要 free</li></ul><hr><h2 id="Code-allocate">Code: allocate<a class="header-anchor" href="#Code-allocate">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>分配記憶體</td><td>一塊 free block</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mp</code></th><th><code>time</code></th></tr></thead><tbody><tr><td>mempool</td><td>等待時間</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will allocate a block from memory pool</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mp the memory pool object</span></span><br><span class="line"><span class="comment"> * @param time the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the allocated memory block or RT_NULL on allocated failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_mp_alloc</span><span class="params">(<span class="keyword">rt_mp_t</span> mp, <span class="keyword">rt_int32_t</span> time)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *block_ptr;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> before_sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mp-&gt;block_free_count == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* memory block is unavailable. */</span></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">            rt_set_errno(-RT_ETIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> RT_NULL;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果目前無法取得記憶體，且等待時間為 0，回傳 NULL，並設置錯誤碼為 TIMEOUT</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* need suspend thread */</span></span><br><span class="line">rt_thread_suspend(thread);</span><br><span class="line">rt_list_insert_after(&amp;(mp-&gt;suspend_thread), &amp;(thread-&gt;tlist));</span><br><span class="line">mp-&gt;suspend_thread_count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    before_sleep = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;time);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要等待，啟動一個 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do a schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>並做一次調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        time -= rt_tick_get() - before_sleep;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            time = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 time 值</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* memory block is available. decrease the free block counter */</span></span><br><span class="line">mp-&gt;block_free_count--;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果可以要記憶體，更新 <code>block_free_count</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get block from block list */</span></span><br><span class="line">block_ptr = mp-&gt;block_list;</span><br><span class="line">RT_ASSERT(block_ptr != RT_NULL);</span><br></pre></td></tr></tbody></table></figure><ul><li>取得第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the next free node. */</span></span><br><span class="line">mp-&gt;block_list = *(<span class="keyword">rt_uint8_t</span> **)block_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>並將 free list 往後一顆</li><li><code>block_list</code> 是使用間接定址，前 8-bit 是下一顆的位置</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* point to memory pool */</span></span><br><span class="line">*(<span class="keyword">rt_uint8_t</span> **)block_ptr = (<span class="keyword">rt_uint8_t</span> *)mp;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著將前 8-bit 指向原來的 mempool</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,</span><br><span class="line">                        (mp, (<span class="keyword">rt_uint8_t</span> *)(block_ptr + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">rt_uint8_t</span> *)(block_ptr + <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_alloc);</span><br></pre></td></tr></tbody></table></figure><ul><li><p>最後回傳取得的 free block</p></li><li><p>注意這裡回傳的是 <code>block_ptr + 8</code>，也就是真正可以使用的位址</p></li><li><p>如果要尋找這個 block 所屬的 mempool 則需要 -8。</p></li></ul><hr><h2 id="Code-free">Code: free<a class="header-anchor" href="#Code-free">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*block</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>所要釋放的記憶體塊</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release a memory block</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param block the address of memory block to be released</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_mp_free</span><span class="params">(<span class="keyword">void</span> *block)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> **block_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mempool</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the control block of pool which the block belongs to */</span></span><br><span class="line">    block_ptr = (<span class="keyword">rt_uint8_t</span> **)((<span class="keyword">rt_uint8_t</span> *)block - <span class="keyword">sizeof</span>(<span class="keyword">rt_uint8_t</span> *));</span><br><span class="line">    mp        = (struct rt_mempool *)*block_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先取得所屬的 mempool（-8）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* increase the free block count */</span></span><br><span class="line">mp-&gt;block_free_count ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* link the block into the block list */</span></span><br><span class="line">*block_ptr = mp-&gt;block_list;</span><br><span class="line">mp-&gt;block_list = (<span class="keyword">rt_uint8_t</span> *)block_ptr;</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 <code>block_free_count</code></li><li>接著定址到 free list，重新指定 block list</li><li>也就是將此 block 插到第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mp-&gt;suspend_thread_count &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get the suspended thread */</span></span><br><span class="line">        thread = rt_list_entry(mp-&gt;suspend_thread.next,</span><br><span class="line">                               struct rt_thread,</span><br><span class="line">                               tlist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set error */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* resume thread */</span></span><br><span class="line">        rt_thread_resume(thread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decrease suspended thread count */</span></span><br><span class="line">        mp-&gt;suspend_thread_count --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* do a schedule */</span></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mp_free);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等資源，叫醒他，並做一次調度</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> 記憶體管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - IPC Communicate</title>
      <link href="/posts/RT-Thread/ipc-2.html"/>
      <url>/posts/RT-Thread/ipc-2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Mail-Box">Mail Box<a class="header-anchor" href="#Mail-Box">#</a></h2><ul><li>類似於 pipe，主要用來傳輸資料</li><li>每一封郵件大小為 4 bytes（即 32 位元）</li></ul><h3 id="結構">結構<a class="header-anchor" href="#結構">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MAILBOX</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mailbox structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>         *msg_pool;                      <span class="comment">/**&lt; start address of message buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          size;                          <span class="comment">/**&lt; size of message pool */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          entry;                         <span class="comment">/**&lt; index of messages in msg_pool */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          in_offset;                     <span class="comment">/**&lt; input offset of the message buffer */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          out_offset;                    <span class="comment">/**&lt; output offset of the message buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>            suspend_sender_thread;         <span class="comment">/**&lt; sender thread suspended on this mailbox */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span> *<span class="title">rt_mailbox_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>msg_pool</code> 指向郵件堆的起點，<code>entry</code> 紀錄總郵件的數量</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立-mail-box">建立 mail box<a class="header-anchor" href="#建立-mail-box">#</a></h3><h4 id="動態記憶體管理">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mail box</td><td>mail box</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>size</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>mail box 大小</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a mailbox object from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of mailbox</span></span><br><span class="line"><span class="comment"> * @param size the size of mailbox</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mailbox</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created mailbox, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mailbox_t</span> rt_mb_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_size_t</span> size, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_mailbox_t</span> mb;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mb = (<span class="keyword">rt_mailbox_t</span>)rt_object_allocate(RT_Object_Class_MailBox, name);</span><br><span class="line">    <span class="keyword">if</span> (mb == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mb;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先 allocate 一塊給 mailbox</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set parent */</span></span><br><span class="line">mb-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init ipc object */</span></span><br><span class="line">rt_ipc_object_init(&amp;(mb-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>填入 flag 及初始化</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init mailbox */</span></span><br><span class="line">mb-&gt;size     = size;</span><br><span class="line">mb-&gt;msg_pool = RT_KERNEL_MALLOC(mb-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">rt_uint32_t</span>));</span><br><span class="line"><span class="keyword">if</span> (mb-&gt;msg_pool == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* delete mailbox object */</span></span><br><span class="line">    rt_object_delete(&amp;(mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因使用動態記憶體的緣故，需 allocate 一塊給郵件堆</li><li>大小為一封一件的大小 * size</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br></pre></td><td class="code"><pre><span class="line">    mb-&gt;entry      = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;in_offset  = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;out_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init an additional list of sender suspend thread */</span></span><br><span class="line">    rt_list_init(&amp;(mb-&gt;suspend_sender_thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mb;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化值及等待鏈</li></ul><hr><h4 id="靜態記憶體管理">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 mail box</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mb</code></th><th><code>*name</code></th><th><code>*msgpool</code></th><th><code>size</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>mail box 本體</td><td>名字</td><td>存放郵件的地方</td><td>mail box 大小</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a mailbox and put it under control of resource</span></span><br><span class="line"><span class="comment"> * management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param name the name of mailbox</span></span><br><span class="line"><span class="comment"> * @param msgpool the begin address of buffer to save received mail</span></span><br><span class="line"><span class="comment"> * @param size the size of mailbox</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mailbox</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_init(<span class="keyword">rt_mailbox_t</span> mb,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>  *name,</span><br><span class="line">                    <span class="keyword">void</span>        *msgpool,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>    size,</span><br><span class="line">                    <span class="keyword">rt_uint8_t</span>   flag)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(mb-&gt;parent.parent), RT_Object_Class_MailBox, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent flag */</span></span><br><span class="line">    mb-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mb-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡就不需要 allocate，可直接初始化來使用</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* init mailbox */</span></span><br><span class="line">    mb-&gt;msg_pool   = msgpool;</span><br><span class="line">    mb-&gt;size       = size;</span><br><span class="line">    mb-&gt;entry      = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;in_offset  = <span class="number">0</span>;</span><br><span class="line">    mb-&gt;out_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init an additional list of sender suspend thread */</span></span><br><span class="line">    rt_list_init(&amp;(mb-&gt;suspend_sender_thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣，郵件堆可直接拿來用，初始化值及等待鏈</li></ul><hr><h3 id="刪除-mail-box">刪除 mail box<a class="header-anchor" href="#刪除-mail-box">#</a></h3><h4 id="動態記憶體管理-v2">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>mb</code></th></tr></thead><tbody><tr><td>刪除 mail box</td><td><code>RT_EOK</code></td><td>欲刪除的 mail box</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a mailbox object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_delete(<span class="keyword">rt_mailbox_t</span> mb)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mb-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* also resume all mailbox private suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;suspend_sender_thread));</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將正在等待郵件的，與正在等待傳送的 thread 叫醒</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* free mailbox pool */</span></span><br><span class="line">    RT_KERNEL_FREE(mb-&gt;msg_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete mailbox object */</span></span><br><span class="line">    rt_object_delete(&amp;(mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>歸還郵件堆，最後刪除 mail box</li></ul><hr><h4 id="靜態記憶體管理-v2">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>mb</code></th></tr></thead><tbody><tr><td>刪除 mail box</td><td><code>RT_EOK</code></td><td>欲刪除的 mail box</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a mailbox from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_detach(<span class="keyword">rt_mailbox_t</span> mb)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;parent.suspend_thread));</span><br><span class="line">    <span class="comment">/* also resume all mailbox private suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mb-&gt;suspend_sender_thread));</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將正在等待郵件的，與正在等待傳送的 thread 叫醒</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* detach mailbox object */</span></span><br><span class="line">    rt_object_detach(&amp;(mb-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後刪除 mail box（使用 <code>detach</code>）</li></ul><hr><h3 id="傳送郵件">傳送郵件<a class="header-anchor" href="#傳送郵件">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送郵件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mb</code></th><th><code>value</code></th><th><code>timeout</code></th></tr></thead><tbody><tr><td>欲傳送的 mailbox</td><td>郵件內容</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send a mail to mailbox object. If the mailbox is full,</span></span><br><span class="line"><span class="comment"> * current thread will be suspended until timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param value the mail</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_send_wait(<span class="keyword">rt_mailbox_t</span> mb,</span><br><span class="line">                         <span class="keyword">rt_uint32_t</span>  value,</span><br><span class="line">                         <span class="keyword">rt_int32_t</span>   timeout)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for non-blocking call */</span></span><br><span class="line">    <span class="keyword">if</span> (mb-&gt;entry == mb-&gt;size &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox is full */</span></span><br><span class="line">    <span class="keyword">while</span> (mb-&gt;entry == mb-&gt;size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset error number in thread */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no waiting, return timeout */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 mail box 滿了，且不等待 (<code>timeout==0</code>)，回傳 <code>FULL</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mb-&gt;suspend_sender_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mb-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    tick_delta = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mb_send_wait: start timer of thread:%s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若要等待，將 thread 掛上等待鏈，啟動一個 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* re-schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>再做一次調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume from suspend state */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* return error */</span></span><br><span class="line">        <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's not waiting forever and then re-calculate timeout tick */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        tick_delta = rt_tick_get() - tick_delta;</span><br><span class="line">        timeout -= tick_delta;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如跳回來，重新計算 <code>timeout</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set ptr */</span></span><br><span class="line">mb-&gt;msg_pool[mb-&gt;in_offset] = value;</span><br><span class="line"><span class="comment">/* increase input offset */</span></span><br><span class="line">++ mb-&gt;in_offset;</span><br><span class="line"><span class="keyword">if</span> (mb-&gt;in_offset &gt;= mb-&gt;size)</span><br><span class="line">    mb-&gt;in_offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* increase message entry */</span></span><br><span class="line">mb-&gt;entry ++;</span><br></pre></td></tr></tbody></table></figure><ul><li>若可以寫入，將資料寫入，同時更新 <code>offset</code> 及 <code>entry</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;mb-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mb-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_send_wait);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待寄信，叫醒他，做一次調度</li></ul><hr><ul><li>若是不想等待，可以使用 <code>rt_mb_send</code></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送郵件（不等待）</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mb</code></th><th><code>value</code></th></tr></thead><tbody><tr><td>欲傳送的 mailbox</td><td>郵件內容</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send a mail to mailbox object, if there are threads</span></span><br><span class="line"><span class="comment"> * suspended on mailbox object, it will be waked up. This function will return</span></span><br><span class="line"><span class="comment"> * immediately, if you want blocking send, use rt_mb_send_wait instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param value the mail</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_send(<span class="keyword">rt_mailbox_t</span> mb, <span class="keyword">rt_uint32_t</span> value)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_mb_send_wait(mb, value, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_send);</span><br></pre></td></tr></tbody></table></figure><ul><li>即 <code>timeout == 0</code></li></ul><hr><h3 id="接受郵件">接受郵件<a class="header-anchor" href="#接受郵件">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>接受郵件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mb</code></th><th><code>*value</code></th><th><code>timeout</code></th></tr></thead><tbody><tr><td>欲收信的 mailbox</td><td>郵件內容</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will receive a mail from mailbox object, if there is no mail</span></span><br><span class="line"><span class="comment"> * in mailbox object, the thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mb the mailbox object</span></span><br><span class="line"><span class="comment"> * @param value the received mail will be saved in</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mb_recv(<span class="keyword">rt_mailbox_t</span> mb, <span class="keyword">rt_uint32_t</span> *value, <span class="keyword">rt_int32_t</span> timeout)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mb != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mb-&gt;parent.parent) == RT_Object_Class_MailBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for non-blocking call */</span></span><br><span class="line">    <span class="keyword">if</span> (mb-&gt;entry == <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mailbox is empty */</span></span><br><span class="line">    <span class="keyword">while</span> (mb-&gt;entry == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* reset error number in thread */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no waiting, return timeout */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 mail box 沒東西，且不等待，回傳 <code>TIMEOUT</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mb-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mb-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    tick_delta = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mb_recv: start timer of thread:%s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若要等待，將 thread 掛上等待鏈，啟動一個 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* re-schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>再做一次調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume from suspend state */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* return error */</span></span><br><span class="line">        <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's not waiting forever and then re-calculate timeout tick */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        tick_delta = rt_tick_get() - tick_delta;</span><br><span class="line">        timeout -= tick_delta;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如跳回來，重新計算 <code>timeout</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fill ptr */</span></span><br><span class="line">*value = mb-&gt;msg_pool[mb-&gt;out_offset];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* increase output offset */</span></span><br><span class="line">++ mb-&gt;out_offset;</span><br><span class="line"><span class="keyword">if</span> (mb-&gt;out_offset &gt;= mb-&gt;size)</span><br><span class="line">    mb-&gt;out_offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* decrease message entry */</span></span><br><span class="line">mb-&gt;entry --;</span><br></pre></td></tr></tbody></table></figure><ul><li>若可以讀取，將資料寫入，同時更新 <code>offset</code> 及 <code>entry</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;(mb-&gt;suspend_sender_thread)))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mb-&gt;suspend_sender_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mb-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mb_recv);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待收信，叫醒他，做一次調度</li></ul><hr><h2 id="Message-Queue">Message Queue<a class="header-anchor" href="#Message-Queue">#</a></h2><ul><li>特性：可接受不固定長度的訊息</li></ul><h3 id="結構-v2">結構<a class="header-anchor" href="#結構-v2">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MESSAGEQUEUE</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * message queue structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                *msg_pool;                      <span class="comment">/**&lt; start address of message queue */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          msg_size;                      <span class="comment">/**&lt; message size of each message */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          max_msgs;                      <span class="comment">/**&lt; max number of messages */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          entry;                         <span class="comment">/**&lt; index of messages in the queue */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                *msg_queue_head;                <span class="comment">/**&lt; list head */</span></span><br><span class="line">    <span class="keyword">void</span>                *msg_queue_tail;                <span class="comment">/**&lt; list tail */</span></span><br><span class="line">    <span class="keyword">void</span>                *msg_queue_free;                <span class="comment">/**&lt; pointer indicated the free node of queue */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span> *<span class="title">rt_mq_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立-message-queue">建立 message queue<a class="header-anchor" href="#建立-message-queue">#</a></h3><h4 id="動態記憶體管理-v3">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v3">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 message queue</td><td>message queue</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>msg_size</code></th><th><code>max_msgs</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>一封訊息的大小</td><td>訊息數上限</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a message queue object from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of message queue</span></span><br><span class="line"><span class="comment"> * @param msg_size the size of message</span></span><br><span class="line"><span class="comment"> * @param max_msgs the maximum number of message in queue</span></span><br><span class="line"><span class="comment"> * @param flag the flag of message queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created message queue, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mq_t</span> rt_mq_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   msg_size,</span><br><span class="line">                     <span class="keyword">rt_size_t</span>   max_msgs,</span><br><span class="line">                     <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span> *<span class="title">mq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mq = (<span class="keyword">rt_mq_t</span>)rt_object_allocate(RT_Object_Class_MessageQueue, name);</span><br><span class="line">    <span class="keyword">if</span> (mq == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    mq-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mq-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>首先要一塊物件給 message queue，並同時填入 flag 及初始化</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init message queue */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get correct message size */</span></span><br><span class="line">mq-&gt;msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);</span><br><span class="line">mq-&gt;max_msgs = max_msgs;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定訊息的大小，與訊息數量的上限</li></ul><div class="alert alert-info"><p><code>RT_ALGIN</code> 目的在對齊訊息的大小，根據不同板子所定義不同的 <code>RT_ALIGN_SIZE</code> 會有所差別<br><br><code>#define RT_ALIGN(size, align)           (((size) + (align) - 1) &amp; ~((align) - 1))</code></p><ul><li>如傳進來的是 <code>RT_ALGIN(7,8)</code> 則結果是 8</li><li>如傳進來的是 <code>RT_ALGIN(13,4)</code> 則結果是 16</li><li>即結果為大於後值的<strong>最小倍數</strong></li></ul></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate message pool */</span></span><br><span class="line">mq-&gt;msg_pool = RT_KERNEL_MALLOC((mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message)) * mq-&gt;max_msgs);</span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_pool == RT_NULL)</span><br><span class="line">{</span><br><span class="line">    rt_mq_delete(mq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著需 allocate 適當的記憶體存放訊息</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init message list */</span></span><br><span class="line">mq-&gt;msg_queue_head = RT_NULL;</span><br><span class="line">mq-&gt;msg_queue_tail = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init message empty list */</span></span><br><span class="line">mq-&gt;msg_queue_free = RT_NULL;</span><br><span class="line"><span class="keyword">for</span> (temp = <span class="number">0</span>; temp &lt; mq-&gt;max_msgs; temp ++)</span><br><span class="line">{</span><br><span class="line">    head = (struct rt_mq_message *)((<span class="keyword">rt_uint8_t</span> *)mq-&gt;msg_pool +</span><br><span class="line">                                    temp * (mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message)));</span><br><span class="line">    head-&gt;next = mq-&gt;msg_queue_free;</span><br><span class="line">    mq-&gt;msg_queue_free = head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先將頭尾設為空，再一塊一塊的將 <code>msg_pool</code> 插在 free list 的第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* the initial entry is zero */</span></span><br><span class="line">    mq-&gt;entry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mq;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後設定 <code>entry</code> 為 0</li></ul><hr><h4 id="靜態記憶體管理-v3">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v3">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 message queue</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mq</code></th><th><code>*name</code></th><th><code>*msgpool</code></th></tr></thead><tbody><tr><td>message queue 本體</td><td>名字</td><td>存放訊息的位址</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>msg_size</code></th><th><code>pool_size</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>一封訊息的大小</td><td>存放訊息的大小</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a message queue and put it under control of</span></span><br><span class="line"><span class="comment"> * resource management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message object</span></span><br><span class="line"><span class="comment"> * @param name the name of message queue</span></span><br><span class="line"><span class="comment"> * @param msgpool the beginning address of buffer to save messages</span></span><br><span class="line"><span class="comment"> * @param msg_size the maximum size of message</span></span><br><span class="line"><span class="comment"> * @param pool_size the size of buffer to save messages</span></span><br><span class="line"><span class="comment"> * @param flag the flag of message queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_init(<span class="keyword">rt_mq_t</span>     mq,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                    <span class="keyword">void</span>       *msgpool,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>   msg_size,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>   pool_size,</span><br><span class="line">                    <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(mq-&gt;parent.parent), RT_Object_Class_MessageQueue, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent flag */</span></span><br><span class="line">    mq-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mq-&gt;parent));</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡就不需要去要一塊物件，直接拿來用即可</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* set messasge pool */</span></span><br><span class="line">    mq-&gt;msg_pool = msgpool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get correct message size */</span></span><br><span class="line">    mq-&gt;msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);</span><br><span class="line">    mq-&gt;max_msgs = pool_size / (mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init message list */</span></span><br><span class="line">    mq-&gt;msg_queue_head = RT_NULL;</span><br><span class="line">    mq-&gt;msg_queue_tail = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init message empty list */</span></span><br><span class="line">    mq-&gt;msg_queue_free = RT_NULL;</span><br><span class="line">    <span class="keyword">for</span> (temp = <span class="number">0</span>; temp &lt; mq-&gt;max_msgs; temp ++)</span><br><span class="line">    {</span><br><span class="line">        head = (struct rt_mq_message *)((<span class="keyword">rt_uint8_t</span> *)mq-&gt;msg_pool +</span><br><span class="line">                                        temp * (mq-&gt;msg_size + <span class="keyword">sizeof</span>(struct rt_mq_message)));</span><br><span class="line">        head-&gt;next = mq-&gt;msg_queue_free;</span><br><span class="line">        mq-&gt;msg_queue_free = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the initial entry is zero */</span></span><br><span class="line">    mq-&gt;entry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>其餘的動作皆與上面相同</li></ul><hr><h3 id="刪除-message-queue">刪除 message queue<a class="header-anchor" href="#刪除-message-queue">#</a></h3><h4 id="動態記憶體管理-v4">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v4">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>mq</code></th></tr></thead><tbody><tr><td>刪除 message queue</td><td><code>RT_EOK</code></td><td>欲刪除的 message queue</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a message queue object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_delete(<span class="keyword">rt_mq_t</span> mq)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mq-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mq-&gt;parent.suspend_thread));</span><br></pre></td></tr></tbody></table></figure><ul><li>先把正在等待收訊息的 thread 叫醒</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* free message queue pool */</span></span><br><span class="line">    RT_KERNEL_FREE(mq-&gt;msg_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete message queue object */</span></span><br><span class="line">    rt_object_delete(&amp;(mq-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著 free <code>msg_pool</code>，並刪除物件</li></ul><hr><h4 id="靜態記憶體管理-v4">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v4">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>mq</code></th></tr></thead><tbody><tr><td>刪除 message queue</td><td><code>RT_EOK</code></td><td>欲刪除的 message queue</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a message queue object from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_detach(<span class="keyword">rt_mq_t</span> mq)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mq-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;mq-&gt;parent.suspend_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach message queue object */</span></span><br><span class="line">    rt_object_detach(&amp;(mq-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡的 <code>msg_pool</code> 就不需要 free</li></ul><hr><h3 id="傳送訊息">傳送訊息<a class="header-anchor" href="#傳送訊息">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送訊息</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mq</code></th><th><code>*buffer</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲傳送的 message queue</td><td>訊息資料</td><td>訊息大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send a message to message queue object, if there are</span></span><br><span class="line"><span class="comment"> * threads suspended on message queue object, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> * @param buffer the message</span></span><br><span class="line"><span class="comment"> * @param size the size of buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_send(<span class="keyword">rt_mq_t</span> mq, <span class="keyword">void</span> *buffer, <span class="keyword">rt_size_t</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(buffer != RT_NULL);</span><br><span class="line">    RT_ASSERT(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* greater than one message size */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; mq-&gt;msg_size)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a free list, there must be an empty item */</span></span><br><span class="line">    msg = (struct rt_mq_message *)mq-&gt;msg_queue_free;</span><br><span class="line">    <span class="comment">/* message queue is full */</span></span><br><span class="line">    <span class="keyword">if</span> (msg == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>首先確定 message queue 沒滿（即 free list 不為空）</li><li>如果滿了，回傳 <code>FULL</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1990</span><br><span class="line">1991</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move free list pointer */</span></span><br><span class="line">mq-&gt;msg_queue_free = msg-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著 free list 往下一顆走</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the msg is the new tailer of list, the next shall be NULL */</span></span><br><span class="line">msg-&gt;next = RT_NULL;</span><br><span class="line"><span class="comment">/* copy buffer */</span></span><br><span class="line">rt_memcpy(msg + <span class="number">1</span>, buffer, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>將訊息填入從 free list 拿的一顆（<code>msg</code>），這顆待會是新的尾巴（設定 <code>next = NULL</code>）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">temp = rt_hw_interrupt_disable();</span><br><span class="line"><span class="comment">/* link msg to message queue */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_tail != RT_NULL)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* if the tail exists, */</span></span><br><span class="line">    ((struct rt_mq_message *)mq-&gt;msg_queue_tail)-&gt;next = msg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果尾巴不為空（也就是 message queue 有東西），將原本的尾巴指向 <code>msg</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set new tail */</span></span><br><span class="line">mq-&gt;msg_queue_tail = msg;</span><br><span class="line"><span class="comment">/* if the head is empty, set head */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_head == RT_NULL)</span><br><span class="line">    mq-&gt;msg_queue_head = msg;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定新的尾巴</li><li>如果頭為空（也就是 message queue 為空），設定新的頭</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2012</span><br><span class="line">2013</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* increase message entry */</span></span><br><span class="line">mq-&gt;entry ++;</span><br></pre></td></tr></tbody></table></figure><ul><li>最後更新 <code>entry</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;mq-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mq-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_send);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待接收訊息，叫醒他</li></ul><hr><h4 id="傳送緊急訊息">傳送緊急訊息<a class="header-anchor" href="#傳送緊急訊息">#</a></h4><ul><li>與上面不同的是：這裡將新訊息插入<strong>第一顆</strong></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳送緊急訊息</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mq</code></th><th><code>*buffer</code></th><th><code>size</code></th></tr></thead><tbody><tr><td>欲傳送的 message queue</td><td>訊息資料</td><td>訊息大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send an urgent message to message queue object, which</span></span><br><span class="line"><span class="comment"> * means the message will be inserted to the head of message queue. If there</span></span><br><span class="line"><span class="comment"> * are threads suspended on message queue object, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> * @param buffer the message</span></span><br><span class="line"><span class="comment"> * @param size the size of buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_urgent(<span class="keyword">rt_mq_t</span> mq, <span class="keyword">void</span> *buffer, <span class="keyword">rt_size_t</span> size)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(buffer != RT_NULL);</span><br><span class="line">    RT_ASSERT(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* greater than one message size */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; mq-&gt;msg_size)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a free list, there must be an empty item */</span></span><br><span class="line">    msg = (struct rt_mq_message *)mq-&gt;msg_queue_free;</span><br><span class="line">    <span class="comment">/* message queue is full */</span></span><br><span class="line">    <span class="keyword">if</span> (msg == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* move free list pointer */</span></span><br><span class="line">    mq-&gt;msg_queue_free = msg-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy buffer */</span></span><br><span class="line">    rt_memcpy(msg + <span class="number">1</span>, buffer, size);</span><br></pre></td></tr></tbody></table></figure><ul><li>因為要插在第一顆，<code>next</code> 就不用設定為空了</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* link msg to the beginning of message queue */</span></span><br><span class="line">msg-&gt;next = mq-&gt;msg_queue_head;</span><br><span class="line">mq-&gt;msg_queue_head = msg;</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡就將新訊息插在第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if there is no tail */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_tail == RT_NULL)</span><br><span class="line">    mq-&gt;msg_queue_tail = msg;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果原本的 message queue 為空，設定新的尾巴</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* increase message entry */</span></span><br><span class="line">    mq-&gt;entry ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume suspended thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!rt_list_isempty(&amp;mq-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        rt_ipc_list_resume(&amp;(mq-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_urgent);</span><br></pre></td></tr></tbody></table></figure><ul><li>其他的動作皆相同</li></ul><hr><h3 id="接收訊息">接收訊息<a class="header-anchor" href="#接收訊息">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>接收訊息</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mq</code></th><th><code>*buffer</code></th><th><code>size</code></th><th><code>timeout</code></th></tr></thead><tbody><tr><td>欲訊息 message queue</td><td>訊息存放處</td><td>訊息存放處大小</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will receive a message from message queue object, if there is</span></span><br><span class="line"><span class="comment"> * no message in message queue object, the thread shall wait for a specified</span></span><br><span class="line"><span class="comment"> * time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mq the message queue object</span></span><br><span class="line"><span class="comment"> * @param buffer the received message will be saved in</span></span><br><span class="line"><span class="comment"> * @param size the size of buffer</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mq_recv(<span class="keyword">rt_mq_t</span>    mq,</span><br><span class="line">                    <span class="keyword">void</span>      *buffer,</span><br><span class="line">                    <span class="keyword">rt_size_t</span>  size,</span><br><span class="line">                    <span class="keyword">rt_int32_t</span> timeout)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mq_message</span> *<span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mq != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mq-&gt;parent.parent) == RT_Object_Class_MessageQueue);</span><br><span class="line">    RT_ASSERT(buffer != RT_NULL);</span><br><span class="line">    RT_ASSERT(size != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for non-blocking call */</span></span><br><span class="line">    <span class="keyword">if</span> (mq-&gt;entry == <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* message queue is empty */</span></span><br><span class="line">    <span class="keyword">while</span> (mq-&gt;entry == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* reset error number in thread */</span></span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no waiting, return timeout */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 message queue 為空，且不等待，回傳 <code>TIMEOUT</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mq-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mq-&gt;parent.parent.flag);</span><br></pre></td></tr></tbody></table></figure><ul><li>如要等待，將 thread 掛在等待鏈上</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get the start tick of timer */</span></span><br><span class="line">    tick_delta = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"set thread:%s to timer list\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>並啟動一個 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* re-schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>開始等待，做一次調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* recv message */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* return error */</span></span><br><span class="line">        <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if it's not waiting forever and then re-calculate timeout tick */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        tick_delta = rt_tick_get() - tick_delta;</span><br><span class="line">        timeout -= tick_delta;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如跳回來，重新計算 <code>timeout</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get message from queue */</span></span><br><span class="line">msg = (struct rt_mq_message *)mq-&gt;msg_queue_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* move message queue head */</span></span><br><span class="line">mq-&gt;msg_queue_head = msg-&gt;next;</span><br><span class="line"><span class="comment">/* reach queue tail, set to NULL */</span></span><br><span class="line"><span class="keyword">if</span> (mq-&gt;msg_queue_tail == msg)</span><br><span class="line">    mq-&gt;msg_queue_tail = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 message queue 有資料，拿第一顆，同時更新 head（tail，如果需要）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2237</span><br><span class="line">2238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* decrease message entry */</span></span><br><span class="line">mq-&gt;entry --;</span><br></pre></td></tr></tbody></table></figure><ul><li>更新 entry</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy message */</span></span><br><span class="line">rt_memcpy(buffer, msg + <span class="number">1</span>, size &gt; mq-&gt;msg_size ? mq-&gt;msg_size : size);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著複製找到的訊息</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* put message to free list */</span></span><br><span class="line">    msg-&gt;next = (struct rt_mq_message *)mq-&gt;msg_queue_free;</span><br><span class="line">    mq-&gt;msg_queue_free = msg;</span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mq-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mq_recv);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後將 <code>msg</code> 插入 free list 的頭</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - IPC Sync</title>
      <link href="/posts/RT-Thread/ipc.html"/>
      <url>/posts/RT-Thread/ipc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>兩個 thread 要溝通的方式，是透過共享的記憶體來完成；而如果此記憶體沒有排他性，這個記憶體有可能會不同步。</li><li>因此進入一塊共享的記憶體一次只允許一個 thread 來使用，這樣即可保證其資料的一致性</li><li>進入此共享記憶體則叫做 <strong>critical region</strong></li><li>RT-Thread 利用 7 種方式來完成同步：關閉中斷、scheduler lock、semaphore、互斥鎖、事件、mail box 及 message</li></ul><hr><h2 id="關閉中斷">關閉中斷<a class="header-anchor" href="#關閉中斷">#</a></h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">level = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  critical region </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">rt_hw_interrupt_enable(level);</span><br></pre></td></tr></tbody></table></figure><ul><li>此方式是最強大的一種，但此 critical region 不可以佔用太多時間</li></ul><hr><h2 id="Scheduler-lock">Scheduler lock<a class="header-anchor" href="#Scheduler-lock">#</a></h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">rt_enter_critical()</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  critical region </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">rt_exit_critical()</span><br></pre></td></tr></tbody></table></figure><ul><li>使用此方式可確保當前 thread 不會被 scheduler 踢出，但還是有可能會被中斷影響。</li></ul><hr><h3 id="進入-scheuler-鎖">進入 scheuler 鎖<a class="header-anchor" href="#進入-scheuler-鎖">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> scheduler.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>進入 scheuler 鎖</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will lock the thread scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_enter_critical</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the maximal number of nest is RT_UINT16_MAX, which is big</span></span><br><span class="line"><span class="comment">     * enough and does not check here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rt_scheduler_lock_nest ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_enter_critical);</span><br></pre></td></tr></tbody></table></figure><ul><li>即，將 <code>rt_scheduler_lock_nest</code> 加一</li></ul><hr><h3 id="離開-scheduler-鎖">離開 scheduler 鎖<a class="header-anchor" href="#離開-scheduler-鎖">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>離開 scheuler 鎖</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will unlock the thread scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_exit_critical</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    rt_scheduler_lock_nest --;</span><br></pre></td></tr></tbody></table></figure><ul><li>即，將 <code>rt_scheduler_lock_nest</code> 減一</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (rt_scheduler_lock_nest &lt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_scheduler_lock_nest = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>rt_scheduler_lock_nest</code> 被減至 0 或以下，進行一次調度</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>回傳 scheuler 鎖的值</td><td>scheuler 鎖的值</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the scheduler lock level</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the level of the scheduler lock. 0 means unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_uint16_t</span> rt_critical_level(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_scheduler_lock_nest;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_critical_level);</span><br></pre></td></tr></tbody></table></figure><ul><li>即，回傳 <code>rt_scheduler_lock_nest</code> 值</li></ul><hr><h2 id="Semaphore">Semaphore<a class="header-anchor" href="#Semaphore">#</a></h2><ul><li>為一個值，代表同時可用的個數</li><li>不等於 0 時可用，取用時將值減 1</li><li>當不可用時，將 thread 掛在等待的鏈上</li></ul><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><h3 id="結構">結構<a class="header-anchor" href="#結構">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_SEMAPHORE</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Semaphore structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          value;                         <span class="comment">/**&lt; value of semaphore. */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span> *<span class="title">rt_sem_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="flags">flags<a class="header-anchor" href="#flags">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IPC flags and control command definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_FLAG_FIFO                0x00            <span class="comment">/**&lt; FIFOed IPC. @ref IPC. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_FLAG_PRIO                0x01            <span class="comment">/**&lt; PRIOed IPC. @ref IPC. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_CMD_UNKNOWN              0x00            <span class="comment">/**&lt; unknown IPC command */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_IPC_CMD_RESET                0x01            <span class="comment">/**&lt; reset IPC object */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_WAITING_FOREVER              -1              <span class="comment">/**&lt; Block forever until get resource. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_WAITING_NO                   0               <span class="comment">/**&lt; Non-block. */</span></span></span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立-semaphore">建立 semaphore<a class="header-anchor" href="#建立-semaphore">#</a></h3><h4 id="動態記憶體管理">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 semaphore</td><td>semaphore</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>value</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>semaphore 值，即最大可同時使用人數</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a semaphore from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of semaphore</span></span><br><span class="line"><span class="comment"> * @param value the init value of semaphore</span></span><br><span class="line"><span class="comment"> * @param flag the flag of semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created semaphore, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_sem_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_sem_t</span> rt_sem_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint32_t</span> value, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_sem_t</span> sem;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    sem = (<span class="keyword">rt_sem_t</span>)rt_object_allocate(RT_Object_Class_Semaphore, name);</span><br><span class="line">    <span class="keyword">if</span> (sem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(sem-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set init value */</span></span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    sem-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sem;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先需要一塊 semaphore 的大小，初始化 ipc 物件，再依序寫入初始值及 flag</li></ul><hr><h4 id="靜態記憶體管理">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 semaphore</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>sem</code></th><th><code>*name</code></th><th><code>value</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>semaphore 本體</td><td>名字</td><td>semaphore 值，即最大可同時使用人數</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a semaphore and put it under control of</span></span><br><span class="line"><span class="comment"> * resource management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> * @param name the name of semaphore</span></span><br><span class="line"><span class="comment"> * @param value the init value of semaphore</span></span><br><span class="line"><span class="comment"> * @param flag the flag of semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_init(<span class="keyword">rt_sem_t</span>    sem,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">rt_uint32_t</span> value,</span><br><span class="line">                     <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(sem-&gt;parent.parent), RT_Object_Class_Semaphore, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(sem-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set init value */</span></span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    sem-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>由於使用靜態記憶體，這裡就不需要再 allocate。</li></ul><hr><h3 id="刪除-semaphore">刪除 semaphore<a class="header-anchor" href="#刪除-semaphore">#</a></h3><h4 id="動態記憶體管理-v2">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>sem</code></th></tr></thead><tbody><tr><td>刪除 semaphore</td><td><code>RT_EOK</code></td><td>欲刪除的 semaphore</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a semaphore object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_sem_detach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_delete(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;sem-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(sem-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete semaphore object */</span></span><br><span class="line">    rt_object_delete(&amp;(sem-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先需把所有正在等待此 semaphore 的 thread 叫醒</li><li>接著呼叫 <code>rt_object_delete</code> 清除此物件（semaphore）</li></ul><hr><h4 id="靜態記憶體管理-v2">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>sem</code></th></tr></thead><tbody><tr><td>刪除 semaphore</td><td><code>RT_EOK</code></td><td>欲刪除的 semaphore</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a semaphore from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_sem_delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_detach(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;sem-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(sem-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach semaphore object */</span></span><br><span class="line">    rt_object_detach(&amp;(sem-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡則透過 <code>rt_object_detach</code> 清除</li></ul><hr><h3 id="使用-semaphore">使用 semaphore<a class="header-anchor" href="#使用-semaphore">#</a></h3><ul><li>呼叫 <code>rt_sem_take</code> 來取得 semaphore，傳入的 time 是等待時間</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求 semaphore</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>sem</code></th><th><code>time</code></th></tr></thead><tbody><tr><td>欲要求的 semaphore</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will take a semaphore, if the semaphore is unavailable, the</span></span><br><span class="line"><span class="comment"> * thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> * @param time the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_take(<span class="keyword">rt_sem_t</span> sem, <span class="keyword">rt_int32_t</span> time)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(sem-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>由於待會會修改 semaphore 的值，這裡先將中斷關閉</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"thread %s take sem:%s, which value is: %d\n"</span>,</span><br><span class="line">                            rt_thread_self()-&gt;name,</span><br><span class="line">                            ((struct rt_object *)sem)-&gt;name,</span><br><span class="line">                            sem-&gt;value));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* semaphore is available */</span></span><br><span class="line">    sem-&gt;value --;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如過 <code>sem-&gt;value</code> 值大於 0 代表可用，接著減一，並開啟中斷</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no waiting, return with timeout */</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 semaphore 不可用時：</li><li>且 time 為 0，表示不等待，直接開啟中斷並 return</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* current context checking */</span></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* semaphore is unavailable, push to suspend list */</span></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset thread error number */</span></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"sem take: suspend thread - %s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* suspend thread */</span></span><br><span class="line">    rt_ipc_list_suspend(&amp;(sem-&gt;parent.suspend_thread),</span><br><span class="line">                        thread,</span><br><span class="line">                        sem-&gt;parent.parent.flag);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果要等待，則將 thread 插入 suspend list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"set thread:%s to timer list\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;time);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>且如果等待時間大於 0，則啟動一個 timeout 為 time 的 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do schedule */</span></span><br><span class="line">            rt_schedule();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(sem-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_take);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後開啟中斷，做一次調度</li></ul><hr><ul><li>若是不想等待，可以呼叫 <code>rt_sem_trytake</code></li><li>即呼叫 <code>rt_sem_take</code> 及傳入 <code>time</code> 為 0</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>sem</code></th></tr></thead><tbody><tr><td>要求 semaphore（不等待）</td><td><code>RT_EOK</code></td><td>欲要求的 semaphore</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will try to take a semaphore and immediately return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_trytake(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_sem_take(sem, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_trytake);</span><br></pre></td></tr></tbody></table></figure><hr><ul><li>還 semaphore 則使用 <code>rt_sem_release</code></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>sem</code></th></tr></thead><tbody><tr><td>釋放 semaphore</td><td><code>RT_EOK</code></td><td>欲要求的 semaphore</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release a semaphore, if there are threads suspended on</span></span><br><span class="line"><span class="comment"> * semaphore, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sem the semaphore object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_release(<span class="keyword">rt_sem_t</span> sem)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_bool_t</span> need_schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(sem != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;sem-&gt;parent.parent) == RT_Object_Class_Semaphore);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(sem-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將待會會遇到的 flag（<code>need_schedule</code>）設為 false</li><li>因為待會也會修改 semaphore 的值，這裡需要關閉中斷</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"thread %s releases sem:%s, which value is: %d\n"</span>,</span><br><span class="line">                            rt_thread_self()-&gt;name,</span><br><span class="line">                            ((struct rt_object *)sem)-&gt;name,</span><br><span class="line">                            sem-&gt;value));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rt_list_isempty(&amp;sem-&gt;parent.suspend_thread))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* resume the suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume(&amp;(sem-&gt;parent.suspend_thread));</span><br><span class="line">    need_schedule = RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等此 semaphore，先恢復他，並修改 <code>need_schedule</code> 為 true</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">455</span><br><span class="line">456</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    sem-&gt;value ++; <span class="comment">/* increase value */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果沒有人在等待，則加一</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume a thread, re-schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (need_schedule == RT_TRUE)</span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_sem_release);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後開啟中斷，並根據 <code>need_schedule</code> 來決定需不需要執行一次調度</li></ul><hr><h2 id="互斥鎖（mutex）">互斥鎖（mutex）<a class="header-anchor" href="#互斥鎖（mutex）">#</a></h2><ul><li>即一種值為 1 的特殊 semaphore，特別的是具有防止優先級翻轉的特性</li></ul><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><h3 id="結構-v2">結構<a class="header-anchor" href="#結構-v2">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MUTEX</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mutual exclusion (mutex) structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint16_t</span>          value;                         <span class="comment">/**&lt; value of mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>           original_priority;             <span class="comment">/**&lt; priority of last thread hold the mutex */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>           hold;                          <span class="comment">/**&lt; numbers of thread hold the mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span>    *<span class="title">owner</span>;</span>                         <span class="comment">/**&lt; current owner of mutex */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> *<span class="title">rt_mutex_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>為了防止優先權翻轉，在持有鎖的過程中可能會被提升優先權，在結構中就需要紀錄原本的優先級。</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立-mutex">建立 mutex<a class="header-anchor" href="#建立-mutex">#</a></h3><h4 id="動態記憶體管理-v3">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v3">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 mutex</td><td>mutex</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a mutex from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of mutex</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mutex</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created mutex, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_mutex_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_mutex_t</span> rt_mutex_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> *<span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    mutex = (<span class="keyword">rt_mutex_t</span>)rt_object_allocate(RT_Object_Class_Mutex, name);</span><br><span class="line">    <span class="keyword">if</span> (mutex == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mutex;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先 allocate 一個物件，初始化</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init ipc object */</span></span><br><span class="line">rt_ipc_object_init(&amp;(mutex-&gt;parent));</span><br><span class="line"></span><br><span class="line">mutex-&gt;value              = <span class="number">1</span>;</span><br><span class="line">mutex-&gt;owner              = RT_NULL;</span><br><span class="line">mutex-&gt;original_priority  = <span class="number">0xFF</span>;</span><br><span class="line">mutex-&gt;hold               = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>value 設為 1，擁有者為 NULL，原始權限最低（255），持有次數為 0</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* set flag */</span></span><br><span class="line">    mutex-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutex;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>同時填入 flag</li></ul><hr><h4 id="靜態記憶體管理-v3">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v3">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 mutex</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mutex</code></th><th><code>*name</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>mutex 本體</td><td>名字</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a mutex and put it under control of resource</span></span><br><span class="line"><span class="comment"> * management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> * @param name the name of mutex</span></span><br><span class="line"><span class="comment"> * @param flag the flag of mutex</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_init(<span class="keyword">rt_mutex_t</span> mutex, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(mutex-&gt;parent.parent), RT_Object_Class_Mutex, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mutex-&gt;parent));</span><br><span class="line"></span><br><span class="line">    mutex-&gt;value = <span class="number">1</span>;</span><br><span class="line">    mutex-&gt;owner = RT_NULL;</span><br><span class="line">    mutex-&gt;original_priority = <span class="number">0xFF</span>;</span><br><span class="line">    mutex-&gt;hold  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set flag */</span></span><br><span class="line">    mutex-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡不需要 allocate，只需要初始化物件</li></ul><hr><h3 id="刪除-mutex">刪除 mutex<a class="header-anchor" href="#刪除-mutex">#</a></h3><h4 id="動態記憶體管理-v4">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v4">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>刪除 mutex</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mutex</code></th></tr></thead><tbody><tr><td>欲刪除的 mutex</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a mutex object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_mutex_detach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_delete(<span class="keyword">rt_mutex_t</span> mutex)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mutex-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mutex-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete semaphore object */</span></span><br><span class="line">    rt_object_delete(&amp;(mutex-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 semaphore 類似，先將正在等待此鎖的所有 thread 叫醒，接著透過 <code>rt_object_delete</code> 刪除 mutex</li></ul><hr><h4 id="靜態記憶體管理-v4">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v4">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>刪除 mutex</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mutex</code></th></tr></thead><tbody><tr><td>欲刪除的 mutex</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a mutex from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see rt_mutex_delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_detach(<span class="keyword">rt_mutex_t</span> mutex)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;mutex-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup all suspend threads */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(mutex-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach semaphore object */</span></span><br><span class="line">    rt_object_detach(&amp;(mutex-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡則運用 <code>rt_object_detach</code> 刪除</li></ul><hr><h3 id="使用-mutex">使用 mutex<a class="header-anchor" href="#使用-mutex">#</a></h3><ul><li>呼叫 <code>rt_mutex_take</code> 來取得鎖</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>要求 mutex</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>mutex</code></th><th><code>time</code></th></tr></thead><tbody><tr><td>欲要求的 mutex</td><td>等待時間（如果需要）</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will take a mutex, if the mutex is unavailable, the</span></span><br><span class="line"><span class="comment"> * thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> * @param time the waiting time</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_take(<span class="keyword">rt_mutex_t</span> mutex, <span class="keyword">rt_int32_t</span> time)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this function must not be used in interrupt even if time = 0 */</span></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>下面將會修改 mutex 的一些資料，這裡先將中斷關閉</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br></pre></td><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(mutex-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC,</span><br><span class="line">             (<span class="string">"mutex_take: current thread %s, mutex value: %d, hold: %d\n"</span>,</span><br><span class="line">              thread-&gt;name, mutex-&gt;value, mutex-&gt;hold));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reset thread error */</span></span><br><span class="line">thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mutex-&gt;owner == thread)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* it's the same thread */</span></span><br><span class="line">    mutex-&gt;hold ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若此 mutex 的擁有者與要求著相同，持有數加 1</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">__again:</span><br><span class="line">        <span class="comment">/* The value of mutex is 1 in initial status. Therefore, if the</span></span><br><span class="line"><span class="comment">         * value is great than 0, it indicates the mutex is avaible.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mutex-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* mutex is available */</span></span><br><span class="line">            mutex-&gt;value --;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set mutex owner and original priority */</span></span><br><span class="line">            mutex-&gt;owner             = thread;</span><br><span class="line">            mutex-&gt;original_priority = thread-&gt;current_priority;</span><br><span class="line">            mutex-&gt;hold ++;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不同，且 mutex 可用，先將 value <code>--</code></li><li>設定所有者，紀錄當前權限，持有數加 1</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no waiting, return with timeout */</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* set error as timeout */</span></span><br><span class="line">        thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果不可用，且不等待，則啟用中斷，<code>return -RT_ETIMEOUT</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* mutex is unavailable, push to suspend list */</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mutex_take: suspend thread: %s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change the owner thread priority of mutex */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;current_priority &lt; mutex-&gt;owner-&gt;current_priority)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* change the owner thread priority */</span></span><br><span class="line">        rt_thread_control(mutex-&gt;owner,</span><br><span class="line">                          RT_THREAD_CTRL_CHANGE_PRIORITY,</span><br><span class="line">                          &amp;thread-&gt;current_priority);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>若需要等待：</li><li>為了避免優先權翻轉的情形發生，如需等待的 thread 的優先級大於持有 mutex 的優先級，提升持有者的</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* suspend current thread */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(mutex-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    mutex-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* has waiting time, start thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC,</span><br><span class="line">                 (<span class="string">"mutex_take: start the timer of thread:%s\n"</span>,</span><br><span class="line">                  thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;time);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>插入 suspend list，並啟動一個 timeout 為 time 的 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>開啟中斷，並做一次調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">{</span><br><span class="line"><span class="comment">/* interrupt by signal, try it again */</span></span><br><span class="line"><span class="keyword">if</span> (thread-&gt;error == -RT_EINTR) <span class="keyword">goto</span> __again;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return error */</span></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果因為中斷再次回到此 thread，重新要一次 mutex</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">/* the mutex is taken successfully. */</span></span><br><span class="line">                    <span class="comment">/* disable interrupt */</span></span><br><span class="line">                    temp = rt_hw_interrupt_disable();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(mutex-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_take);</span><br></pre></td></tr></tbody></table></figure><hr><ul><li>還鎖則使用 <code>rt_mutex_release</code></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>mutex</code></th></tr></thead><tbody><tr><td>釋放 mutex</td><td><code>RT_EOK</code></td><td>欲釋放的 mutex</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will release a mutex, if there are threads suspended on mutex,</span></span><br><span class="line"><span class="comment"> * it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mutex the mutex object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_mutex_release(<span class="keyword">rt_mutex_t</span> mutex)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">rt_bool_t</span> need_schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(mutex != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;mutex-&gt;parent.parent) == RT_Object_Class_Mutex);</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only thread could release mutex because we need test the ownership */</span></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>下面將會修改 mutex 的一些資料，這裡先將中斷關閉</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_IPC,</span><br><span class="line">             (<span class="string">"mutex_release:current thread %s, mutex value: %d, hold: %d\n"</span>,</span><br><span class="line">              thread-&gt;name, mutex-&gt;value, mutex-&gt;hold));</span><br><span class="line"></span><br><span class="line">RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(mutex-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mutex only can be released by owner */</span></span><br><span class="line"><span class="keyword">if</span> (thread != mutex-&gt;owner)</span><br><span class="line">{</span><br><span class="line">    thread-&gt;error = -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>檢查歸還者是否為擁有者</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">822</span><br><span class="line">823</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* decrease hold */</span></span><br><span class="line">mutex-&gt;hold --;</span><br></pre></td></tr></tbody></table></figure><ul><li>持有數減 1</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if no hold */</span></span><br><span class="line"><span class="keyword">if</span> (mutex-&gt;hold == 才會</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* change the owner thread to original priority */</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;original_priority != mutex-&gt;owner-&gt;current_priority)</span><br><span class="line">    {</span><br><span class="line">        rt_thread_control(mutex-&gt;owner,</span><br><span class="line">                          RT_THREAD_CTRL_CHANGE_PRIORITY,</span><br><span class="line">                          &amp;(mutex-&gt;original_priority));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>若已不再擁有此 mutex，且優先權有被更改過，調整回來</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* wakeup suspended thread */</span></span><br><span class="line"><span class="keyword">if</span> (!rt_list_isempty(&amp;mutex-&gt;parent.suspend_thread))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* get suspended thread */</span></span><br><span class="line">    thread = rt_list_entry(mutex-&gt;parent.suspend_thread.next,</span><br><span class="line">                           struct rt_thread,</span><br><span class="line">                           tlist);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_IPC, (<span class="string">"mutex_release: resume thread: %s\n"</span>,</span><br><span class="line">                                thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set new owner and priority */</span></span><br><span class="line">    mutex-&gt;owner             = thread;</span><br><span class="line">    mutex-&gt;original_priority = thread-&gt;current_priority;</span><br><span class="line">    mutex-&gt;hold ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume thread */</span></span><br><span class="line">    rt_ipc_list_resume(&amp;(mutex-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若有人在等待此 mutex，將 mutex 傳遞給第一個正在等待的 thread</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* increase value */</span></span><br><span class="line">        mutex-&gt;value ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* clear owner */</span></span><br><span class="line">        mutex-&gt;owner             = RT_NULL;</span><br><span class="line">        mutex-&gt;original_priority = <span class="number">0xff</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果沒有人在等，value 加 1，將資料初始化</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* perform a schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (need_schedule == RT_TRUE)</span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_mutex_release);</span><br></pre></td></tr></tbody></table></figure><ul><li>開啟中斷，並視情況做一次調度</li></ul><hr><h2 id="事件">事件<a class="header-anchor" href="#事件">#</a></h2><ul><li>可實現一對多，多對多</li><li>僅用來同步，無傳輸的功能</li></ul><h3 id="實作">實作<a class="header-anchor" href="#實作">#</a></h3><ul><li>thread 的結構中有一個 32 位的事件標記，一個事件的資訊</li></ul><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(RT_USING_EVENT)</span></span><br><span class="line">    <span class="comment">/* thread event */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> event_set;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  event_info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>標記的每一位代表一個事件，資訊包含 AND、OR 及 CLEAR</li><li>當事件標記的第 2、4 位為 1，其餘為 0，代表此 thread 設置第 2、4 個事件<ul><li>AND：即需同時接收到 2 號與 4 號事件才會被喚醒</li><li>OR：只需接收到一個</li><li>CLEAR：表示接收完事件喚醒後，是否須將標記清除</li></ul></li></ul><h3 id="結構-v3">結構<a class="header-anchor" href="#結構-v3">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_EVENT</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flag defintions in event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_EVENT_FLAG_AND               0x01            <span class="comment">/**&lt; logic and */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_EVENT_FLAG_OR                0x02            <span class="comment">/**&lt; logic or */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_EVENT_FLAG_CLEAR             0x04            <span class="comment">/**&lt; clear flag */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * event structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_event</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span>          <span class="built_in">set</span>;                           <span class="comment">/**&lt; event set */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_event</span> *<span class="title">rt_event_t</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> ipc.c</p></div><h3 id="建立事件">建立事件<a class="header-anchor" href="#建立事件">#</a></h3><h4 id="動態記憶體管理-v5">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v5">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立事件</td><td>事件</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create an event object from system resource</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of event</span></span><br><span class="line"><span class="comment"> * @param flag the flag of event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created event, RT_NULL on error happen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_event_t</span> rt_event_create(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_event_t</span> event;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate object */</span></span><br><span class="line">    event = (<span class="keyword">rt_event_t</span>)rt_object_allocate(RT_Object_Class_Event, name);</span><br><span class="line">    <span class="keyword">if</span> (event == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    event-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(event-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init event */</span></span><br><span class="line">    event-&gt;<span class="built_in">set</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣 allocate 記憶體，填入 flag，初始化，最後設定值為 0</li></ul><hr><h4 id="靜態記憶體管理-v5">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v5">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化事件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>event</code></th><th><code>*name</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>事件本體</td><td>名字</td><td>FIFO / PRIO</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize an event and put it under control of resource</span></span><br><span class="line"><span class="comment"> * management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> * @param name the name of event</span></span><br><span class="line"><span class="comment"> * @param flag the flag of event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_init(<span class="keyword">rt_event_t</span> event, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init object */</span></span><br><span class="line">    rt_object_init(&amp;(event-&gt;parent.parent), RT_Object_Class_Event, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent flag */</span></span><br><span class="line">    event-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init ipc object */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(event-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init event */</span></span><br><span class="line">    event-&gt;<span class="built_in">set</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡則不需要 allocate</li></ul><hr><h3 id="刪除事件">刪除事件<a class="header-anchor" href="#刪除事件">#</a></h3><h4 id="靜態記憶體管理-v6">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v6">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>event</code></th></tr></thead><tbody><tr><td>刪除事件</td><td><code>RT_EOK</code></td><td>欲刪除的事件</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete an event object and release the memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_delete(<span class="keyword">rt_event_t</span> event)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;event-&gt;parent.parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_NOT_IN_INTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(event-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete event object */</span></span><br><span class="line">    rt_object_delete(&amp;(event-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>相同的，需要先將正在等待此事件的 thread 叫醒，再刪除</li></ul><hr><h4 id="靜態記憶體管理-v7">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v7">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>event</code></th></tr></thead><tbody><tr><td>刪除事件</td><td><code>RT_EOK</code></td><td>欲刪除的事件</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach an event object from resource management</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_detach(<span class="keyword">rt_event_t</span> event)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;event-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resume all suspended thread */</span></span><br><span class="line">    rt_ipc_list_resume_all(&amp;(event-&gt;parent.suspend_thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach event object */</span></span><br><span class="line">    rt_object_detach(&amp;(event-&gt;parent.parent));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>這裡則用 <code>rt_object_detach</code></li></ul><hr><h3 id="傳遞事件">傳遞事件<a class="header-anchor" href="#傳遞事件">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>傳遞事件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>event</code></th><th><code>set</code></th></tr></thead><tbody><tr><td>欲傳遞的事件</td><td>事件編號</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will send an event to the event object, if there are threads</span></span><br><span class="line"><span class="comment"> * suspended on event object, it will be waked up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the event object</span></span><br><span class="line"><span class="comment"> * @param set the event set</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_send(<span class="keyword">rt_event_t</span> event, <span class="keyword">rt_uint32_t</span> <span class="built_in">set</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> level;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> status;</span><br><span class="line">    <span class="keyword">rt_bool_t</span> need_schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    need_schedule = RT_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>下面會修改事件的資料，這裡先將中斷關閉</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1044</span><br><span class="line">1045</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set event */</span></span><br><span class="line">event-&gt;<span class="built_in">set</span> |= <span class="built_in">set</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定事件編號</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br></pre></td><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(event-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rt_list_isempty(&amp;event-&gt;parent.suspend_thread))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* search thread list to resume thread */</span></span><br><span class="line">    n = event-&gt;parent.suspend_thread.next;</span><br><span class="line">    <span class="keyword">while</span> (n != &amp;(event-&gt;parent.suspend_thread))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* get thread */</span></span><br><span class="line">        thread = rt_list_entry(n, struct rt_thread, tlist);</span><br><span class="line"></span><br><span class="line">        status = -RT_ERROR;</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;event_info &amp; RT_EVENT_FLAG_AND)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((thread-&gt;event_set &amp; event-&gt;<span class="built_in">set</span>) == thread-&gt;event_set)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* received an AND event */</span></span><br><span class="line">                status = RT_EOK;</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果有人在等待此事件，且滿足條件時，設定為 OK</li><li>這裡為 AND，即事件編號應與 thread 所設定的一致</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (thread-&gt;event_info &amp; RT_EVENT_FLAG_OR)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;event_set &amp; event-&gt;<span class="built_in">set</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* save recieved event set */</span></span><br><span class="line">        thread-&gt;event_set = thread-&gt;event_set &amp; event-&gt;<span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* received an OR event */</span></span><br><span class="line">        status = RT_EOK;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若為 OR，則只需有一位相同即可</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1077</span><br><span class="line">1078</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move node to the next */</span></span><br><span class="line">n = n-&gt;next;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著走向下一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* condition is satisfied, resume thread */</span></span><br><span class="line"><span class="keyword">if</span> (status == RT_EOK)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* clear event */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;event_info &amp; RT_EVENT_FLAG_CLEAR)</span><br><span class="line">        event-&gt;<span class="built_in">set</span> &amp;= ~thread-&gt;event_set;</span><br></pre></td></tr></tbody></table></figure><ul><li>如有人滿足條件，且被設定 CLEAR，清除其標記位</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* resume thread, and thread list breaks out */</span></span><br><span class="line">            rt_thread_resume(thread);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* need do a scheduling */</span></span><br><span class="line">            need_schedule = RT_TRUE;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>並恢復此 thread，設定待會需要調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do a schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (need_schedule == RT_TRUE)</span><br><span class="line">        rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_send);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後開啟中斷，視情況做一次調度</li></ul><hr><h3 id="接收事件">接收事件<a class="header-anchor" href="#接收事件">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>接收事件</td><td><code>RT_EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>event</code></th><th><code>set</code></th><th><code>option</code></th><th><code>timeout</code></th><th><code>*recved</code></th></tr></thead><tbody><tr><td>欲接收的事件</td><td>事件編號</td><td>AND /OR</td><td>等待時間（如果需要）</td><td>傳遞成功的事件號碼</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will receive an event from event object, if the event is</span></span><br><span class="line"><span class="comment"> * unavailable, the thread shall wait for a specified time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param event the fast event object</span></span><br><span class="line"><span class="comment"> * @param set the interested event set</span></span><br><span class="line"><span class="comment"> * @param option the receive option, either RT_EVENT_FLAG_AND or</span></span><br><span class="line"><span class="comment"> *        RT_EVENT_FLAG_OR should be set.</span></span><br><span class="line"><span class="comment"> * @param timeout the waiting time</span></span><br><span class="line"><span class="comment"> * @param recved the received event, if you don't care, RT_NULL can be set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_event_recv(<span class="keyword">rt_event_t</span>   event,</span><br><span class="line">                       <span class="keyword">rt_uint32_t</span>  <span class="built_in">set</span>,</span><br><span class="line">                       <span class="keyword">rt_uint8_t</span>   option,</span><br><span class="line">                       <span class="keyword">rt_int32_t</span>   timeout,</span><br><span class="line">                       <span class="keyword">rt_uint32_t</span> *recved)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> level;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> status;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_IN_THREAD_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parameter check */</span></span><br><span class="line">    RT_ASSERT(event != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;event-&gt;parent.parent) == RT_Object_Class_Event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init status */</span></span><br><span class="line">    status = -RT_ERROR;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line">    <span class="comment">/* reset thread error */</span></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&amp;(event-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>下面會修改事件的資料，這裡先將中斷關閉</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check event set */</span></span><br><span class="line"><span class="keyword">if</span> (option &amp; RT_EVENT_FLAG_AND)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ((event-&gt;<span class="built_in">set</span> &amp; <span class="built_in">set</span>) == <span class="built_in">set</span>)</span><br><span class="line">        status = RT_EOK;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (option &amp; RT_EVENT_FLAG_OR)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">set</span> &amp; <span class="built_in">set</span>)</span><br><span class="line">        status = RT_EOK;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */</span></span><br><span class="line">    RT_ASSERT(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果滿足條件，表示已接收到事件，設定為 OK</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == RT_EOK)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* set received event */</span></span><br><span class="line">    <span class="keyword">if</span> (recved)</span><br><span class="line">        *recved = (event-&gt;<span class="built_in">set</span> &amp; <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* received event */</span></span><br><span class="line">    <span class="keyword">if</span> (option &amp; RT_EVENT_FLAG_CLEAR)</span><br><span class="line">        event-&gt;<span class="built_in">set</span> &amp;= ~<span class="built_in">set</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果已接收到事件，設定 recved 參數</li><li>視情況看需不需要清除標記</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* no waiting */</span></span><br><span class="line">    thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若需等待事件，但 timeout 為 0</li><li>即不等待，將錯誤碼設為 TIMEOUT</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* fill thread event info */</span></span><br><span class="line">    thread-&gt;event_set  = <span class="built_in">set</span>;</span><br><span class="line">    thread-&gt;event_info = option;</span><br></pre></td></tr></tbody></table></figure><ul><li>如欲等待，將資訊掛在 thread 的結構上</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* put thread to suspended thread list */</span></span><br><span class="line">rt_ipc_list_suspend(&amp;(event-&gt;parent.suspend_thread),</span><br><span class="line">                    thread,</span><br><span class="line">                    event-&gt;parent.parent.flag);</span><br></pre></td></tr></tbody></table></figure><ul><li>並插入等待的鏈上</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if there is a waiting timeout, active thread timer */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                     RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                     &amp;timeout);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>啟動一個 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* enable interrupt */</span></span><br><span class="line">rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do a schedule */</span></span><br><span class="line">rt_schedule();</span><br></pre></td></tr></tbody></table></figure><ul><li>最後開啟中斷，並做一次調度</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* return error */</span></span><br><span class="line">            <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* received an event, disable interrupt to protect */</span></span><br><span class="line">        level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set received event */</span></span><br><span class="line">        <span class="keyword">if</span> (recved)</span><br><span class="line">            *recved = thread-&gt;event_set;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(event-&gt;parent.parent)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_event_recv);</span><br></pre></td></tr></tbody></table></figure><ul><li>最終接收到事件，一樣設定 recved 參數，回傳錯誤碼</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Clock</title>
      <link href="/posts/RT-Thread/clock.html"/>
      <url>/posts/RT-Thread/clock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> clock.c</p></div><h2 id="取得當前-tick">取得當前 tick<a class="header-anchor" href="#取得當前-tick">#</a></h2><div class="alert alert-secondary"><p>即回傳全域變數 <code>rt_tick</code> 值</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>取得當前的 system tick</td><td>tick 值</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will return current tick from operating system startup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return current tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_tick_t</span> rt_tick_get(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* return the global tick */</span></span><br><span class="line">    <span class="keyword">return</span> rt_tick;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_tick_get);</span><br></pre></td></tr></tbody></table></figure><h2 id="設定當前-tick">設定當前 tick<a class="header-anchor" href="#設定當前-tick">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>tick</code></th></tr></thead><tbody><tr><td>修改 system tick</td><td>void</td><td>欲修改的結果</td></tr></tbody></table></div><ul><li>由於需要修改全域變數，因此這裡需要將中斷關閉進入 critical region</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will set current tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_tick_set</span><span class="params">(<span class="keyword">rt_tick_t</span> tick)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line">    rt_tick = tick;</span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="增加-tick">增加 tick<a class="header-anchor" href="#增加-tick">#</a></h2><ul><li>增加 tick 是由 ISR 所執行的動作，因此修改 <code>rt_tick</code> 值不需進入 critical region</li><li>由於增加 tick 需要發出中斷，所以所有的 ISR 都不可以佔用太多時間（如果執行超過一個 tick 的時間，clock ISR 就無法在正確的時間發生中斷，時間就會不準）</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增加 tick（clock ISR）</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will notify kernel there is one tick passed. Normally,</span></span><br><span class="line"><span class="comment"> * this function is invoked by clock ISR.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_tick_increase</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increase the global tick */</span></span><br><span class="line">    ++ rt_tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check time slice */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    -- thread-&gt;remaining_tick;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;remaining_tick == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* change to initialized tick */</span></span><br><span class="line">        thread-&gt;remaining_tick = thread-&gt;init_tick;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* yield */</span></span><br><span class="line">        rt_thread_yield();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check timer */</span></span><br><span class="line">    rt_timer_check();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在增加 <code>rt_tick</code> 值的同時，也減少當前 thread 的剩餘 tick 值；當減至 0 時，重設剩餘 tick 並讓出處理器。</li><li>（rt_timer_check()）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> clock </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Timer</title>
      <link href="/posts/RT-Thread/timer.html"/>
      <url>/posts/RT-Thread/timer.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>timer 的作用：當時間到時，觸發一個事件；如文本的圖：<br><div class="img-item" data-src="https://i.imgur.com/6ois2av.png" data-sub-html=".caption"><img src="https://i.imgur.com/6ois2av.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li><li>timer 的實作是一條鏈，即當前 tick 到達指定的 timer 時，會觸發該 timer 的 <code>timeout_func</code>，同時將該 timer 從鏈結移除</li><li>以上圖為例，當 <code>rt_tick</code> = 70 時，將會觸發 timer #1 的 <code>timeout_func</code>，並將 timer #1 移除</li></ul><hr><ul><li>而在新增一個 timer 時，會按照 timeout 的大小排列插入，如圖：<br><div class="img-item" data-src="https://i.imgur.com/yCkzoq0.png" data-sub-html=".caption"><img src="https://i.imgur.com/yCkzoq0.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li><li>我們想要新增一個 timer #4，並希望在 300 個 tick 過後觸發事件，所以 timeout 設為 330（rt_tick + 300）</li><li>由於 timer 鏈需要由小到大排，所以將 timer #4 插在 #2 與 #3 之間</li></ul><hr><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timer structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> <span class="title">parent</span>;</span>                            <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>        row[RT_TIMER_SKIP_LIST_LEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*timeout_func)(<span class="keyword">void</span> *parameter);              <span class="comment">/**&lt; timeout function */</span></span><br><span class="line">    <span class="keyword">void</span>            *parameter;                         <span class="comment">/**&lt; timeout function's parameter */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_tick_t</span>        init_tick;                         <span class="comment">/**&lt; timer timeout tick */</span></span><br><span class="line">    <span class="keyword">rt_tick_t</span>        timeout_tick;                      <span class="comment">/**&lt; timeout tick */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> *<span class="title">rt_timer_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>timeout_func</code> 即為 timeout 時會觸發的函式</li><li><code>timeout_tick</code> = <code>init_tick</code> + 當前的 system tick</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> timer.c</p></div><h2 id="初始化、建立-timer">初始化、建立 timer<a class="header-anchor" href="#初始化、建立-timer">#</a></h2><ul><li>在建立一個 thread 時，<code>_rt_thread_init</code> 會呼叫 <code>rt_timer_init</code> 來初始化 timer</li></ul><h3 id="靜態記憶體管理">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 timer</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>timer</code></th><th><code>*name</code></th><th><code>*timeout</code></th><th><code>*parameter</code></th><th><code>time</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>timer 結構</td><td>名字</td><td>timeout function</td><td>func 的參數</td><td>timeout 初始 tick</td><td>狀態</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*parameter</code></th><th><code>time</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>func 的參數</td><td>timeout 初始 tick</td><td>狀態</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a timer, normally this function is used to</span></span><br><span class="line"><span class="comment"> * initialize a static timer object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timer the static timer object</span></span><br><span class="line"><span class="comment"> * @param name the name of timer</span></span><br><span class="line"><span class="comment"> * @param timeout the timeout function</span></span><br><span class="line"><span class="comment"> * @param parameter the parameter of timeout function</span></span><br><span class="line"><span class="comment"> * @param time the tick of timer</span></span><br><span class="line"><span class="comment"> * @param flag the flag of timer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_timer_init</span><span class="params">(<span class="keyword">rt_timer_t</span>  timer,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> (*timeout)(<span class="keyword">void</span> *parameter),</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span>       *parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rt_tick_t</span>   time,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">rt_uint8_t</span>  flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* timer check */</span></span><br><span class="line">    RT_ASSERT(timer != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* timer object initialization */</span></span><br><span class="line">    rt_object_init((<span class="keyword">rt_object_t</span>)timer, RT_Object_Class_Timer, name);</span><br><span class="line"></span><br><span class="line">    _rt_timer_init(timer, timeout, parameter, time, flag);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 thread 類似，使用 <code>_rt_timer_init</code> 完成初始化</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rt_timer_init(<span class="keyword">rt_timer_t</span> timer,</span><br><span class="line">                           <span class="keyword">void</span> (*timeout)(<span class="keyword">void</span> *parameter),</span><br><span class="line">                           <span class="keyword">void</span>      *parameter,</span><br><span class="line">                           <span class="keyword">rt_tick_t</span>  time,</span><br><span class="line">                           <span class="keyword">rt_uint8_t</span> flag)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set flag */</span></span><br><span class="line">    timer-&gt;parent.flag  = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set deactivated */</span></span><br><span class="line">    timer-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;</span><br><span class="line"></span><br><span class="line">    timer-&gt;timeout_func = timeout;</span><br><span class="line">    timer-&gt;parameter    = parameter;</span><br><span class="line"></span><br><span class="line">    timer-&gt;timeout_tick = <span class="number">0</span>;</span><br><span class="line">    timer-&gt;init_tick    = time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize timer list */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RT_TIMER_SKIP_LIST_LEVEL; i++)</span><br><span class="line">    {</span><br><span class="line">        rt_list_init(&amp;(timer-&gt;row[i]));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 flag 為 decativated，設定 timeout_func、tick、timerlist</li></ul><hr><h3 id="動態記憶體管理">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 timer</td><td>timer</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>*timeout</code></th><th><code>*parameter</code></th><th><code>time</code></th><th><code>flag</code></th></tr></thead><tbody><tr><td>名字</td><td>timeout function</td><td>func 的參數</td><td>timeout 初始 tick</td><td>狀態</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a timer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of timer</span></span><br><span class="line"><span class="comment"> * @param timeout the timeout function</span></span><br><span class="line"><span class="comment"> * @param parameter the parameter of timeout function</span></span><br><span class="line"><span class="comment"> * @param time the tick of timer</span></span><br><span class="line"><span class="comment"> * @param flag the flag of timer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created timer object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_timer_t</span> rt_timer_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                           <span class="keyword">void</span> (*timeout)(<span class="keyword">void</span> *parameter),</span><br><span class="line">                           <span class="keyword">void</span>       *parameter,</span><br><span class="line">                           <span class="keyword">rt_tick_t</span>   time,</span><br><span class="line">                           <span class="keyword">rt_uint8_t</span>  flag)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> *<span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a object */</span></span><br><span class="line">    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);</span><br><span class="line">    <span class="keyword">if</span> (timer == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _rt_timer_init(timer, timeout, parameter, time, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>同樣也是透過 <code>_rt_timer_init</code> 完成動作</li></ul><hr><h2 id="刪除-timer">刪除 timer<a class="header-anchor" href="#刪除-timer">#</a></h2><h3 id="動態記憶體管理-v2">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v2">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>timer</code></th></tr></thead><tbody><tr><td>刪除 timer</td><td><code>RT_EOK</code></td><td>欲刪除的 timer</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a timer and release timer memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timer the timer to be deleted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK; RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_timer_delete(<span class="keyword">rt_timer_t</span> timer)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* timer check */</span></span><br><span class="line">    RT_ASSERT(timer != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;timer-&gt;parent) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    _rt_timer_remove(timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    rt_object_delete((<span class="keyword">rt_object_t</span>)timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>_rt_timer_remove</code> 移除鏈結</li><li>透過 <code>rt_object_delete</code> 移除 timer</li></ul><hr><h3 id="靜態記憶體管理-v2">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v2">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>timer</code></th></tr></thead><tbody><tr><td>刪除 timer</td><td>tick 值</td><td>欲刪除的 timer</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a timer from timer management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timer the static timer object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK; RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_timer_detach(<span class="keyword">rt_timer_t</span> timer)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* timer check */</span></span><br><span class="line">    RT_ASSERT(timer != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject(&amp;timer-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    _rt_timer_remove(timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span>  rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    rt_object_detach((<span class="keyword">rt_object_t</span>)timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>_rt_timer_remove</code> 移除鏈結</li><li>透過 <code>rt_object_detach</code> 移除 timer</li></ul><hr><h2 id="啟動、停止-timer">啟動、停止 timer<a class="header-anchor" href="#啟動、停止-timer">#</a></h2><h3 id="Code-rt-timer-start">Code: rt_timer_start<a class="header-anchor" href="#Code-rt-timer-start">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>timer</code></th></tr></thead><tbody><tr><td>啟動 timer</td><td><code>RT_EOK</code></td><td>欲啟動的 timer</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will start the timer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timer the timer to be started</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_timer_start(<span class="keyword">rt_timer_t</span> timer)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> row_lvl;</span><br><span class="line">    <span class="keyword">rt_list_t</span> *timer_list;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line">    <span class="keyword">rt_list_t</span> *row_head[RT_TIMER_SKIP_LIST_LEVEL];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tst_nr;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> random_nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* timer check */</span></span><br><span class="line">    RT_ASSERT(timer != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop timer firstly */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* remove timer from list */</span></span><br><span class="line">    _rt_timer_remove(timer);</span><br><span class="line">    <span class="comment">/* change status of timer */</span></span><br><span class="line">    timer-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;</span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要，先停止 timer</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line">RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(timer-&gt;parent)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get timeout tick,</span></span><br><span class="line"><span class="comment"> * the max timeout tick shall not great than RT_TICK_MAX/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RT_ASSERT(timer-&gt;init_tick &lt; RT_TICK_MAX / <span class="number">2</span>);</span><br><span class="line">timer-&gt;timeout_tick = rt_tick_get() + timer-&gt;init_tick;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* disable interrupt */</span></span><br><span class="line">level = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 timer 的 <code>timeout_tick</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_TIMER_SOFT</span></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;parent.flag &amp; RT_TIMER_FLAG_SOFT_TIMER)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* insert timer to soft timer list */</span></span><br><span class="line">        timer_list = rt_soft_timer_list;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* insert timer to system timer list */</span></span><br><span class="line">        timer_list = rt_timer_list;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    row_head[<span class="number">0</span>]  = &amp;timer_list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (row_lvl = <span class="number">0</span>; row_lvl &lt; RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (; row_head[row_lvl] != timer_list[row_lvl].prev;</span><br><span class="line">             row_head[row_lvl]  = row_head[row_lvl]-&gt;next)</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> *<span class="title">t</span>;</span></span><br><span class="line">            <span class="keyword">rt_list_t</span> *p = row_head[row_lvl]-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* fix up the entry pointer */</span></span><br><span class="line">            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have two timers that timeout at the same time, it's</span></span><br><span class="line"><span class="comment">             * preferred that the timer inserted early get called early.</span></span><br><span class="line"><span class="comment">             * So insert the new timer to the end the the some-timeout timer</span></span><br><span class="line"><span class="comment">             * list.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((t-&gt;timeout_tick - timer-&gt;timeout_tick) == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((t-&gt;timeout_tick - timer-&gt;timeout_tick) &lt; RT_TICK_MAX / <span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>)</span><br><span class="line">            row_head[row_lvl + <span class="number">1</span>] = row_head[row_lvl] + <span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>尋找 timer 正確的位置</li></ul><div class="alert alert-secondary"><p>如果有一樣的 timeout，將此 timer 插到最後</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Interestingly, this super simple timer insert counter works very very</span></span><br><span class="line"><span class="comment">     * well on distributing the list height uniformly. By means of "very very</span></span><br><span class="line"><span class="comment">     * well", I mean it beats the randomness of timer-&gt;timeout_tick very easily</span></span><br><span class="line"><span class="comment">     * (actually, the timeout_tick is not random and easy to be attacked). */</span></span><br><span class="line">    random_nr++;</span><br><span class="line">    tst_nr = random_nr;</span><br><span class="line"></span><br><span class="line">    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>],</span><br><span class="line">                         &amp;(timer-&gt;row[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (row_lvl = <span class="number">2</span>; row_lvl &lt;= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!(tst_nr &amp; RT_TIMER_SKIP_LIST_MASK))</span><br><span class="line">            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],</span><br><span class="line">                                 &amp;(timer-&gt;row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Shift over the bits we have tested. Works well with 1 bit and 2</span></span><br><span class="line"><span class="comment">         * bits. */</span></span><br><span class="line">        tst_nr &gt;&gt;= (RT_TIMER_SKIP_LIST_MASK + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    timer-&gt;parent.flag |= RT_TIMER_FLAG_ACTIVATED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_TIMER_SOFT</span></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;parent.flag &amp; RT_TIMER_FLAG_SOFT_TIMER)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* check whether timer thread is ready */</span></span><br><span class="line">        <span class="keyword">if</span> ((timer_thread.stat &amp; RT_THREAD_STAT_MASK) != RT_THREAD_READY)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* resume timer thread to check soft timer */</span></span><br><span class="line">            rt_thread_resume(&amp;timer_thread);</span><br><span class="line">            rt_schedule();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_start);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著插入 timer 並啟動</li></ul><hr><h3 id="Code-rt-timer-stop">Code: rt_timer_stop<a class="header-anchor" href="#Code-rt-timer-stop">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>timer</code></th></tr></thead><tbody><tr><td>停止 timer</td><td><code>RT_EOK</code></td><td>欲刪除的 timer</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will stop the timer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timer the timer to be stopped</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_timer_stop(<span class="keyword">rt_timer_t</span> timer)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* timer check */</span></span><br><span class="line">    RT_ASSERT(timer != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(timer-&gt;parent.flag &amp; RT_TIMER_FLAG_ACTIVATED))</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&amp;(timer-&gt;parent)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    _rt_timer_remove(timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change stat */</span></span><br><span class="line">    timer-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_stop);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將 timer 從鏈結移出，再將 flag 設為 <code>RT_TIMER_FLAG_DEACTIVATED </code></li></ul><hr><h2 id="控制-timer">控制 timer<a class="header-anchor" href="#控制-timer">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>控制 timer</td><td>tick 值</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>timer</code></th><th><code>cmd</code></th><th><code>*arg</code></th></tr></thead><tbody><tr><td>欲控制的 timer</td><td>動作</td><td>根據前面動作的參數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will get or set some options of the timer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timer the timer to be get or set</span></span><br><span class="line"><span class="comment"> * @param cmd the control command</span></span><br><span class="line"><span class="comment"> * @param arg the argument</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_timer_control(<span class="keyword">rt_timer_t</span> timer, <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* timer check */</span></span><br><span class="line">    RT_ASSERT(timer != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RT_TIMER_CTRL_GET_TIME:</span><br><span class="line">        *(<span class="keyword">rt_tick_t</span> *)arg = timer-&gt;init_tick;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要尋找 timer 的值，將 <code>arg</code> 設為 <code>init_tick</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> RT_TIMER_CTRL_SET_TIME:</span><br><span class="line">    timer-&gt;init_tick = *(<span class="keyword">rt_tick_t</span> *)arg;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果需要設定 tick，將 <code>init_tick</code> 設為 <code>arg</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> RT_TIMER_CTRL_SET_ONESHOT:</span><br><span class="line">    timer-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_PERIODIC;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>如果要設定 timer 為一次性的，添加 <code>RT_TIMER_FLAG_ONE_SHOT</code> 的 flag（即為 <code>~RT_TIMER_FLAG_PERIODIC</code>）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> RT_TIMER_CTRL_SET_PERIODIC:</span><br><span class="line">        timer-&gt;parent.flag |= RT_TIMER_FLAG_PERIODIC;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_timer_control);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果要設定 timer 為週期性的，添加 <code>RT_TIMER_FLAG_PERIODIC</code></li></ul><hr><h2 id="檢查-timer">檢查 timer<a class="header-anchor" href="#檢查-timer">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>檢查 timer list</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will check timer list, if a timeout event happens, the</span></span><br><span class="line"><span class="comment"> * corresponding timeout function will be invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note this function shall be invoked in operating system timer interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_timer_check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="keyword">rt_tick_t</span> current_tick;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_TIMER, (<span class="string">"timer check enter\n"</span>));</span><br><span class="line"></span><br><span class="line">    current_tick = rt_tick_get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!rt_list_isempty(&amp;rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>]))</span><br><span class="line">    {</span><br><span class="line">        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>].next,</span><br><span class="line">                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * It supposes that the new tick shall less than the half duration of</span></span><br><span class="line"><span class="comment">         * tick max.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX / <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* remove timer from timer list firstly */</span></span><br><span class="line">            _rt_timer_remove(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* call timeout function */</span></span><br><span class="line">            t-&gt;timeout_func(t-&gt;parameter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* re-get tick */</span></span><br><span class="line">            current_tick = rt_tick_get();</span><br><span class="line"></span><br><span class="line">            RT_DEBUG_LOG(RT_DEBUG_TIMER, (<span class="string">"current tick: %d\n"</span>, current_tick));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((t-&gt;parent.flag &amp; RT_TIMER_FLAG_PERIODIC) &amp;&amp;</span><br><span class="line">                (t-&gt;parent.flag &amp; RT_TIMER_FLAG_ACTIVATED))</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* start it */</span></span><br><span class="line">                t-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;</span><br><span class="line">                rt_timer_start(t);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/* stop timer */</span></span><br><span class="line">                t-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_TIMER, (<span class="string">"timer check leave\n"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> timer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Thread</title>
      <link href="/posts/RT-Thread/thread.html"/>
      <url>/posts/RT-Thread/thread.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> rtdef.h</p></div><h2 id="結構">結構<a class="header-anchor" href="#結構">#</a></h2><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* rt object */</span></span><br><span class="line">    <span class="keyword">char</span>        name[RT_NAME_MAX];                      <span class="comment">/**&lt; the name of thread */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  type;                                   <span class="comment">/**&lt; type of object */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  flags;                                  <span class="comment">/**&lt; thread's flags */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="keyword">void</span>       *module_id;                              <span class="comment">/**&lt; id of application module */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>一些基本資料，如名字等</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_list_t</span>   <span class="built_in">list</span>;                                   <span class="comment">/**&lt; the object list */</span></span><br><span class="line"><span class="keyword">rt_list_t</span>   tlist;                                  <span class="comment">/**&lt; the thread list */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>兩條鏈：thread list、object list</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stack point and entry */</span></span><br><span class="line"><span class="keyword">void</span>       *sp;                                     <span class="comment">/**&lt; stack point */</span></span><br><span class="line"><span class="keyword">void</span>       *entry;                                  <span class="comment">/**&lt; entry */</span></span><br><span class="line"><span class="keyword">void</span>       *parameter;                              <span class="comment">/**&lt; parameter */</span></span><br><span class="line"><span class="keyword">void</span>       *stack_addr;                             <span class="comment">/**&lt; stack address */</span></span><br><span class="line"><span class="keyword">rt_uint32_t</span> stack_size;                             <span class="comment">/**&lt; stack size */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>stack 相關的</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* error code */</span></span><br><span class="line"><span class="keyword">rt_err_t</span>    error;                                  <span class="comment">/**&lt; error code */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_uint8_t</span>  stat;                                   <span class="comment">/**&lt; thread status */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>狀態，下面會列出來所有可能</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* priority */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  current_priority;                       <span class="comment">/**&lt; current priority */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  init_priority;                          <span class="comment">/**&lt; initialized priority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  number;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  high_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> number_mask;</span><br></pre></td></tr></tbody></table></figure><ul><li>與權限相關的</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(RT_USING_EVENT)</span></span><br><span class="line">    <span class="comment">/* thread event */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> event_set;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span>  event_info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(RT_USING_SIGNALS)</span></span><br><span class="line">    <span class="keyword">rt_sigset_t</span>     sig_pending;                        <span class="comment">/**&lt; the pending signals */</span></span><br><span class="line">    <span class="keyword">rt_sigset_t</span>     sig_mask;                           <span class="comment">/**&lt; the mask bits of signal */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>            *sig_ret;                           <span class="comment">/**&lt; the return stack pointer from signal */</span></span><br><span class="line">    <span class="keyword">rt_sighandler_t</span> *sig_vectors;                       <span class="comment">/**&lt; vectors of signal handler */</span></span><br><span class="line">    <span class="keyword">void</span>            *si_list;                           <span class="comment">/**&lt; the signal infor list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_ubase_t</span>  init_tick;                              <span class="comment">/**&lt; thread's initialized tick */</span></span><br><span class="line">    <span class="keyword">rt_ubase_t</span>  remaining_tick;                         <span class="comment">/**&lt; remaining tick */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> <span class="title">thread_timer</span>;</span>                       <span class="comment">/**&lt; built-in thread timer */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>event、sig、tick</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">void</span> (*cleanup)(struct rt_thread *tid);             <span class="comment">/**&lt; cleanup function when thread exit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* light weight process if present */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_LWP</span></span><br><span class="line">    <span class="keyword">void</span>        *lwp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> user_data;                             <span class="comment">/**&lt; private user data beyond this thread */</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">rt_thread_t</span>;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>cleanup</code> 函數及 <code>user_data</code></li></ul><hr><h2 id="狀態">狀態<a class="header-anchor" href="#狀態">#</a></h2><ul><li>一共有 6 種狀態</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_INIT                  0x00                <span class="comment">/**&lt; Initialized status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_READY                 0x01                <span class="comment">/**&lt; Ready status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_SUSPEND               0x02                <span class="comment">/**&lt; Suspend status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_RUNNING               0x03                <span class="comment">/**&lt; Running status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_BLOCK                 RT_THREAD_SUSPEND   <span class="comment">/**&lt; Blocked status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_CLOSE                 0x04                <span class="comment">/**&lt; Closed status */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RT_THREAD_STAT_MASK             0x0f</span></span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> thread.h</p></div><ul><li>下圖為官方文本的 thread 流向圖，接著一個一個的看下去<br><div class="img-item" data-src="https://i.imgur.com/bysM6mg.png" data-sub-html=".caption"><img src="https://i.imgur.com/bysM6mg.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li></ul><hr><h2 id="初始化、建立-thread">初始化、建立 thread<a class="header-anchor" href="#初始化、建立-thread">#</a></h2><h3 id="靜態記憶體管理">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 thread</td><td><code>RT-EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*thread</code></th><th><code>*name</code></th><th><code>*entry</code></th><th><code>*parameter</code></th></tr></thead><tbody><tr><td>thread 本體</td><td>名字</td><td>要執行的副程式</td><td>副程式參數</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*stack_start</code></th><th><code>stack_size</code></th><th><code>priority</code></th><th><code>tick</code></th></tr></thead><tbody><tr><td>thread 堆疊起點</td><td>thread 堆疊大小</td><td>優先級</td><td>可執行的 tick 數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will initialize a thread, normally it's used to initialize a</span></span><br><span class="line"><span class="comment"> * static thread object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the static thread object</span></span><br><span class="line"><span class="comment"> * @param name the name of thread, which shall be unique</span></span><br><span class="line"><span class="comment"> * @param entry the entry function of thread</span></span><br><span class="line"><span class="comment"> * @param parameter the parameter of thread enter function</span></span><br><span class="line"><span class="comment"> * @param stack_start the start address of thread stack</span></span><br><span class="line"><span class="comment"> * @param stack_size the size of thread stack</span></span><br><span class="line"><span class="comment"> * @param priority the priority of thread</span></span><br><span class="line"><span class="comment"> * @param tick the time slice if there are same priority thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_init(struct rt_thread *thread,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span>       *name,</span><br><span class="line">                        <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *parameter),</span><br><span class="line">                        <span class="keyword">void</span>             *parameter,</span><br><span class="line">                        <span class="keyword">void</span>             *stack_start,</span><br><span class="line">                        <span class="keyword">rt_uint32_t</span>       stack_size,</span><br><span class="line">                        <span class="keyword">rt_uint8_t</span>        priority,</span><br><span class="line">                        <span class="keyword">rt_uint32_t</span>       tick)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(stack_start != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread object */</span></span><br><span class="line">    rt_object_init((<span class="keyword">rt_object_t</span>)thread, RT_Object_Class_Thread, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _rt_thread_init(thread,</span><br><span class="line">                           name,</span><br><span class="line">                           entry,</span><br><span class="line">                           parameter,</span><br><span class="line">                           stack_start,</span><br><span class="line">                           stack_size,</span><br><span class="line">                           priority,</span><br><span class="line">                           tick);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_init);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>_rt_thread_init</code> 完成初始化</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 thread</td><td>RT_EOK</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*thread</code></th><th><code>*name</code></th><th><code>*entry</code></th><th><code>*parameter</code></th></tr></thead><tbody><tr><td>thread 本體</td><td>名字</td><td>要執行的副程式</td><td>副程式參數</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*stack_start</code></th><th><code>stack_size</code></th><th><code>priority</code></th><th><code>tick</code></th></tr></thead><tbody><tr><td>thread 堆疊起點</td><td>thread 堆疊大小</td><td>優先級</td><td>可執行的 tick 數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rt_thread_init(struct rt_thread *thread,</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">char</span>       *name,</span><br><span class="line">                                <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *parameter),</span><br><span class="line">                                <span class="keyword">void</span>             *parameter,</span><br><span class="line">                                <span class="keyword">void</span>             *stack_start,</span><br><span class="line">                                <span class="keyword">rt_uint32_t</span>       stack_size,</span><br><span class="line">                                <span class="keyword">rt_uint8_t</span>        priority,</span><br><span class="line">                                <span class="keyword">rt_uint32_t</span>       tick)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* init thread list */</span></span><br><span class="line">    rt_list_init(&amp;(thread-&gt;tlist));</span><br><span class="line"></span><br><span class="line">    thread-&gt;entry = (<span class="keyword">void</span> *)entry;</span><br><span class="line">    thread-&gt;parameter = parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stack init */</span></span><br><span class="line">    thread-&gt;stack_addr = stack_start;</span><br><span class="line">    thread-&gt;stack_size = stack_size;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將傳入的資料填入結構</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init thread stack */</span></span><br><span class="line">rt_memset(thread-&gt;stack_addr, <span class="string">'#'</span>, thread-&gt;stack_size);</span><br><span class="line">thread-&gt;sp = (<span class="keyword">void</span> *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,</span><br><span class="line">                                      (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)thread-&gt;stack_addr + thread-&gt;stack_size - <span class="number">4</span>),</span><br><span class="line">                                      (<span class="keyword">void</span> *)rt_thread_exit);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著設定堆疊，使用 <code>rt_hw_stack_init</code> 來完成（根據不同 cpu 有不同的方式，<code>rt_hw_stack_init</code> 在 /libcpu 中針對不同的 cpu 有不同的函式宣告）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* priority init */</span></span><br><span class="line">    RT_ASSERT(priority &lt; RT_THREAD_PRIORITY_MAX);</span><br><span class="line">    thread-&gt;init_priority    = priority;</span><br><span class="line">    thread-&gt;current_priority = priority;</span><br><span class="line"></span><br><span class="line">    thread-&gt;number_mask = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">    thread-&gt;number = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;high_mask = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>設定 priority 及 mask</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* tick init */</span></span><br><span class="line">    thread-&gt;init_tick      = tick;</span><br><span class="line">    thread-&gt;remaining_tick = tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error and flags */</span></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line">    thread-&gt;stat  = RT_THREAD_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize cleanup function and user data */</span></span><br><span class="line">    thread-&gt;cleanup   = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;user_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread timer */</span></span><br><span class="line">    rt_timer_init(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                  thread-&gt;name,</span><br><span class="line">                  rt_thread_timeout,</span><br><span class="line">                  thread,</span><br><span class="line">                  <span class="number">0</span>,</span><br><span class="line">                  RT_TIMER_FLAG_ONE_SHOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize signal */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_SIGNALS</span></span><br><span class="line">    thread-&gt;sig_mask    = <span class="number">0x00</span>;</span><br><span class="line">    thread-&gt;sig_pending = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    thread-&gt;sig_ret     = RT_NULL;</span><br><span class="line">    thread-&gt;sig_vectors = RT_NULL;</span><br><span class="line">    thread-&gt;si_list     = RT_NULL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_LWP</span></span><br><span class="line">    thread-&gt;lwp = RT_NULL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後依序完成 tick、sig、hook 等的初始化</li></ul><hr><h3 id="動態記憶體管理">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 thread</td><td>thread</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*name</code></th><th><code>*entry</code></th><th><code>*parameter</code></th></tr></thead><tbody><tr><td>名字</td><td>要執行的副程式</td><td>副程式參數</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*stack_start</code></th><th><code>stack_size</code></th><th><code>priority</code></th><th><code>tick</code></th></tr></thead><tbody><tr><td>thread 堆疊起點</td><td>thread 堆疊大小</td><td>優先級</td><td>可執行的 tick 數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will create a thread object and allocate thread object memory</span></span><br><span class="line"><span class="comment"> * and stack.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name the name of thread, which shall be unique</span></span><br><span class="line"><span class="comment"> * @param entry the entry function of thread</span></span><br><span class="line"><span class="comment"> * @param parameter the parameter of thread enter function</span></span><br><span class="line"><span class="comment"> * @param stack_size the size of thread stack</span></span><br><span class="line"><span class="comment"> * @param priority the priority of thread</span></span><br><span class="line"><span class="comment"> * @param tick the time slice if there are same priority thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the created thread object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_thread_t</span> rt_thread_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                             <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *parameter),</span><br><span class="line">                             <span class="keyword">void</span>       *parameter,</span><br><span class="line">                             <span class="keyword">rt_uint32_t</span> stack_size,</span><br><span class="line">                             <span class="keyword">rt_uint8_t</span>  priority,</span><br><span class="line">                             <span class="keyword">rt_uint32_t</span> tick)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *stack_start;</span><br><span class="line"></span><br><span class="line">    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,</span><br><span class="line">                                                    name);</span><br><span class="line">    <span class="keyword">if</span> (thread == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line"></span><br><span class="line">    stack_start = (<span class="keyword">void</span> *)RT_KERNEL_MALLOC(stack_size);</span><br><span class="line">    <span class="keyword">if</span> (stack_start == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* allocate stack failure */</span></span><br><span class="line">        rt_object_delete((<span class="keyword">rt_object_t</span>)thread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RT_NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    _rt_thread_init(thread,</span><br><span class="line">                    name,</span><br><span class="line">                    entry,</span><br><span class="line">                    parameter,</span><br><span class="line">                    stack_start,</span><br><span class="line">                    stack_size,</span><br><span class="line">                    priority,</span><br><span class="line">                    tick);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_create);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先 allocate 一塊給 thread，一塊給堆疊</li><li>再呼叫 <code>_rt_thread_init</code> 完成初始化</li></ul><hr><h2 id="啟動-thread">啟動 thread<a class="header-anchor" href="#啟動-thread">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>thread</code></th></tr></thead><tbody><tr><td>啟動 thread</td><td><code>RT_EOK</code></td><td>欲啟動的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will start a thread and put it to system ready queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be started</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_startup(<span class="keyword">rt_thread_t</span> thread)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT((thread-&gt;stat &amp; RT_THREAD_STAT_MASK) == RT_THREAD_INIT);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set current priority to init priority */</span></span><br><span class="line">    thread-&gt;current_priority = thread-&gt;init_priority;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 priority</li></ul><figure class="highlight c"><figcaption><span>268</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/* calculate priority attribute */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">    thread-&gt;number      = thread-&gt;current_priority &gt;&gt; <span class="number">3</span>;            <span class="comment">/* 5bit */</span></span><br><span class="line">    thread-&gt;number_mask = <span class="number">1L</span> &lt;&lt; thread-&gt;number;</span><br><span class="line">    thread-&gt;high_mask   = <span class="number">1L</span> &lt;&lt; (thread-&gt;current_priority &amp; <span class="number">0x07</span>);  <span class="comment">/* 3bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    thread-&gt;number_mask = <span class="number">1L</span> &lt;&lt; thread-&gt;current_priority;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>這些參數是用來計算權限的，<code>scheudler</code> 會用到</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">    RT_DEBUG_LOG(RT_DEBUG_THREAD, (<span class="string">"startup a thread:%s with priority:%d\n"</span>,</span><br><span class="line">                                   thread-&gt;name, thread-&gt;init_priority));</span><br><span class="line">    <span class="comment">/* change thread stat */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_SUSPEND;</span><br><span class="line">    <span class="comment">/* then resume it */</span></span><br><span class="line">    rt_thread_resume(thread);</span><br><span class="line">    <span class="keyword">if</span> (rt_thread_self() != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* do a scheduling */</span></span><br><span class="line">        rt_schedule();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_startup);</span><br></pre></td></tr></tbody></table></figure><ul><li>最後將 stat 設為 <code>RT_THREAD_SUSPEND</code>，再透過 <code>rt_thread_resume</code> 來完成啟動</li><li>啟動完成後呼叫 <code>rt_scheduler()</code> 來執行一次調度</li></ul><hr><h2 id="暫停、復原-thread">暫停、復原 thread<a class="header-anchor" href="#暫停、復原-thread">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*thread</code></th></tr></thead><tbody><tr><td>暫停 thread</td><td><code>RT-EOK</code></td><td>欲暫停的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will suspend the specified thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be suspended</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note if suspend self thread, after this function call, the</span></span><br><span class="line"><span class="comment"> * rt_schedule() must be invoked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_suspend(<span class="keyword">rt_thread_t</span> thread)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_THREAD, (<span class="string">"thread suspend:  %s\n"</span>, thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((thread-&gt;stat &amp; RT_THREAD_STAT_MASK) != RT_THREAD_READY)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_THREAD, (<span class="string">"thread suspend: thread disorder, 0x%2x\n"</span>,</span><br><span class="line">                                       thread-&gt;stat));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change thread stat */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_SUSPEND | (thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);</span><br><span class="line">    rt_schedule_remove_thread(thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop thread timer anyway */</span></span><br><span class="line">    rt_timer_stop(&amp;(thread-&gt;thread_timer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread));</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_suspend);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將狀態修改為 <code>RT_THREAD_SUSPEND</code>，接著將 thread 從 tlist 移除，結束 timer</li></ul><hr><p><i class="fa fa-code"></i> Code: <code>rt_thread_delay</code></p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>tick</code></th></tr></thead><tbody><tr><td>延遲 thread</td><td><code>RT-EOK</code></td><td>欲延遲的時間</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will let current thread delay for some ticks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param tick the delay ticks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_delay(<span class="keyword">rt_tick_t</span> tick)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> rt_thread_sleep(tick);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_delay);</span><br></pre></td></tr></tbody></table></figure><ul><li>透過 <code>rt_thread_sleep</code> 實作</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>使 thread 休眠</td><td><code>RT-EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>tick</code></th></tr></thead><tbody><tr><td>欲睡眠的時間</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will let current thread sleep for some ticks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param tick the sleep ticks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_sleep(<span class="keyword">rt_tick_t</span> tick)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* set to current thread */</span></span><br><span class="line">    thread = rt_current_thread;</span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* suspend thread */</span></span><br><span class="line">    rt_thread_suspend(thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset the timeout of thread timer and start it */</span></span><br><span class="line">    rt_timer_control(&amp;(thread-&gt;thread_timer), RT_TIMER_CTRL_SET_TIME, &amp;tick);</span><br><span class="line">    rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    rt_schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clear error number of this thread to RT_EOK */</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;error == -RT_ETIMEOUT)</span><br><span class="line">        thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="復原-thread">復原 thread<a class="header-anchor" href="#復原-thread">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*thread</code></th></tr></thead><tbody><tr><td>復原 thread</td><td><code>RT-EOK</code></td><td>欲復原的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will resume a thread and put it to system ready queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be resumed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_resume(<span class="keyword">rt_thread_t</span> thread)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_THREAD, (<span class="string">"thread resume:  %s\n"</span>, thread-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((thread-&gt;stat &amp; RT_THREAD_STAT_MASK) != RT_THREAD_SUSPEND)</span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_THREAD, (<span class="string">"thread resume: thread disorder, %d\n"</span>,</span><br><span class="line">                                       thread-&gt;stat));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove from suspend list */</span></span><br><span class="line">    rt_list_remove(&amp;(thread-&gt;tlist));</span><br><span class="line"></span><br><span class="line">    rt_timer_stop(&amp;thread-&gt;thread_timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* insert to schedule ready list */</span></span><br><span class="line">    rt_schedule_insert_thread(thread);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_resume);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先從 suspend list 移除，停止 timer，掛回去 ready list</li><li><code>rt_schedule_insert_thread</code> 會將狀態修改成 <code>RT_THREAD_READY</code></li></ul><hr><h2 id="離開、刪除-thread">離開、刪除 thread<a class="header-anchor" href="#離開、刪除-thread">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>暫停 thread</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_thread_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_current_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove from schedule */</span></span><br><span class="line">    rt_schedule_remove_thread(thread);</span><br><span class="line">    <span class="comment">/* change stat */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove it from timer list */</span></span><br><span class="line">    rt_timer_detach(&amp;thread-&gt;thread_timer);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先從 ready list 中移除，修改狀態為 <code>RT_THREAD_CLOSE</code>，從 timer list 中移除</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((rt_object_is_systemobject((<span class="keyword">rt_object_t</span>)thread) == RT_TRUE) &amp;&amp;</span><br><span class="line">        thread-&gt;cleanup == RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        rt_object_detach((<span class="keyword">rt_object_t</span>)thread);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* insert to defunct thread list */</span></span><br><span class="line">        rt_list_insert_after(&amp;rt_thread_defunct, &amp;(thread-&gt;tlist));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* switch to next task */</span></span><br><span class="line">    rt_schedule();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果為系統的 thread，且 <code>cleanup</code> 函式沒有被定義時，呼叫 <code>rt_object_detach</code> 來完成移除的動作</li><li>否則，將 thread 插入至 <code>rt_thread_defunct</code>，此鏈上面的 thread 會由 idle 清除。</li></ul><hr><h3 id="刪除-thread">刪除 thread<a class="header-anchor" href="#刪除-thread">#</a></h3><h4 id="動態記憶體管理-v2">動態記憶體管理<a class="header-anchor" href="#動態記憶體管理-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*thread</code></th></tr></thead><tbody><tr><td>刪除 thread</td><td><code>RT-EOK</code></td><td>欲刪除的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will delete a thread. The thread object will be removed from</span></span><br><span class="line"><span class="comment"> * thread queue and deleted from system object management in the idle thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be deleted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_delete(<span class="keyword">rt_thread_t</span> thread)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject((<span class="keyword">rt_object_t</span>)thread) == RT_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((thread-&gt;stat &amp; RT_THREAD_STAT_MASK) != RT_THREAD_INIT)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* remove from schedule */</span></span><br><span class="line">        rt_schedule_remove_thread(thread);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果此 thread 已經啟動過了，將此 thread 從 ready list 移除</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* release thread timer */</span></span><br><span class="line">    rt_timer_detach(&amp;(thread-&gt;thread_timer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change stat */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    lock = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* insert to defunct thread list */</span></span><br><span class="line">    rt_list_insert_after(&amp;rt_thread_defunct, &amp;(thread-&gt;tlist));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_delete);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著將 timer 還回去，修改狀態為 <code>RT_THREAD_CLOSE</code>，插入至 <code>rt_thread_defunct</code></li></ul><hr><h4 id="靜態記憶體管理-v2">靜態記憶體管理<a class="header-anchor" href="#靜態記憶體管理-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>刪除 thread</td><td><code>RT-EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*thread</code></th></tr></thead><tbody><tr><td>欲刪除的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will detach a thread. The thread object will be removed from</span></span><br><span class="line"><span class="comment"> * thread queue and detached/deleted from system object management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be deleted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the operation status, RT_EOK on OK, -RT_ERROR on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_detach(<span class="keyword">rt_thread_t</span> thread)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">rt_base_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line">    RT_ASSERT(rt_object_is_systemobject((<span class="keyword">rt_object_t</span>)thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((thread-&gt;stat &amp; RT_THREAD_STAT_MASK) != RT_THREAD_INIT)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* remove from schedule */</span></span><br><span class="line">        rt_schedule_remove_thread(thread);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* release thread timer */</span></span><br><span class="line">    rt_timer_detach(&amp;(thread-&gt;thread_timer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change stat */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* detach object */</span></span><br><span class="line">    rt_object_detach((<span class="keyword">rt_object_t</span>)thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;cleanup != RT_NULL)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* disable interrupt */</span></span><br><span class="line">        lock = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* insert to defunct thread list */</span></span><br><span class="line">        rt_list_insert_after(&amp;rt_thread_defunct, &amp;(thread-&gt;tlist));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(lock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_detach);</span><br></pre></td></tr></tbody></table></figure><ul><li>與 delete 不同的差在第32行</li></ul><h2 id="控制-thread">控制 thread<a class="header-anchor" href="#控制-thread">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>控制 thread</td><td><code>RT-EOK</code></td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*thread</code></th><th><code>cmd</code></th><th><code>*argv</code></th></tr></thead><tbody><tr><td>欲控制的 thread</td><td>需執行的動作</td><td>伴隨動作的參數</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will control thread behaviors according to control command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the specified thread to be controlled</span></span><br><span class="line"><span class="comment"> * @param cmd the control command, which includes</span></span><br><span class="line"><span class="comment"> *  RT_THREAD_CTRL_CHANGE_PRIORITY for changing priority level of thread;</span></span><br><span class="line"><span class="comment"> *  RT_THREAD_CTRL_STARTUP for starting a thread;</span></span><br><span class="line"><span class="comment"> *  RT_THREAD_CTRL_CLOSE for delete a thread.</span></span><br><span class="line"><span class="comment"> * @param arg the argument of control command</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return RT_EOK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_control(<span class="keyword">rt_thread_t</span> thread, <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* thread check */</span></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line">    RT_ASSERT(rt_object_get_type((<span class="keyword">rt_object_t</span>)thread) == RT_Object_Class_Thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RT_THREAD_CTRL_CHANGE_PRIORITY:</span><br><span class="line">        <span class="comment">/* disable interrupt */</span></span><br><span class="line">        temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* for ready thread, change queue */</span></span><br><span class="line">        <span class="keyword">if</span> ((thread-&gt;stat &amp; RT_THREAD_STAT_MASK) == RT_THREAD_READY)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* remove thread from schedule queue first */</span></span><br><span class="line">            rt_schedule_remove_thread(thread);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* change thread priority */</span></span><br><span class="line">            thread-&gt;current_priority = *(<span class="keyword">rt_uint8_t</span> *)arg;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* recalculate priority attribute */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">            thread-&gt;number      = thread-&gt;current_priority &gt;&gt; <span class="number">3</span>;            <span class="comment">/* 5bit */</span></span><br><span class="line">            thread-&gt;number_mask = <span class="number">1</span> &lt;&lt; thread-&gt;number;</span><br><span class="line">            thread-&gt;high_mask   = <span class="number">1</span> &lt;&lt; (thread-&gt;current_priority &amp; <span class="number">0x07</span>);   <span class="comment">/* 3bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            thread-&gt;number_mask = <span class="number">1</span> &lt;&lt; thread-&gt;current_priority;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* insert thread to schedule queue again */</span></span><br><span class="line">            rt_schedule_insert_thread(thread);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            thread-&gt;current_priority = *(<span class="keyword">rt_uint8_t</span> *)arg;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* recalculate priority attribute */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">            thread-&gt;number      = thread-&gt;current_priority &gt;&gt; <span class="number">3</span>;            <span class="comment">/* 5bit */</span></span><br><span class="line">            thread-&gt;number_mask = <span class="number">1</span> &lt;&lt; thread-&gt;number;</span><br><span class="line">            thread-&gt;high_mask   = <span class="number">1</span> &lt;&lt; (thread-&gt;current_priority &amp; <span class="number">0x07</span>);   <span class="comment">/* 3bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            thread-&gt;number_mask = <span class="number">1</span> &lt;&lt; thread-&gt;current_priority;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RT_THREAD_CTRL_STARTUP:</span><br><span class="line">        <span class="keyword">return</span> rt_thread_startup(thread);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_HEAP</span></span><br><span class="line">    <span class="keyword">case</span> RT_THREAD_CTRL_CLOSE:</span><br><span class="line">        <span class="keyword">return</span> rt_thread_delete(thread);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_thread_control);</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - RTM_EXPORT</title>
      <link href="/posts/RT-Thread/rtmexpo.html"/>
      <url>/posts/RT-Thread/rtmexpo.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 RT-Thread 的 kernel 中，許多副程式的結尾都有 <code>RTM_EXPORT</code>，如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function will lock the thread scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_enter_critical</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the maximal number of nest is RT_UINT16_MAX, which is big</span></span><br><span class="line"><span class="comment">     * enough and does not check here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rt_scheduler_lock_nest ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">}</span><br><span class="line">RTM_EXPORT(rt_enter_critical);</span><br></pre></td></tr></tbody></table></figure><p><code>RTM_EXPORT</code> 是在 <em>rtm.h</em> 中所定義的一個巨集。</p><h2 id="File-rtm-h">File: rtm.h<a class="header-anchor" href="#File-rtm-h">#</a></h2><ul><li><code>RTM_EXPORT</code> 可被定義的方式有三種：</li></ul><h3 id="1-MSC-VER">1. _MSC_VER<a class="header-anchor" href="#1-MSC-VER">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">"RTMSymTab$f"</span>,read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTM_EXPORT(symbol)                                            \</span></span><br><span class="line">__declspec(allocate(<span class="string">"RTMSymTab$f"</span>))<span class="keyword">const</span> <span class="keyword">char</span> __rtmsym_#<span class="meta">#symbol##_name[] = <span class="meta-string">"__vs_rtm_"</span>#symbol;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/merge:RTMSymTab=mytext"</span>)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-MINGW32">2. __MINGW32_<a class="header-anchor" href="#2-MINGW32">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__MINGW32__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTM_EXPORT(symbol)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-else">3. else<a class="header-anchor" href="#3-else">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTM_EXPORT(symbol)                                            \</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> __rtmsym_#<span class="meta">#symbol##_name[] SECTION(<span class="meta-string">".rodata.name"</span>) = #symbol;     \</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_module_symtab</span> __<span class="title">rtmsym_</span>##<span class="title">symbol</span> <span class="title">SECTION</span>("<span class="title">RTMSymTab</span>")= \</span></span><br><span class="line"><span class="class">{</span>                                                                     \</span><br><span class="line">    (<span class="keyword">void</span> *)&amp;symbol,                                                  \</span><br><span class="line">    __rtmsym_#<span class="meta">#symbol##_name                                          \</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>##</code> 為連字符<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[C/C++ 的預處理定義 : # , #@ , ##](https://blog.xuite.net/jesonchung/scienceview/93554778-C%2FC%2B%2B+的預處理定義+%3A+%23+%2C++%23%40+%2C+%23%23)">[1]</span></a></sup>，作用是將指定文字帶到變數名稱裡；如：當傳進來的 <code>symbol</code> 值是 <code>rt_enter_critical</code> 時，此字串的變數名會被宣告成 <code>__rtmsym_rt_enter_critical_name</code></li><li><code>SECTION</code> 為 <code>__attribute__((section))</code> 的巨集寫法</li><li><code>#</code> 為字串話操作符，作用是將後面的變數轉換成字串；如當傳進來的 <code>symbol</code> 值是 <code>rt_enter_critical</code> 時，<code>#symbol</code> 會被轉換成 <code>"rt_enter_critical"</code></li><li>綜合以上，我們可以將原來的 <code>RTM_EXPORT(rt_enter_critical)</code> 透過 <code>define</code> 轉換成以下程式碼：</li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> __rtmsym_rt_enter_critical_name[] __attribute__((section(<span class="string">".rodata.name"</span>))) \</span><br><span class="line">= <span class="string">"rt_enter_critical"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_module_symtab</span> __<span class="title">rtmsym_rt_enter_critical</span>  \</span></span><br><span class="line"><span class="class"> __<span class="title">attribute__</span>((<span class="title">section</span>("<span class="title">RTMSymTab</span>")))=</span></span><br><span class="line"><span class="class">{</span>                                                                     </span><br><span class="line">    (<span class="keyword">void</span> *)&amp;rt_enter_critical,                                                  </span><br><span class="line">    __rtmsym_rt_enter_critical_name                                          </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_module_symtab</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">void</span>       *addr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="用意">用意<a class="header-anchor" href="#用意">#</a></h2><ul><li>linux 系統中，有 <code>EXPORT_SYMBOL</code>，其中的用意是為了在撰寫程式時能夠方便呼叫這些副程式<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[EXPORT_SYMBOL解析](http://www.cnblogs.com/dyllove98/p/3186967.html)">[2]</span></a></sup>，即<strong>模組化</strong></li></ul><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.xuite.net/jesonchung/scienceview/93554778-C%2FC%2B%2B+%E7%9A%84%E9%A0%90%E8%99%95%E7%90%86%E5%AE%9A%E7%BE%A9+%3A+%23+%2C++%23%40+%2C+%23%23" target="_blank" rel="noopener">C/C++ 的預處理定義 : # , #@ , ##</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://www.cnblogs.com/dyllove98/p/3186967.html" target="_blank" rel="noopener">EXPORT_SYMBOL解析</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread - Scheduler</title>
      <link href="/posts/RT-Thread/scheduler.html"/>
      <url>/posts/RT-Thread/scheduler.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> scheduler.c</p></div><ul><li>於 <em>components.c</em> 中 的 <code>rtthread_startup()</code> 首先呼叫 <code>rt_system_scheduler_init()</code> 初始化 scheduler</li><li>於 <code>rtthread_startup()</code> 的最後呼叫 <code>rt_system_scheduler_start()</code> 開始 scheduler</li></ul><hr><h2 id="初始化-scheduler">初始化 scheduler<a class="header-anchor" href="#初始化-scheduler">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 scheduler</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> * This function will initialize the system scheduler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_scheduler_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> offset;</span><br><span class="line"></span><br><span class="line">    rt_scheduler_lock_nest = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>rt_scheduler_lock_nest</code> 為 scheduler 的鎖，在進入 critical region 時會 <code>++</code>，離開時會 <code>--</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (<span class="string">"start scheduler: max priority 0x%02x\n"</span>,</span><br><span class="line">                                  RT_THREAD_PRIORITY_MAX));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; RT_THREAD_PRIORITY_MAX; offset ++)</span><br><span class="line">{</span><br><span class="line">    rt_list_init(&amp;rt_thread_priority_table[offset]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>RT_THREAD_PRIORITY_MAX</code> 根據不同的 <em>BSP</em> 可設定為不同的值，如 256；即優先級為 0~255，數字越小越等級越高</li><li>初始化 <code>rt_thread_priority_table</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">rt_current_priority = RT_THREAD_PRIORITY_MAX - <span class="number">1</span>;</span><br><span class="line">rt_current_thread = RT_NULL;</span><br></pre></td></tr></tbody></table></figure><ul><li>設定當前的優先級為最低，及空。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* initialize ready priority group */</span></span><br><span class="line">    rt_thread_ready_priority_group = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">    <span class="comment">/* initialize ready table */</span></span><br><span class="line">    rt_memset(rt_thread_ready_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(rt_thread_ready_table));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize thread defunct */</span></span><br><span class="line">    rt_list_init(&amp;rt_thread_defunct);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>初始化 <code>rt_thread_ready_priority_group</code> 及 <code>rt_thread_defunct</code></li></ul><hr><h2 id="啟動-scheduler">啟動 scheduler<a class="header-anchor" href="#啟動-scheduler">#</a></h2><ul><li>此函數會找到一個 priorty 最高的 thread 並執行</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>啟動 scheduler</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ingroup SystemInit</span></span><br><span class="line"><span class="comment"> * This function will startup scheduler. It will select one thread</span></span><br><span class="line"><span class="comment"> * with the highest priority level, then switch to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_scheduler_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> highest_ready_priority;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> number;</span><br><span class="line"></span><br><span class="line">    number = __rt_ffs(rt_thread_ready_priority_group) - <span class="number">1</span>;</span><br><span class="line">    highest_ready_priority = (number &lt;&lt; <span class="number">3</span>) + __rt_ffs(rt_thread_ready_table[number]) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <code>rt_ffs</code> 來尋找 priority 最高的鏈結</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* get switch to thread */</span></span><br><span class="line">    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,</span><br><span class="line">                              struct rt_thread,</span><br><span class="line">                              tlist);</span><br><span class="line"></span><br><span class="line">    rt_current_thread = to_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* switch to new thread */</span></span><br><span class="line">    rt_hw_context_switch_to((<span class="keyword">rt_uint32_t</span>)&amp;to_thread-&gt;sp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* never come back */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>找到該鏈的第一顆，context switch 至該 thread</li></ul><hr><h2 id="Scheduler">Scheduler<a class="header-anchor" href="#Scheduler">#</a></h2><ul><li>呼叫此函式，系統會重新計算所有 thread 的 priority，如果存在更高的（與呼叫此函式的 thread 比較），系統將會 switch 至該 thread。</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>執行一次調度</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will perform one schedule. It will select one thread</span></span><br><span class="line"><span class="comment"> * with the highest priority level, then switch to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">rt_base_t</span> level;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">from_thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    level = rt_hw_interrupt_disable();</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將中斷關閉</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* check the scheduler is enabled or not */</span></span><br><span class="line">    <span class="keyword">if</span> (rt_scheduler_lock_nest == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> highest_ready_priority;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &lt;= 32</span></span><br><span class="line">        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">rt_ubase_t</span> number;</span><br><span class="line"></span><br><span class="line">        number = __rt_ffs(rt_thread_ready_priority_group) - <span class="number">1</span>;</span><br><span class="line">        highest_ready_priority = (number &lt;&lt; <span class="number">3</span>) + __rt_ffs(rt_thread_ready_table[number]) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>檢查鎖的狀態，並找到 priority 最高的鍊</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get switch to thread */</span></span><br><span class="line">to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,</span><br><span class="line">                          struct rt_thread,</span><br><span class="line">                          tlist);</span><br></pre></td></tr></tbody></table></figure><ul><li>找到該鏈的第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* if the destination thread is not the same as current thread */</span></span><br><span class="line">        <span class="keyword">if</span> (to_thread != rt_current_thread)</span><br><span class="line">        {</span><br><span class="line">            rt_current_priority = (<span class="keyword">rt_uint8_t</span>)highest_ready_priority;</span><br><span class="line">            from_thread         = rt_current_thread;</span><br><span class="line">            rt_current_thread   = to_thread;</span><br><span class="line"></span><br><span class="line">            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* switch to new thread */</span></span><br><span class="line">            RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,</span><br><span class="line">                         (<span class="string">"[%d]switch to priority#%d "</span></span><br><span class="line">                          <span class="string">"thread:%.*s(sp:0x%p), "</span></span><br><span class="line">                          <span class="string">"from thread:%.*s(sp: 0x%p)\n"</span>,</span><br><span class="line">                          rt_interrupt_nest, highest_ready_priority,</span><br><span class="line">                          RT_NAME_MAX, to_thread-&gt;name, to_thread-&gt;sp,</span><br><span class="line">                          RT_NAME_MAX, from_thread-&gt;name, from_thread-&gt;sp));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_OVERFLOW_CHECK</span></span><br><span class="line">            _rt_scheduler_stack_check(to_thread);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rt_interrupt_nest == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rt_thread_handle_sig</span><span class="params">(<span class="keyword">rt_bool_t</span> clean_state)</span></span>;</span><br><span class="line"></span><br><span class="line">                rt_hw_context_switch((<span class="keyword">rt_uint32_t</span>)&amp;from_thread-&gt;sp,</span><br><span class="line">                                     (<span class="keyword">rt_uint32_t</span>)&amp;to_thread-&gt;sp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* enable interrupt */</span></span><br><span class="line">                rt_hw_interrupt_enable(level);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_SIGNALS</span></span><br><span class="line">                <span class="comment">/* check signal status */</span></span><br><span class="line">                rt_thread_handle_sig(RT_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到的 thread 與當前的 thread 不相符，且 <code>rt_interrupt_nest == 0</code>，即這次調度不是在中斷下運作的，直接 switch 至該 thread</li><li>最後恢復中斷</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (<span class="string">"switch in interrupt\n"</span>));</span><br><span class="line"></span><br><span class="line">        rt_hw_context_switch_interrupt((<span class="keyword">rt_uint32_t</span>)&amp;from_thread-&gt;sp,</span><br><span class="line">                                       (<span class="keyword">rt_uint32_t</span>)&amp;to_thread-&gt;sp);</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 <code>rt_interrupt_nest != 0</code>，即這次調度是在中斷下運作的，則用中斷 switch 至該 thread</li><li>最後恢復中斷</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(level);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* enable interrupt */</span></span><br><span class="line">        rt_hw_interrupt_enable(level);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果找到的一樣，或是沒要到鎖，直接開啟中斷，結束調度</li></ul><hr><h2 id="插入-thread">插入 thread<a class="header-anchor" href="#插入-thread">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*thread</code></th></tr></thead><tbody><tr><td>將 thread 插入 list</td><td>void</td><td>欲插入的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will insert a thread to system ready queue. The state of</span></span><br><span class="line"><span class="comment"> * thread will be set as READY and remove from suspend queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be inserted</span></span><br><span class="line"><span class="comment"> * @note Please do not invoke this function in user application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_schedule_insert_thread</span><span class="params">(struct rt_thread * thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change stat */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_READY | (thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先關閉中斷，及更改 thread 的狀態為 <code>RT_THREAD_READY</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* insert thread to ready list */</span></span><br><span class="line">rt_list_insert_before(&amp;(rt_thread_priority_table[thread-&gt;current_priority]),</span><br><span class="line">                      &amp;(thread-&gt;tlist));</span><br></pre></td></tr></tbody></table></figure><ul><li>接著呼叫 <code>rt_list_insert_before</code> 將 thread 插到第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* set priority mask */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &lt;= 32</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (<span class="string">"insert thread[%.*s], the priority: %d\n"</span>,</span><br><span class="line">                                      RT_NAME_MAX, thread-&gt;name, thread-&gt;current_priority));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,</span><br><span class="line">                 (<span class="string">"insert thread[%.*s], the priority: %d 0x%x %d\n"</span>,</span><br><span class="line">                  RT_NAME_MAX,</span><br><span class="line">                  thread-&gt;name,</span><br><span class="line">                  thread-&gt;number,</span><br><span class="line">                  thread-&gt;number_mask,</span><br><span class="line">                  thread-&gt;high_mask));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">    rt_thread_ready_table[thread-&gt;number] |= thread-&gt;high_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    rt_thread_ready_priority_group |= thread-&gt;number_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後恢復中斷</li></ul><hr><h2 id="移除-thread">移除 thread<a class="header-anchor" href="#移除-thread">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*thread</code></th></tr></thead><tbody><tr><td>從 list 中移除 thread</td><td>void</td><td>欲移除的 thread</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function will remove a thread from system ready queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param thread the thread to be removed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note Please do not invoke this function in user application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_schedule_remove_thread</span><span class="params">(struct rt_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(thread != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &lt;= 32</span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (<span class="string">"remove thread[%.*s], the priority: %d\n"</span>,</span><br><span class="line">                                      RT_NAME_MAX, thread-&gt;name,</span><br><span class="line">                                      thread-&gt;current_priority));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,</span><br><span class="line">                 (<span class="string">"remove thread[%.*s], the priority: %d 0x%x %d\n"</span>,</span><br><span class="line">                  RT_NAME_MAX,</span><br><span class="line">                  thread-&gt;name,</span><br><span class="line">                  thread-&gt;number,</span><br><span class="line">                  thread-&gt;number_mask,</span><br><span class="line">                  thread-&gt;high_mask));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove thread from ready list */</span></span><br><span class="line">    rt_list_remove(&amp;(thread-&gt;tlist));</span><br></pre></td></tr></tbody></table></figure><ul><li>先關閉中斷，再呼叫 <code>rt_list_remove</code> 來刪除第一顆</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (rt_list_isempty(&amp;(rt_thread_priority_table[thread-&gt;current_priority])))</span><br><span class="line">    {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RT_THREAD_PRIORITY_MAX &gt; 32</span></span><br><span class="line">        rt_thread_ready_table[thread-&gt;number] &amp;= ~thread-&gt;high_mask;</span><br><span class="line">        <span class="keyword">if</span> (rt_thread_ready_table[thread-&gt;number] == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            rt_thread_ready_priority_group &amp;= ~thread-&gt;number_mask;</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        rt_thread_ready_priority_group &amp;= ~thread-&gt;number_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果刪除後，原本的鏈為空，就修改一些參數（在 thread 會討論）</li><li>最後開啟中斷</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> kernel </tag>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread GUI - Framework</title>
      <link href="/posts/RT-Thread/gui.html"/>
      <url>/posts/RT-Thread/gui.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RT-Thread 的 GUI 放在 package 中（<a href="https://github.com/RT-Thread-packages/gui_engine.git" target="_blank" rel="noopener">git 原始碼</a>），本文將簡單將此 GUI engine 分工。</p><h2 id="Font">Font<a class="header-anchor" href="#Font">#</a></h2><p>處理文字編碼，及字型相關的</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">. </span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- asc12font.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- asc16font.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- font_bmp.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- font_fnt.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- font_freetype.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- font_hz_bmp.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- font_hz_file.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- font.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- hz12font.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- hz16font.c</span></span><br><span class="line">|<span class="string"> ˋ-- gb2312.c</span></span><br><span class="line">|</span><br><span class="line">ˋ-- include</span><br><span class="line">  ˋ-- rtgui</span><br><span class="line">    |<span class="string">-- font_fnt.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- font_freetype.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- font.h</span></span><br><span class="line"><span class="string">    ˋ-- gb2312.h</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Image">Image<a class="header-anchor" href="#Image">#</a></h2><p>處理圖片格式相關的</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- blit.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- image_bmp.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- image_jpg.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- image_png.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- image_xpm.c</span></span><br><span class="line">|<span class="string"> ˋ-- image.c</span></span><br><span class="line">|</span><br><span class="line">ˋ-- include</span><br><span class="line">  ˋ-- rtgui</span><br><span class="line">    |<span class="string">-- bilt.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- image_bmp.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- image_container.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- image_hdc.h</span></span><br><span class="line"><span class="string">    ˋ-- image.h</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Draw">Draw<a class="header-anchor" href="#Draw">#</a></h2><p>協助使用者繪製一些圖形等</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- color.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- dc_blend.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- dc_duffer.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- dc_client.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- dc_hw.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- dc_rotozoom.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- dc_trans.c</span></span><br><span class="line">|<span class="string"> ˋ-- dc.c</span></span><br><span class="line">|</span><br><span class="line">ˋ-- include</span><br><span class="line">  ˋ-- rtgui</span><br><span class="line">    |<span class="string">-- color.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- dc_draw.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- dc_trans.h</span></span><br><span class="line"><span class="string">    ˋ-- dc.h</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Widgets">Widgets<a class="header-anchor" href="#Widgets">#</a></h2><p>一些相關的 widgets，如按鈕、視窗等</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- box.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- container.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- matrix.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- region.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- title.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- topwin.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- topwin.h</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- widgets.c</span></span><br><span class="line">|<span class="string"> ˋ-- window.c</span></span><br><span class="line">|</span><br><span class="line">ˋ-- include</span><br><span class="line">  ˋ-- rtgui</span><br><span class="line">    ˋ-- widgets</span><br><span class="line">      |<span class="string">-- box.h</span></span><br><span class="line"><span class="string">      </span>|<span class="string">-- container.h</span></span><br><span class="line"><span class="string">      </span>|<span class="string">-- matrix.h</span></span><br><span class="line"><span class="string">      </span>|<span class="string">-- region.h</span></span><br><span class="line"><span class="string">      </span>|<span class="string">-- title.h</span></span><br><span class="line"><span class="string">      </span>|<span class="string">-- widget.h</span></span><br><span class="line"><span class="string">      ˋ-- window.h</span></span><br></pre></td></tr></tbody></table></figure><h2 id="System">System<a class="header-anchor" href="#System">#</a></h2><p>系統層面的工作、及協助外部硬體，如鍵盤等。</p><figure class="highlight gherkin"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- filerw.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- mouse.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- mouse.h</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- server.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- rtgui_app.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- rtgui_driver.c</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">-- rtgui_object.c</span></span><br><span class="line">|<span class="string"> ˋ-- rtgui_system.c</span></span><br><span class="line">|</span><br><span class="line">ˋ-- include</span><br><span class="line">  ˋ-- rtgui</span><br><span class="line">    |<span class="string">-- driver.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- event.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- filerw.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- kbddef.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- list.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- rtgui_app.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- rtgui_config.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- rtgui_object.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- rtgui_server.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- rtgui_system.h</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- rtgui.h</span></span><br><span class="line"><span class="string">    ˋ-- tree.h</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 更改家目錄位置</title>
      <link href="/posts/linux/change-home-partition.html"/>
      <url>/posts/linux/change-home-partition.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前為了解決我的問題，上網<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Partitioning/Home/Moving](https://help.ubuntu.com/community/Partitioning/Home/Moving)">[1]</span></a></sup>找到的解答，紀錄一下。</p><h2 id="1-找到目標分割的-UUID">1. 找到目標分割的 UUID<a class="header-anchor" href="#1-找到目標分割的-UUID">#</a></h2><ul><li>command:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></tbody></table></figure><ul><li>result:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">/dev/sda1: UUID="1a2b3c4d-1a2b-1a2b-1a2b-1a2b3c4d5e6f" TYPE="ext4" PARTUUID="12345678-01"</span><br></pre></td></tr></tbody></table></figure><ul><li>其中 <code>UUID="1a2b3c4d-1a2b-1a2b-1a2b-1a2b3c4d5e6f"</code> 為此分割的 UUID，記著。</li></ul><hr><h2 id="2-設定-fstab">2. 設定 fstab<a class="header-anchor" href="#2-設定-fstab">#</a></h2><p>fstab 是用來設定開機時哪些分割需要被載入，接下來會將原本的 fstab 備份，並於檔名中加入當前日期，接著修改該文件。</p><ul><li>備份 (Duplicate)</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo cp /etc/fstab /etc/fstab.$(date +%Y-%m-%d)</span><br></pre></td></tr></tbody></table></figure><ul><li>比較兩檔案</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cmp /etc/fstab /etc/fstab.$(date +%Y-%m-%d)</span><br></pre></td></tr></tbody></table></figure><ul><li>開啟文字編輯器修改 fstab</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo gedit /etc/fstab</span><br></pre></td></tr></tbody></table></figure><p>(gedit 可替換成任何文字編輯器，如 vim)<br>加入以下文字：</p><figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line"># (identifier)  (location, eg sda5)   (format, eg ext3 <span class="keyword">or</span> ext4)      (some settings) </span><br><span class="line">UUID=<span class="number">1</span>a2b3c4d<span class="number">-1</span>a2b<span class="number">-1</span>a2b<span class="number">-1</span>a2b<span class="number">-1</span>a2b3c4d5e6f   /media/home    ext4          defaults       <span class="number">0</span>       <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>記得填入自己的 UUID，及正確的格式。</p><p>存檔，關閉編輯器。</p><ul><li>建立新資料夾</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo mkdir /media/home</span><br></pre></td></tr></tbody></table></figure><p>此資料夾是為了掛載新的分割，需與上一步驟填入的相同。</p><ul><li>重開機。</li></ul><hr><h2 id="3-複製原本的-home-到新分割">3. 複製原本的 home 到新分割<a class="header-anchor" href="#3-複製原本的-home-到新分割">#</a></h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo rsync -aXS --progress --exclude='/*/.gvfs' /home/. /media/home/.</span><br></pre></td></tr></tbody></table></figure><ul><li>檢查是否全複製過去了</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo diff -r /home /media/home -x ".gvfs/*"</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="4-再次修改-fstab">4. 再次修改 fstab<a class="header-anchor" href="#4-再次修改-fstab">#</a></h2><ul><li>開啟</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo gedit /etc/fstab</span><br></pre></td></tr></tbody></table></figure><ul><li>修改上次新增的部分，將 <code>/media/home</code> 改成 <code>default</code>:</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> (identifier)  (location, eg sda5)   (format, eg ext3 or ext4)      (some settings) </span></span><br><span class="line">UUID=????????   /home    ext3          defaults       0       2</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="5-備份舊的家目錄">5. 備份舊的家目錄<a class="header-anchor" href="#5-備份舊的家目錄">#</a></h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd / &amp;&amp; sudo mv /home /old_home &amp;&amp; sudo mkdir /home</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="6-重開機，大功告成">6. 重開機，大功告成<a class="header-anchor" href="#6-重開機，大功告成">#</a></h2><ol><li>fstab 將新分割掛載在 /home 上</li><li>原本的 /home 改名成 /old_home</li></ol><hr><h2 id="刪除-old-home">刪除 old_home<a class="header-anchor" href="#刪除-old-home">#</a></h2><p>如果磁碟空間不夠，或是想清理磁碟的話，可透過以下指令刪除。</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line">sudo rm -rI /old_home</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://help.ubuntu.com/community/Partitioning/Home/Moving" target="_blank" rel="noopener">Partitioning/Home/Moving</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 語言 - attribute</title>
      <link href="/posts/CLang/c-attribute.html"/>
      <url>/posts/CLang/c-attribute.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有分三種： <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">1⃣</span> 對副函式的 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">2⃣</span> 對資料的　<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8">3⃣</span> 對結構的</p><div class="alert alert-warning"><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f514.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f514.png?v8">🔔</span> 註：<strong>attribute</strong> 是給 compiler 看的。</p></div><h2 id="對結構的">對結構的<a class="header-anchor" href="#對結構的">#</a></h2><h3 id="packed">packed<a class="header-anchor" href="#packed">#</a></h3><p>C語言在宣告結構的時候，會對裡面的元素作對齊，給個例子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span> {</span></span><br><span class="line">    <span class="keyword">int</span>  memberA;</span><br><span class="line">    <span class="keyword">char</span> memberB[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>  memberC;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我們手算此結構的大小的話，會是：</p><ul><li>A: 4 bytes;</li><li>B: 3 bytes;</li><li>C: 4 bytes;</li><li>sample : 4 + 3 + 4 = 11 bytes</li></ul><p>但實際上 compiler 出來 <code>sizeof(struct sample) = 12</code><br><br>這是因為 compiler 所有元素對齊，也就是把每一格切成 4 bytes，B 就會自動對齊成 4 bytes。<br><br>也可以說是寫成：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span> {</span></span><br><span class="line">    <span class="keyword">int</span>  memberA;</span><br><span class="line">    <span class="keyword">char</span> memberB[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> padding;</span><br><span class="line">    <span class="keyword">int</span>  memberC;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在嵌入式系統中，不可浪費太多記憶體，所以需要使用 packed 屬性來告訴 compiler 不要幫我們對齊，<code>sizeof</code> 出來的結果就會如我們預期。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span> {</span></span><br><span class="line">    <span class="keyword">int</span>  memberA;</span><br><span class="line">    <span class="keyword">char</span> memberB[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>  memberC;</span><br><span class="line">}__attribute__((packed));</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="aligned">aligned<a class="header-anchor" href="#aligned">#</a></h3><p>相反的，<code>aligned</code> 屬性就是告訴 compiler 幫我們對齊資料，可以指定對其的大小，如：</p><ul><li><code>__attribute__((aligned(8)))</code></li><li><code>__attribute__((aligned(16)))</code></li></ul><p>如果我們在上一個例子加上此屬性的話，<code>sizeof</code> 的結果將會不一樣。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span> {</span></span><br><span class="line">    <span class="keyword">int</span>  memberA;</span><br><span class="line">    <span class="keyword">char</span> memberB[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>  memberC;</span><br><span class="line">}__attribute__((aligned(<span class="number">8</span>)));</span><br></pre></td></tr></tbody></table></figure><p>此時 <code>sizeof(struct sample) = 16</code><br>也就是 A+B=7 bytes，沒有超過我們給定的 8，但加上 C 就會超過了，所以在 B 跟 C 中間塞個 1 byte 來對齊；然後在 C 的後面塞 4 bytes；也就是：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span> {</span></span><br><span class="line">    <span class="keyword">int</span>  memberA;</span><br><span class="line">    <span class="keyword">char</span> memberB[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> padding1;</span><br><span class="line">    <span class="keyword">int</span>  memberC;</span><br><span class="line">    <span class="keyword">int</span>  padding2;</span><br><span class="line">}__attribute__((aligned(<span class="number">8</span>)));</span><br></pre></td></tr></tbody></table></figure><p>如果沒有加數字，compiler 會進行最佳化的對齊。<br>以此例子將以 4 對齊。</p><h2 id="對資料的">對資料的<a class="header-anchor" href="#對資料的">#</a></h2><ul><li><code>__attribute__((aligned))</code></li><li><code>__attribute__((packed))</code></li></ul><p>與結構道理相同，也是決定要不要對齊。</p><h2 id="aligned-v-s-packed">aligned v.s. packed<a class="header-anchor" href="#aligned-v-s-packed">#</a></h2><ul><li>aligned: 速度快</li><li>packed: 省記憶體</li></ul><h2 id="對副程式的">對副程式的<a class="header-anchor" href="#對副程式的">#</a></h2><h3 id="noreturn">noreturn<a class="header-anchor" href="#noreturn">#</a></h3><p>對於 void 的副程式，如果放在某個需要回傳值的副程式，理論上會需要回傳值，也就是 <code>return void</code></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample</span><span class="params">(<span class="keyword">int</span> a)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a==<span class="number">0</span> ? a : <span class="built_in">exit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但這是無效的操作，所以需要加上 <code>__attribute__((noreturn))</code></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span>__<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample</span><span class="params">(<span class="keyword">int</span> a)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a==<span class="number">0</span>? a : <span class="built_in">exit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="通用">通用<a class="header-anchor" href="#通用">#</a></h2><h3 id="section">section<a class="header-anchor" href="#section">#</a></h3><p>如果需要將特定的變數、結構或是副程式放到指定的記憶體位置，即可使用此屬性，用法如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span>{</span></span><br><span class="line">    <span class="keyword">int</span>  some;</span><br><span class="line">    <span class="keyword">char</span> members;</span><br><span class="line">    <span class="keyword">int</span>  here;</span><br><span class="line">}__attribute__((section(<span class="string">"name"</span>)));</span><br></pre></td></tr></tbody></table></figure><p>上述例子我們指定將 sample 結構放置於指定的記憶體區塊，名為 <code>"name"</code>。<br><br>而 <code>"name"</code> 這個記憶體區塊則在 <em>linker script</em> 中命名。</p><figure class="highlight mipsasm"><table><tbody><tr><td class="code"><pre><span class="line">SECTION</span><br><span class="line">{</span><br><span class="line">    . = <span class="number">0x1000</span><span class="comment">;</span></span><br><span class="line">    .name : {</span><br><span class="line">        <span class="built_in">AT</span>(<span class="number">0x100000</span>)<span class="comment">;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>對變數、副程式我們可以一樣指定連結的位址：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> link_sample __attribute__((section(<span class="string">"data"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample_fun</span><span class="params">( )</span>__<span class="title">attribute__</span><span class="params">((section(<span class="string">"text"</span>)))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample_fun</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> do_nothing = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> do_nothing;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C語言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C語言 </tag>
            
            <tag> attribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 指令筆記</title>
      <link href="/posts/linux/vim-instruction.html"/>
      <url>/posts/linux/vim-instruction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="編輯">編輯<a class="header-anchor" href="#編輯">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:left">游標位置進入編輯模式（insert mode）<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[vi 與 vim 的指令整理](http://www.vixual.net/blog/archives/234)">[1]</span></a></sup></td></tr><tr><td style="text-align:center">I</td><td style="text-align:left">在游標行的第一個非空字元進入編輯模式</td></tr><tr><td style="text-align:center">A</td><td style="text-align:left">在游標行的最後一位進入編輯模式</td></tr><tr><td style="text-align:center">o</td><td style="text-align:left">向下新增一行，進入編輯模式</td></tr><tr><td style="text-align:center">O</td><td style="text-align:left">向下新增一行，進入編輯模式</td></tr><tr><td style="text-align:center">cc</td><td style="text-align:left">刪除此行，並進入編輯模式</td></tr><tr><td style="text-align:center"><span class="badge badge-secondary">ESC</span></td><td style="text-align:left">退出編輯模式</td></tr></tbody></table></div><h2 id="刪除">刪除<a class="header-anchor" href="#刪除">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">dd</td><td style="text-align:left">刪除此行</td></tr><tr><td style="text-align:center"><code>n</code> dd</td><td style="text-align:left">刪除第 <code>n</code> 行</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:left">從游標行刪除至最後一行</td></tr><tr><td style="text-align:center">d1G</td><td style="text-align:left">從游標行刪除至第一行</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:left">從游標處刪除至最後一個字元</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:left">從游標處刪除至第一個字元</td></tr></tbody></table></div><h2 id="游標移動">游標移動<a class="header-anchor" href="#游標移動">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">gg</td><td style="text-align:left">移至第一行</td></tr><tr><td style="text-align:center">G</td><td style="text-align:left">移至最後一行</td></tr><tr><td style="text-align:center"><code>n</code> G</td><td style="text-align:left">移至第 <code>n</code> 行</td></tr><tr><td style="text-align:center">0</td><td style="text-align:left">移至該行的最前</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">移至該行的最後</td></tr><tr><td style="text-align:center"><code>n</code> <span class="badge badge-secondary">Space</span></td><td style="text-align:left">向右移 <code>n</code> 個字元</td></tr><tr><td style="text-align:center"><code>n</code> <span class="badge badge-secondary">Enter</span></td><td style="text-align:left">向下移 <code>n</code> 行</td></tr></tbody></table></div><h2 id="標記、複製">標記、複製<a class="header-anchor" href="#標記、複製">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">v</td><td style="text-align:left">開始文字標記</td></tr><tr><td style="text-align:center">V</td><td style="text-align:left">開始行標記</td></tr><tr><td style="text-align:center">v <span class="badge badge-secondary">CTRL</span> v</td><td style="text-align:left">開始區塊標記</td></tr><tr><td style="text-align:center">d</td><td style="text-align:left">刪除標記內容</td></tr><tr><td style="text-align:center">y</td><td style="text-align:left">複製標記內容</td></tr><tr><td style="text-align:center">yy</td><td style="text-align:left">複製游標行</td></tr><tr><td style="text-align:center">yG</td><td style="text-align:left">從游標行複製到最後一行</td></tr><tr><td style="text-align:center">y1G</td><td style="text-align:left">從游標行複製到第一行</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:left">複製游標處至最後</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:left">複製游標處至最前</td></tr><tr><td style="text-align:center">p</td><td style="text-align:left">在下一行貼上複製或刪除的內容</td></tr><tr><td style="text-align:center">P</td><td style="text-align:left">在上一行貼上複製或刪除的內容</td></tr><tr><td style="text-align:center"><span class="badge badge-secondary">CTRL</span> R 0</td><td style="text-align:left">於編輯模式中，在下一行貼上複製或刪除的內容</td></tr></tbody></table></div><h2 id="搜尋與取代">搜尋與取代<a class="header-anchor" href="#搜尋與取代">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">/</td><td style="text-align:left">搜尋</td></tr><tr><td style="text-align:center">/\c</td><td style="text-align:left">不分大小寫搜尋</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">選取字串，按 * 也可以搜尋</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">向上搜尋</td></tr><tr><td style="text-align:center">?\c</td><td style="text-align:left">不分大小寫向上搜尋</td></tr><tr><td style="text-align:center">n</td><td style="text-align:left">下一個搜尋結果</td></tr><tr><td style="text-align:center">N</td><td style="text-align:left">上一個搜尋結果</td></tr></tbody></table></div><h2 id="功能">功能<a class="header-anchor" href="#功能">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:left">存檔</td></tr><tr><td style="text-align:center">:w <code>file_name</code></td><td style="text-align:left">另存新檔</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:left">退出</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:left">存檔並退出</td></tr><tr><td style="text-align:center">:x</td><td style="text-align:left">存檔並退出</td></tr><tr><td style="text-align:center">:e <code>file_name</code></td><td style="text-align:left">編輯其他檔案</td></tr><tr><td style="text-align:center">:e!</td><td style="text-align:left">還原至檔案修改前的狀態</td></tr><tr><td style="text-align:center">:files</td><td style="text-align:left">列出所有開啟的檔案</td></tr><tr><td style="text-align:center">:n</td><td style="text-align:left">切到下一個開啟的檔案</td></tr><tr><td style="text-align:center">:N</td><td style="text-align:left">切到上一個開啟的檔案</td></tr><tr><td style="text-align:center">:Ex</td><td style="text-align:left">開啟檔案瀏覽器</td></tr><tr><td style="text-align:center">:Ex <code>url</code></td><td style="text-align:left">在指定路徑開啟檔案瀏覽器</td></tr></tbody></table></div><h3 id="檔案瀏覽器相關">檔案瀏覽器相關<a class="header-anchor" href="#檔案瀏覽器相關">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:left">同指令 <code>..</code></td></tr><tr><td style="text-align:center">d</td><td style="text-align:left"><code>mkdir</code></td></tr><tr><td style="text-align:center">D</td><td style="text-align:left"><code>rmdir</code></td></tr><tr><td style="text-align:center">R</td><td style="text-align:left">重新命名</td></tr></tbody></table></div><h2 id="其他">其他<a class="header-anchor" href="#其他">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">重覆上一個指令</td></tr><tr><td style="text-align:center">! <code>shell</code></td><td style="text-align:left">執行 <code>shell</code> 指令，並顯示執行結果</td></tr><tr><td style="text-align:center">u</td><td style="text-align:left">還原指令</td></tr><tr><td style="text-align:center">J</td><td style="text-align:left">將游標行與下一行合併</td></tr></tbody></table></div><hr><h2 id="特殊指令">特殊指令<a class="header-anchor" href="#特殊指令">#</a></h2><ul><li><code>:w !sudo tee %</code>：當要存檔的時候需要權限，可以用此指令來提升。</li><li><code>"+y</code>：將選取的內容複製到 + 暫存器（剪貼簿)，方便在其他程式中貼上。<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[如何将 Vim 剪贴板里面的东西粘贴到 Vim 之外的地方？](https://www.zhihu.com/question/19863631)">[2]</span></a></sup></li></ul><div class="alert alert-info"><p>vim 在複製、刪除時，會把資料放在預設暫存器中，有 0-9A-Za-z+" 這些暫存器可選擇，其中：</p><ul><li>0-9：vim 會用到 0-9，0 存放最近一次的資料</li><li>“：預設暫存器</li><li>+：剪貼簿暫存器</li></ul><p>因此將資料放進 + 暫存器等同於將資料放進剪貼簿。</p></div><hr><h2 id="vim-rc-設定檔">vim.rc 設定檔<a class="header-anchor" href="#vim-rc-設定檔">#</a></h2><p>記錄我目前的設定檔。</p><figure class="highlight vim line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span></span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="keyword">set</span> smartindent</span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">inoremap</span> ( ()<span class="symbol">&lt;Esc&gt;</span>i</span><br><span class="line"><span class="keyword">inoremap</span> [ []<span class="symbol">&lt;Esc&gt;</span>i</span><br><span class="line"><span class="keyword">inoremap</span> <span class="string">' '</span><span class="string">'&lt;Esc&gt;i</span></span><br><span class="line"><span class="string">inoremap " ""&lt;Esc&gt;i</span></span><br><span class="line"><span class="string">inoremap {&lt;CR&gt; {&lt;CR&gt;}&lt;Esc&gt;ko</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>set nu</code></li></ul><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://www.vixual.net/blog/archives/234" target="_blank" rel="noopener">vi 與 vim 的指令整理</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.zhihu.com/question/19863631" target="_blank" rel="noopener">如何将 Vim 剪贴板里面的东西粘贴到 Vim 之外的地方？</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - Starting Process</title>
      <link href="/posts/xv6/starting.html"/>
      <url>/posts/xv6/starting.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>BIOS -&gt; boot section -&gt; main -&gt; scheduler 的詳細流程在 <a href="/post/xv6/process.html">Ch1</a>、<a href="/post/xv6/scheduler.html">Ch5</a>及<a href="/post/xv6/bootloader.html">Appendix B</a>，本文強調 CPU0 以外的 CPU 啟動流程及更詳細的 main 解析。</p></blockquote><h2 id="Code-startothers">Code: startothers<a class="header-anchor" href="#Code-startothers">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> main.c</p></div><ul><li>在 main 初始化一些設備後，會先呼叫 startothers，再呼叫 mpmain 來完成 cpu 的設定及呼叫 scheduler。</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>啟動其他 CPU</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">startothers(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];</span><br><span class="line">  uchar *code;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">  <span class="keyword">char</span> *<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write entry code to unused memory at 0x7000.</span></span><br><span class="line">  <span class="comment">// The linker has placed the image of entryother.S in</span></span><br><span class="line">  <span class="comment">// _binary_entryother_start.</span></span><br><span class="line">  code = p2v(<span class="number">0x7000</span>);</span><br><span class="line">  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);</span><br></pre></td></tr></tbody></table></figure><ul><li>entryother.S 的入口被 linked 到 <code>0x7000</code>，這裡將 code 指向 <code>0x7000</code> 作為 entryother.S 的進入點。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(c = cpus; c &lt; cpus+ncpu; c++){</span><br><span class="line">  <span class="keyword">if</span>(c == cpus+cpunum())  <span class="comment">// We've started already.</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell entryother.S what stack to use, where to enter, and what </span></span><br><span class="line">  <span class="comment">// pgdir to use. We cannot use kpgdir yet, because the AP processor</span></span><br><span class="line">  <span class="comment">// is running in low  memory, so we use entrypgdir for the APs too.</span></span><br><span class="line">  <span class="built_in">stack</span> = kalloc();</span><br><span class="line">  *(<span class="keyword">void</span>**)(code<span class="number">-4</span>) = <span class="built_in">stack</span> + KSTACKSIZE;</span><br><span class="line">  *(<span class="keyword">void</span>**)(code<span class="number">-8</span>) = mpenter;</span><br><span class="line">  *(<span class="keyword">int</span>**)(code<span class="number">-12</span>) = (<span class="keyword">void</span> *) v2p(entrypgdir);</span><br></pre></td></tr></tbody></table></figure><ul><li>為待會的 entryother 建立一個堆疊 …</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">lapicstartap(c-&gt;id, v2p(code));</span><br></pre></td></tr></tbody></table></figure><ul><li>正式的啟動 CPU <code>c</code>，即進入 entryother.S</li><li>entryother.S 做完設定後會呼叫 <code>mpenter()</code>，<code>mpmenter</code> 最後會呼叫 <code>mpmain()</code>。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// wait for cpu to finish mpmain()</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在 <code>mpmain()</code> 會將 <code>cpu-&gt;started</code> 設為 <code>1</code>，CPU0 在 <code>while</code> 迴圈等待 CPU <code>c</code> 啟動完畢，才繼續啟動下一個 CPU。</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>完成多核心啟動流程</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mpenter(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  switchkvm(); </span><br><span class="line">  seginit();</span><br><span class="line">  lapicinit();</span><br><span class="line">  mpmain();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>執行多核心任務</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mpmain(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  cprintf(<span class="string">"cpu%d: starting\n"</span>, cpu-&gt;id);</span><br><span class="line">  idtinit();       <span class="comment">// load idt register</span></span><br><span class="line">  xchg(&amp;cpu-&gt;started, <span class="number">1</span>); <span class="comment">// tell startothers() we're up</span></span><br><span class="line">  scheduler();     <span class="comment">// start running processes</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lapicstartup">lapicstartup<a class="header-anchor" href="#lapicstartup">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>啟動 lapic</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>apicid</code></th><th><code>addr</code></th></tr></thead><tbody><tr><td>欲啟動的 lapic</td><td>填入的值</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">lapicstartap(uchar apicid, uint addr)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  ushort *wrv;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// "The BSP must initialize CMOS shutdown code to 0AH</span></span><br><span class="line">  <span class="comment">// and the warm reset vector (DWORD based at 40:67) to point at</span></span><br><span class="line">  <span class="comment">// the AP startup code prior to the [universal startup algorithm]."</span></span><br><span class="line">  outb(IO_RTC, <span class="number">0xF</span>);  <span class="comment">// offset 0xF is shutdown code</span></span><br><span class="line">  outb(IO_RTC+<span class="number">1</span>, <span class="number">0x0A</span>);</span><br><span class="line">  wrv = (ushort*)P2V((<span class="number">0x40</span>&lt;&lt;<span class="number">4</span> | <span class="number">0x67</span>));  <span class="comment">// Warm reset vector</span></span><br><span class="line">  wrv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  wrv[<span class="number">1</span>] = addr &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "Universal startup algorithm."</span></span><br><span class="line">  <span class="comment">// Send INIT (level-triggered) interrupt to reset other CPU.</span></span><br><span class="line">  lapicw(ICRHI, apicid&lt;&lt;<span class="number">24</span>);</span><br><span class="line">  lapicw(ICRLO, INIT | LEVEL | ASSERT);</span><br><span class="line">  microdelay(<span class="number">200</span>);</span><br><span class="line">  lapicw(ICRLO, INIT | LEVEL);</span><br><span class="line">  microdelay(<span class="number">100</span>);    <span class="comment">// should be 10ms, but too slow in Bochs!</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Send startup IPI (twice!) to enter code.</span></span><br><span class="line">  <span class="comment">// Regular hardware is supposed to only accept a STARTUP</span></span><br><span class="line">  <span class="comment">// when it is in the halted state due to an INIT.  So the second</span></span><br><span class="line">  <span class="comment">// should be ignored, but it is part of the official Intel algorithm.</span></span><br><span class="line">  <span class="comment">// Bochs complains about the second one.  Too bad for Bochs.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++){</span><br><span class="line">    lapicw(ICRHI, apicid&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    lapicw(ICRLO, STARTUP | (addr&gt;&gt;<span class="number">12</span>));</span><br><span class="line">    microdelay(<span class="number">200</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Main-解析">Main 解析<a class="header-anchor" href="#Main-解析">#</a></h2><h3 id="main">main<a class="header-anchor" href="#main">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  kinit1(end, P2V(<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>)); <span class="comment">// phys page allocator</span></span><br><span class="line">  kvmalloc();      <span class="comment">// kernel page table</span></span><br><span class="line">  mpinit();        <span class="comment">// collect info about this machine</span></span><br><span class="line">  lapicinit();</span><br><span class="line">  seginit();       <span class="comment">// set up segments</span></span><br><span class="line">  cprintf(<span class="string">"\ncpu%d: starting XV6\n\n"</span>, cpu-&gt;id);</span><br><span class="line">  picinit();       <span class="comment">// interrupt controller</span></span><br><span class="line">  ioapicinit();    <span class="comment">// another interrupt controller</span></span><br><span class="line">  consoleinit();   <span class="comment">// I/O devices &amp; their interrupts</span></span><br><span class="line">  uartinit();      <span class="comment">// serial port</span></span><br><span class="line">  pinit();         <span class="comment">// process table</span></span><br><span class="line">  tvinit();        <span class="comment">// trap vectors</span></span><br><span class="line">  binit();         <span class="comment">// buffer cache</span></span><br><span class="line">  fileinit();      <span class="comment">// file table</span></span><br><span class="line">  iinit();         <span class="comment">// inode cache</span></span><br><span class="line">  ideinit();       <span class="comment">// disk</span></span><br><span class="line">  <span class="keyword">if</span>(!ismp)</span><br><span class="line">    timerinit();   <span class="comment">// uniprocessor timer</span></span><br><span class="line">  startothers();   <span class="comment">// start other processors</span></span><br><span class="line">  kinit2(P2V(<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>), P2V(PHYSTOP)); <span class="comment">// must come after startothers()</span></span><br><span class="line">  userinit();      <span class="comment">// first user process</span></span><br><span class="line">  <span class="comment">// Finish setting up this processor in mpmain.</span></span><br><span class="line">  mpmain();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>kinit1()</code> <a href="/post/xv6/mem.html#kinit1-2">In ch2</a></li><li><code>kvmalloc()</code> <a href="/post/xv6/mem.html#kvmalloc">In Ch2</a></li><li><code>mpinit()</code></li><li><code>lapicinit()</code></li><li><code>seginit()</code></li><li><code>picinit()</code></li><li><code>ioapicinit()</code></li><li><code>consoleinit()</code></li><li><code>uartinit()</code></li><li><code>pinit()</code></li><li><code>tvinit()</code> <a href="/post/xv6/trap.html#Code-Assembly-trap-handler">In Ch3</a></li><li><code>binit()</code></li><li><code>fileinit()</code></li><li><code>iinit()</code></li><li><code>ideinit()</code> <a href="/post/xv6/trap.html#File-buf-h">In Ch3</a></li><li><code>timerinit()</code></li><li><code>startothers()</code> <a href="#Code-startothers">Above</a></li><li><code>kinit2()</code> <a href="/post/xv6/mem.html#kinit1-2">In ch2</a></li><li><code>userinit()</code> <a href="/post/xv6/process.html#userinit">In Ch1</a></li><li><code>mpmain()</code></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - Running</title>
      <link href="/posts/xv6/running.html"/>
      <url>/posts/xv6/running.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Makefile-解析">Makefile 解析<a class="header-anchor" href="#Makefile-解析">#</a></h2><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OBJS = \</span><br><span class="line">bio.o\</span><br><span class="line">console.o\</span><br><span class="line">exec.o\</span><br><span class="line">file.o\</span><br><span class="line">fs.o\</span><br><span class="line">ide.o\</span><br><span class="line">ioapic.o\</span><br><span class="line">kalloc.o\</span><br><span class="line">kbd.o\</span><br><span class="line">lapic.o\</span><br><span class="line">main.o\</span><br><span class="line">mp.o\</span><br><span class="line">picirq.o\</span><br><span class="line">pipe.o\</span><br><span class="line">proc.o\</span><br><span class="line">spinlock.o\</span><br><span class="line">string.o\</span><br><span class="line">swtch.o\</span><br><span class="line">syscall.o\</span><br><span class="line">sysfile.o\</span><br><span class="line">sysproc.o\</span><br><span class="line">timer.o\</span><br><span class="line">trapasm.o\</span><br><span class="line">trap.o\</span><br><span class="line">uart.o\</span><br><span class="line">vectors.o\</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cross-compiling (e.g., on Mac OS X)</span></span><br><span class="line">TOOLPREFIX = /usr/bin/i386-jos-elf-</span><br><span class="line"><span class="comment"># Using native tools (e.g., on X86 Linux)</span></span><br><span class="line"><span class="comment"># TOOLPREFIX = </span></span><br><span class="line">CC = <span class="variable">$(TOOLPREFIX)</span>gcc</span><br><span class="line">AS = <span class="variable">$(TOOLPREFIX)</span>gas</span><br><span class="line">LD = <span class="variable">$(TOOLPREFIX)</span>ld</span><br><span class="line">OBJCOPY = <span class="variable">$(TOOLPREFIX)</span>objcopy</span><br><span class="line">OBJDUMP = <span class="variable">$(TOOLPREFIX)</span>objdump</span><br><span class="line">CFLAGS = -fno-builtin -O2 -Wall -MD -ggdb -m32</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-fno-builtin</code>：不使用 C 中的內建函數。</li><li><code>-O2</code>：<code>-O</code> 表示最佳化的程度，數字越大越好，但會增加編譯時間。</li><li><code>-Wall</code>：Warm all 的意思，打開所有的警告。</li><li><code>-MD</code>：生成 .d（directory），等同於 <code>-M -MF file</code>。</li></ul><div class="alert alert-info"><p><code>gcc -M file.c</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Linux Makefile 生成 .d 依赖文件及 gcc -M -MF -MP 等相关选项说明](https://blog.csdn.net/QQ1452008/article/details/50855810)">[1]</span></a></sup> 會將 file.c 有 include 的 .h （包含標準函式庫）關聯起來，即輸出為：<br><code>file.o: file.c header.h stdio.h</code><br><code>gcc -M -MF file.c</code> 將 <code>-M</code> 的輸出存入 file.d 裡。<br><strong>註</strong>：<code>-M</code> 會自動帶 <code>-E</code>，如果使用 <code>-MD</code> 替代 <code>-M -MF</code> 時則不會帶 <code>-E</code>。</p></div><ul><li><code>-ggdb</code>：為 GDB 生成更多的 debug 資訊。</li><li><code>-m32</code>：生成 32 位元的程式碼。</li></ul><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span></span><br><span class="line">ASFLAGS = -m32</span><br><span class="line"><span class="comment"># FreeBSD ld wants ``elf_i386_fbsd''</span></span><br><span class="line">LDFLAGS += -m <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(LD)</span> -V | grep elf_i386 2&gt;/dev/null)</span></span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">XV6.img: bootblock kernel fs.img</span></span><br><span class="line">dd if=/dev/zero of=XV6.img count=10000</span><br><span class="line">dd if=bootblock of=XV6.img conv=notrunc</span><br><span class="line">dd if=kernel of=XV6.img seek=1 conv=notrunc</span><br></pre></td></tr></tbody></table></figure><ul><li>產生 XV6.img</li><li><code>dd</code> 指令將 <code>if</code>(input file) 複製到 <code>of</code>(output file)</li><li><code>count</code> 限制輸入的大小，單位為 blocks，一個 block 的大小由 <code>ibs=BYTES</code> 宣告（預設為 512）。</li><li><code>notrunc</code> 在輸出檔案時會比對輸入的檔案，只會輸出與輸入檔案不一樣的地方。</li><li><code>seek</code> 會略過數個 blocks 之後再輸出，block 大小由 <code>obs=BTYES</code> 宣告（預設為 512）。</li></ul><div class="alert alert-warning"><p>/dev/zero 為一個特殊檔案，讀取時會提供無限的空字元，44 行為生成一個大小為 10000（個 block）的空白檔案 XV6.img（或是把 XV6.img 的前 10000 個 block 清除。）</p></div><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">bootblock: bootasm.S bootmain.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -O -nostdinc -I. -c bootmain.c</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -nostdinc -I. -c bootasm.S</span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -S -O binary bootblock.o bootblock</span><br><span class="line">./sign.pl bootblock</span><br></pre></td></tr></tbody></table></figure><ul><li>建立 bootblock</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>GCC</th><th></th></tr></thead><tbody><tr><td><code>-nostdinc</code></td><td>不要從根目錄開始搜尋檔案，要從 <code>-I</code> 指定的目錄開始</td></tr><tr><td><code>-I.</code></td><td>指定現在的資料夾</td></tr><tr><td><code>-c</code></td><td>對後面的檔案編譯（或組譯），但不做連接</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>LD</th><th></th></tr></thead><tbody><tr><td><code>-N</code></td><td></td></tr><tr><td><code>-e</code></td><td>使用後面的名稱（start）作為入口</td></tr><tr><td><code>-Ttext</code></td><td>將後面的位置作為輸出文件的起始位置（須為 16 進位）</td></tr><tr><td><code>-o</code></td><td>用來指定 ld 生成的名稱</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>OBJDUMP</th><th></th></tr></thead><tbody><tr><td><code>-S</code></td><td>反組譯目標文件</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>OBJCOPY</th><th></th></tr></thead><tbody><tr><td><code>-S</code></td><td>去除所有符號資訊</td></tr><tr><td><code>-O binary</code></td><td>輸出為二進位的文件</td></tr></tbody></table></div><div class="alert alert-info"><p>反組譯的用意是為了 debug</p></div><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">bootother: bootother.S</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -nostdinc -I. -c bootother.S</span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7000 -o bootother.out bootother.o</span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -S -O binary bootother.out bootother</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -S bootother.o &gt; bootother.asm</span><br></pre></td></tr></tbody></table></figure><ul><li>啟動其他的 CPU</li></ul><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">initcode: initcode.S</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -nostdinc -I. -c initcode.S</span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0 -o initcode.out initcode.o</span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -S -O binary initcode.out initcode</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -S initcode.o &gt; initcode.asm</span><br></pre></td></tr></tbody></table></figure><ul><li>建立 initcode</li></ul><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">kernel: <span class="variable">$(OBJS)</span> bootother initcode</span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -Ttext 0x100000 -e main -o kernel <span class="variable">$(OBJS)</span> -b binary initcode bootother</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -S kernel &gt; kernel.asm</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; kernel.sym</span><br></pre></td></tr></tbody></table></figure><ul><li>建立 kernel</li></ul><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">tags: <span class="variable">$(OBJS)</span> bootother.S _init</span></span><br><span class="line">etags *.S *.c</span><br><span class="line"></span><br><span class="line"><span class="section">vectors.S: vectors.pl</span></span><br><span class="line">perl vectors.pl &gt; vectors.S</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <a href="http://vectors.pl" target="_blank" rel="noopener">vectors.pl</a> 生成 vectors.S</li></ul><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">ULIB = ulib.o usys.o printf.o umalloc.o</span><br><span class="line"></span><br><span class="line"><span class="section">_%: %.o <span class="variable">$(ULIB)</span></span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e main -Ttext 0 -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$*</span>.asm</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; <span class="variable">$*</span>.sym</span><br></pre></td></tr></tbody></table></figure><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>特殊符號</th><th></th></tr></thead><tbody><tr><td>%</td><td>萬用字元，如 <code>_a</code> 需對應 <code>a.o</code></td></tr><tr><td>$@</td><td>代表工作目標，即 <code>_%</code></td></tr><tr><td>$^</td><td>代表所有必要條件，即 <code>%.o $(ULIB)</code></td></tr><tr><td>$*</td><td>代表第一個必要條件，但不包含副檔名</td></tr></tbody></table></div><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">_forktest: forktest.o <span class="variable">$(ULIB)</span></span></span><br><span class="line"><span class="comment"># forktest has less library code linked in - needs to be small</span></span><br><span class="line"><span class="comment"># in order to be able to max out the proc table.</span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o</span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -S _forktest &gt; forktest.asm</span><br><span class="line"></span><br><span class="line"><span class="section">mkfs: mkfs.c fs.h</span></span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> -Wall -o mkfs mkfs.c</span><br><span class="line"></span><br><span class="line">UPROGS=\</span><br><span class="line">_cat\</span><br><span class="line">_echo\</span><br><span class="line">_forktest\</span><br><span class="line">_grep\</span><br><span class="line">_init\</span><br><span class="line">_kill\</span><br><span class="line">_ln\</span><br><span class="line">_ls\</span><br><span class="line">_mkdir\</span><br><span class="line">_rm\</span><br><span class="line">_sh\</span><br><span class="line">_usertests\</span><br><span class="line">_wc\</span><br><span class="line">_zombie\</span><br><span class="line"></span><br><span class="line"><span class="section">fs.img: mkfs README <span class="variable">$(UPROGS)</span></span></span><br><span class="line">./mkfs fs.img README <span class="variable">$(UPROGS)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>fs 指的是 file system</li></ul><figure class="highlight makefile line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> *.d</span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \</span><br><span class="line">*.o *.d *.asm *.sym vectors.S parport.out \</span><br><span class="line">bootblock kernel XV6.img fs.img mkfs \</span><br><span class="line"><span class="variable">$(UPROGS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make a printout</span></span><br><span class="line">FILES = <span class="variable">$(<span class="built_in">shell</span> grep -v '^\#' runoff.list)</span></span><br><span class="line">PRINT = runoff.list <span class="variable">$(FILES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">XV6.pdf: <span class="variable">$(PRINT)</span></span></span><br><span class="line">./runoff</span><br><span class="line"></span><br><span class="line"><span class="section">print: XV6.pdf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run in emulators</span></span><br><span class="line"></span><br><span class="line">bochs : fs.img XV6.img</span><br><span class="line">if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi</span><br><span class="line">bochs -q</span><br><span class="line"></span><br><span class="line"><span class="section">qemu: fs.img XV6.img</span></span><br><span class="line">qemu -parallel stdio -hdb fs.img XV6.img</span><br><span class="line"></span><br><span class="line"><span class="section">qemutty: fs.img XV6.img</span></span><br><span class="line">qemu -nographic -smp 2 -hdb fs.img XV6.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># CUT HERE</span></span><br><span class="line"><span class="comment"># prepare dist for students</span></span><br><span class="line"><span class="comment"># after running make dist, probably want to</span></span><br><span class="line"><span class="comment"># rename it to rev0 or rev1 or so on and then</span></span><br><span class="line"><span class="comment"># check in that version.</span></span><br><span class="line"></span><br><span class="line">EXTRA=\</span><br><span class="line">mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c\</span><br><span class="line">kill.c ln.c ls.c mkdir.c rm.c usertests.c wc.c zombie.c\</span><br><span class="line">printf.c umalloc.c \</span><br><span class="line">README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\</span><br><span class="line"></span><br><span class="line"><span class="section">dist:</span></span><br><span class="line">rm -rf dist</span><br><span class="line">mkdir dist</span><br><span class="line">for i in <span class="variable">$(FILES)</span>; \</span><br><span class="line">do \</span><br><span class="line">grep -v PAGEBREAK $$i &gt;dist/$$i; \</span><br><span class="line">done</span><br><span class="line">sed '/CUT HERE/,$$d' Makefile &gt;dist/Makefile</span><br><span class="line">echo &gt;dist/runoff.spec</span><br><span class="line">cp <span class="variable">$(EXTRA)</span> dist</span><br><span class="line"></span><br><span class="line"><span class="section">dist-test:</span></span><br><span class="line">rm -rf dist</span><br><span class="line">make dist</span><br><span class="line">rm -rf dist-test</span><br><span class="line">mkdir dist-test</span><br><span class="line">cp dist/* dist-test</span><br><span class="line">cd dist-test; ../m print</span><br><span class="line">cd dist-test; ../m bochs || true</span><br><span class="line">cd dist-test; ../m qemu</span><br><span class="line"></span><br><span class="line"><span class="comment"># update this rule (change rev1) when it is time to</span></span><br><span class="line"><span class="comment"># make a new revision.</span></span><br><span class="line"><span class="section">tar:</span></span><br><span class="line">rm -rf /tmp/XV6</span><br><span class="line">mkdir -p /tmp/XV6</span><br><span class="line">cp dist/* /tmp/XV6</span><br><span class="line">(cd /tmp; tar cf - XV6) | gzip &gt;XV6-rev2.tar.gz</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Make">Make<a class="header-anchor" href="#Make">#</a></h2><blockquote><p>我本來是打算在 MacOX 的環境下 make XV6 的，但是如果要 make 的話需要有 <code>i386-jos-elf</code> 的相關工具，需另外安裝（<a href="https://pdos.csail.mit.edu/6.828/2016/tools.html" target="_blank" rel="noopener">安裝方法</a>）。由於我一直沒辦法安裝，最後只好裝 ubuntu 來 make。</p></blockquote><ul><li>在主目錄下輸入 <code>make</code> 指令</li><li>接著會多出兩個檔案：XV6.img、fs.img，我們使用 qemu 來運行 XV6。</li></ul><hr><h2 id="QEMU">QEMU<a class="header-anchor" href="#QEMU">#</a></h2><ul><li>輸入以下代碼<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[【學習 XV6 】在 Mac OSX 下運行 XV6](http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/)">[2]</span></a></sup></li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">qemu-system-i386 -serial mon:stdio -hdb fs.img XV6.img -smp 1 -m 512</span><br></pre></td></tr></tbody></table></figure><p><div class="img-item" data-src="https://i.imgur.com/Fz4WKO1.png" data-sub-html=".caption"><img src="https://i.imgur.com/Fz4WKO1.png" alt="QEMU" title="Running XV6 in QEMU"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">QEMU</span></div></div></p><div class="alert alert-warning"><p>註：make 好了以後，在 MacOS 的環境下使用 QEMU 模擬器即可運行。</p></div><hr><h2 id="File-Kernel-ld">File: Kernel.ld<a class="header-anchor" href="#File-Kernel-ld">#</a></h2><figure class="highlight armasm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Simple linker script for the JOS kernel.</span></span><br><span class="line"><span class="comment">   See the GNU ld 'info' manual ("info ld") to learn the syntax. */</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OUTPUT_FORMAT</span>(<span class="string">"elf32-i386"</span>, <span class="string">"elf32-i386"</span>, <span class="string">"elf32-i386"</span>)</span><br><span class="line"><span class="symbol">OUTPUT_ARCH</span>(i386)</span><br><span class="line"><span class="symbol">ENTRY</span>(_start)</span><br><span class="line"></span><br><span class="line"><span class="symbol">SECTIONS</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/* Link the kernel at this address: "." means the current address */</span></span><br><span class="line">        <span class="comment">/* Must be equal to KERNLINK */</span></span><br><span class="line">. = <span class="number">0x80100000</span><span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>設定記憶體位置到 <code>0x8010000</code>（虛擬地址，分頁硬體會映射至實體位置 <code>0x0010000</code>）</li><li><em>bootmain.c</em> 將 ELF 指標指向 <code>0x100000</code> 接著將 kernel 讀入。</li></ul><figure class="highlight armasm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.text</span> : AT(<span class="number">0x100000</span>) {</span><br><span class="line">*(<span class="meta">.text</span> .stub <span class="meta">.text</span>.* .gnu.linkonce.t.*)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">PROVIDE(etext = .)<span class="comment">;/* Define the 'etext' symbol to this value */</span></span><br><span class="line"></span><br><span class="line">.rodata : {</span><br><span class="line">*(.rodata .rodata.* .gnu.linkonce.r.*)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include debugging information in kernel memory */</span></span><br><span class="line">.stab : {</span><br><span class="line">PROVIDE(__STAB_BEGIN__ = .)<span class="comment">;</span></span><br><span class="line">*(.stab)<span class="comment">;</span></span><br><span class="line">PROVIDE(__STAB_END__ = .)<span class="comment">;</span></span><br><span class="line"><span class="keyword">BYTE(0)</span><span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">   for this section */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.stabstr : {</span><br><span class="line">PROVIDE(__STABSTR_BEGIN__ = .)<span class="comment">;</span></span><br><span class="line">*(.stabstr)<span class="comment">;</span></span><br><span class="line">PROVIDE(__STABSTR_END__ = .)<span class="comment">;</span></span><br><span class="line"><span class="keyword">BYTE(0)</span><span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">   for this section */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adjust the address for the data segment to the next page */</span></span><br><span class="line">. = <span class="meta">ALIGN</span>(<span class="number">0x1000</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conventionally, Unix linkers provide pseudo-symbols</span></span><br><span class="line"><span class="comment"> * etext, edata, and end, at the end of the text, data, and bss.</span></span><br><span class="line"><span class="comment"> * For the kernel mapping, we need the address at the beginning</span></span><br><span class="line"><span class="comment"> * of the data section, but that's not one of the conventional</span></span><br><span class="line"><span class="comment"> * symbols, because the convention started before there was a</span></span><br><span class="line"><span class="comment"> * read-only rodata section between text and data. */</span></span><br><span class="line">PROVIDE(<span class="meta">data</span> = .)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The data segment */</span></span><br><span class="line"><span class="meta">.data</span> : {</span><br><span class="line">*(<span class="meta">.data</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">PROVIDE(edata = .)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">.<span class="keyword">bss </span>: {</span><br><span class="line">*(.<span class="keyword">bss)</span></span><br><span class="line"><span class="keyword"></span>}</span><br><span class="line"></span><br><span class="line">PROVIDE(<span class="meta">end</span> = .)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">/DISCARD/ : {</span><br><span class="line">*(.eh_frame .note.GNU-stack)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/QQ1452008/article/details/50855810" target="_blank" rel="noopener">Linux Makefile 生成 .d 依赖文件及 gcc -M -MF -MP 等相关选项说明</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/" target="_blank" rel="noopener">【學習 XV6 】在 Mac OSX 下運行 XV6</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> makefile </tag>
            
            <tag> XV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - The Boot loader</title>
      <link href="/posts/xv6/bootloader.html"/>
      <url>/posts/xv6/bootloader.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>x86 開機時，會先呼叫位於主機板上的 BIOS。</li><li>BIOS 的工作：準備硬體，將控制權轉給 OS (XV6)。</li><li>準確的說，控制權轉給 boot sector，位於開機碟的第一個磁碟扇區(512 byte)。</li><li>Boot sector 包含 boot loader—負責將 kernel 載入記憶體。</li><li>BIOS 將 boot sector 寫入 0x7c00 的位置，並跳至該位址(透過設定暫存器 %ip)。</li><li>XV6 boot loader 包含兩個檔案：<em>bootasm.s</em>、<em>bootmain.c</em>。</li></ul><h2 id="Code-Assembly-bootstrap">Code: Assembly bootstrap<a class="header-anchor" href="#Code-Assembly-bootstrap">#</a></h2><h3 id="File-bootasm-s">File: bootasm.s<a class="header-anchor" href="#File-bootasm-s">#</a></h3><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"asm.h"</span></span><br><span class="line">#include <span class="string">"memlayout.h"</span></span><br><span class="line">#include <span class="string">"mmu.h"</span></span><br><span class="line"></span><br><span class="line"># Start the first <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></span><br><span class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</span><br><span class="line"># with %cs=<span class="number">0</span> %ip=7c00.</span><br></pre></td></tr></tbody></table></figure><ul><li>第一行指令：<code>cli</code>，禁止處理器中斷。</li><li>硬體可以透過中斷觸發中斷處理，進而操作系統的功能。BIOS 為了初始化硬體，可能設置了自己的中斷處理。但控制權已經給 boot loader 了，所以現在處理中斷是不安全的；當 XV6 準備完成後會重新允許中斷。</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.code16</span>                       # Assemble for <span class="number">16</span>-bit mode</span><br><span class="line"><span class="meta">.globl</span> start</span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">  <span class="keyword">cli</span>                         # BIOS enabled interrupts<span class="comment">; disable</span></span><br></pre></td></tr></tbody></table></figure><ul><li>處理器在模擬 Intel 8088 的 <strong>real mode</strong> 狀態下，有 8 個 16 位元的通用暫存器，但處理器傳送的是20位元的地址給記憶體；因此多出來的四個位元由段暫存器(<code>%cs</code>, <code>%ds</code>, <code>%es</code>, <code>%ss</code>)提供。</li><li><code>%cs</code> 取指令用</li><li><code>%ds</code> 讀寫資料用</li><li><code>%ss</code> 讀寫堆疊用</li><li>BIOS 完成工作後 <code>%ds</code>, <code>%es</code>, <code>%ss</code> 是未知的，所以將其設為 0</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># <span class="meta">Zero</span> data <span class="meta">segment</span> registers <span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="keyword">and</span> <span class="built_in">SS</span>.</span><br><span class="line">xorw    %ax,%ax             # Set %ax to <span class="meta">zero</span></span><br><span class="line">movw    %ax,%ds             # -&gt; Data <span class="meta">Segment</span></span><br><span class="line">movw    %ax,%es             # -&gt; Extra <span class="meta">Segment</span></span><br><span class="line">movw    %ax,%ss             # -&gt; Stack <span class="meta">Segment</span></span><br></pre></td></tr></tbody></table></figure><ul><li>XV6 假設 x86 的指令是使用虛擬地址，但實際上使用的是邏輯地址。</li><li>一個邏輯地址包含一個段選擇器及一個差值，有時表示為 segment:offset。</li><li>更多時候，段是固定的，所以程式只會使用差值。</li><li>分段硬體負責將邏輯地址翻譯成線性地址。</li><li>如果分頁硬體是啟用的，它會把線性地址轉成物理地址；若未啟用，處理器會把線性地址當作物理地址。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/WqLrdy2.png" data-sub-html=".caption"><img src="https://i.imgur.com/WqLrdy2.png" alt="logic address" title="The relationship between logical, linear, and physical addresses."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">logic address</span></div></div></p><ul><li>一個 segment:offset 可能產生 21-bit 的物理地址，但在模擬 Intel 8088 下只能使用 20 bits 的記憶體位置，IBM 提出了一個方法：如果鍵盤控制器輸出端的第二位高於第一位，則第 21 個 bit 可以正常使用，反之則歸零。</li><li>boot loader 用 I/O 指令控制鍵盤控制器端 0x64、0x60 來確保第 21 個 bit 正常運作。</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  # Physical address line A20 is tied to <span class="meta">zero</span> so that the first PCs </span><br><span class="line">  # with <span class="number">2</span> MB would run software that assumed <span class="number">1</span> MB.  Undo that.</span><br><span class="line"><span class="symbol">seta20.1:</span></span><br><span class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy</span><br><span class="line">  testb   <span class="number">$0</span>x2,%al</span><br><span class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.1</span></span><br><span class="line"></span><br><span class="line">  movb    <span class="number">$0</span>xd1,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></span><br><span class="line">  outb    %al,<span class="number">$0</span>x64</span><br><span class="line"></span><br><span class="line"><span class="symbol">seta20.2:</span></span><br><span class="line">  inb     <span class="number">$0</span>x64,%al               # Wait for <span class="keyword">not</span> busy</span><br><span class="line">  testb   <span class="number">$0</span>x2,%al</span><br><span class="line">  <span class="keyword">jnz</span>     seta20<span class="meta">.2</span></span><br><span class="line"></span><br><span class="line">  movb    <span class="number">$0</span>xdf,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></span><br><span class="line">  outb    %al,<span class="number">$0</span>x60</span><br></pre></td></tr></tbody></table></figure><ul><li>由於 real mode 只有 16-bit 的暫存器，導致一個程式如果要使用超過 65536 bytes 的記憶體會很困難，也不可能使用超過 1MB 的記憶體。</li><li>x86 從 80286 開始有 <strong>protected mode</strong>，允許物理位置能擁有更多 bits，從 80386 後有 32-bit 模式。</li><li>Boot loader 接著開啟 protected mode 和 32-bit 模式。</li><li>在 protected mode 下的段暫存器保存著段描述符表的索引。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/vGzE58G.png" data-sub-html=".caption"><img src="https://i.imgur.com/vGzE58G.png" alt="segment" title="Segments in protected mode."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">segment</span></div></div></p><ul><li>Limits 代表最大的虛擬地址</li><li>段描述符表包含一個權限(被 protected mode 保護)，kernel 可以使用這個權限確保一個程式只會使用自己的記憶體。</li></ul><div class="alert alert-warning"><p>XV6 幾乎不用段，取而代之的是分頁。</p></div><ul><li>Boot loader 設定段描述符表 gdt，每一段的基址為 0，且 limit 為 4GB (2^32)。</li><li>Flag 使程式碼會在 32-bit 中執行。</li><li>由上述設定能確保當 boot loader 進入 protected mode 時，邏輯地址映射到物理地址會是 1-1 的。</li><li><code>lgdt</code> 指令將 GDT 暫存器(指向 gdt) 載入 gdtdesc 的值。</li></ul><details class="alert alert-secondary"><summary>GDT 補充</summary><p>在創建 GDT 的時候，第一項須為空(規定)，接著我們為此臨時的 GDT 設立 code 及 data 段。</p><figure class="highlight x86asm"><table><tbody><tr><td class="code"><pre><span class="line"># Line <span class="number">78</span> <span class="keyword">in</span> bootasm.S</span><br><span class="line"># Bootstrap GDT</span><br><span class="line"><span class="meta">.p2align</span> <span class="number">2</span>                                   # force <span class="number">4</span> <span class="built_in">byte</span> alignment</span><br><span class="line"><span class="symbol">gdt:</span></span><br><span class="line">     SEG_NULLASM                             # null <span class="built_in">seg</span></span><br><span class="line">     SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)   # code <span class="built_in">seg</span></span><br><span class="line">     SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)         # data <span class="built_in">seg</span></span><br><span class="line"><span class="symbol">gdtdesc:</span></span><br><span class="line"><span class="meta">     .word</span>   (gdtdesc - gdt - <span class="number">1</span>)             # sizeof(gdt) - <span class="number">1</span></span><br><span class="line"><span class="meta">     .long</span>   gdt                             # address gdt</span><br></pre></td></tr></tbody></table></figure></details><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode.  Use a bootstrap GDT that makes</span><br><span class="line"># virtual addresses map directly to physical addresses so that the</span><br><span class="line"># effective memory map doesn<span class="string">'t change during the transition.</span></span><br><span class="line"><span class="string">lgdt    gdtdesc</span></span><br></pre></td></tr></tbody></table></figure><ul><li>Boot loader 將 <code>%cr0</code> 中的 <code>CRO_PE</code> 設為 1，來啟用 protected mode。</li><li>啟用 protceted mode 不會立即改變處理器轉譯邏輯地址的過程；只有當段暫存器載入了新的值，處理器讀取 GDT 改變其內部的斷設定。</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ljmp</code> 指令語法：<code>ljmp segment offset</code>，此時段暫存器為 <code>SEG_KCODE&lt;&lt;3</code>，即 8 (<code>SEG_KCODE == 1</code>，定義於<code>mmu.h</code>)</li><li><code>ljmp</code> 指令跳至 start32 執行。</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//PAGEBREAK!</span><br><span class="line">  # Complete transition to <span class="number">32</span>-bit protected mode by using long <span class="keyword">jmp</span></span><br><span class="line">  # to reload %cs <span class="keyword">and</span> %eip.  The <span class="meta">segment</span> descriptors are set <span class="meta">up</span> with no</span><br><span class="line">  # translation, so that the mapping is still the identity mapping.</span><br><span class="line">  ljmp    $(SEG_KCODE&lt;&lt;<span class="number">3</span>), $start32</span><br></pre></td></tr></tbody></table></figure><ul><li>進入 32 位元後的第一個動作：用<code>SEG_KDATA</code>初始化數據段暫存器</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.code32</span>  # Tell assembler to generate <span class="number">32</span>-bit code now.</span><br><span class="line"><span class="symbol">start32:</span></span><br><span class="line">  # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers</span><br><span class="line">  movw    $(SEG_KDATA&lt;&lt;<span class="number">3</span>), %ax    # Our data <span class="meta">segment</span> selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></span><br><span class="line">  movw    %ax, %es                # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></span><br><span class="line">  movw    %ax, %ss                # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></span><br><span class="line">  movw    <span class="number">$0</span>, %ax                 # <span class="meta">Zero</span> segments <span class="keyword">not</span> ready for use</span><br><span class="line">  movw    %ax, %fs                # -&gt; <span class="built_in">FS</span></span><br><span class="line">  movw    %ax, %gs                # -&gt; <span class="built_in">GS</span></span><br></pre></td></tr></tbody></table></figure><ul><li>最後建立一個 stack，跳至 <em>bootmain.c</em>。</li><li>記憶體 0xa0000 至 0x100000 為設備區，XV6 kernel 放在 0x100000。</li><li>Boot loader 位於 0x7c00 至 0x7e00 (512 bytes)，所以其他位置都能拿來建立堆疊；這裡選擇 0x7c00 當作 top (<code>$start</code>)，堆疊向下延伸，直到 0x0000。</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C.</span><br><span class="line">movl    $start, %esp</span><br><span class="line"><span class="keyword">call</span>    bootmain</span><br></pre></td></tr></tbody></table></figure><ul><li>如果出錯了，會向 0x8a00 端輸出一些字。</li><li>實際上沒有設備連接到 0x8a00。</li><li>如果使用模擬器，boot loader 會把控制權還給模擬器。</li></ul><div class="alert alert-warning"><p>真正的 boot loader 會印出一些錯誤訊息。</p></div><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># If bootmain returns (it shouldnt), trigger a Bochs</span><br><span class="line"># breakpoint if running under Bochs, then <span class="keyword">loop</span>.</span><br><span class="line">movw    <span class="number">$0</span>x8a00, %ax            # <span class="number">0x8a00</span> -&gt; port <span class="number">0x8a00</span></span><br><span class="line">movw    %ax, %dx</span><br><span class="line">outw    %ax, %dx</span><br><span class="line">movw    <span class="number">$0</span>x8ae0, %ax            # <span class="number">0x8ae0</span> -&gt; port <span class="number">0x8a00</span></span><br><span class="line">outw    %ax, %dx</span><br></pre></td></tr></tbody></table></figure><ul><li>接著進入無限迴圈</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spin:</span></span><br><span class="line">  <span class="keyword">jmp</span>     spin</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-C-bootstrap">Code: C bootstrap<a class="header-anchor" href="#Code-C-bootstrap">#</a></h2><h3 id="File-bootmain-c">File: bootmain.c<a class="header-anchor" href="#File-bootmain-c">#</a></h3><ul><li><em>bootmain</em> 的工作：載入並執行 kernel。</li><li>Kernel 為 ELF 格式的二進位檔。</li></ul><div class="alert alert-info"><p>ELF(Executable and Linking Format) ，為 UNIX 中的目錄檔格式。</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>開機程序（執行 kernel)</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boot loader.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Part of the boot sector, along with bootasm.S, which calls bootmain().</span></span><br><span class="line"><span class="comment">// bootasm.S has put the processor into protected 32-bit mode.</span></span><br><span class="line"><span class="comment">// bootmain() loads an ELF kernel image from the disk starting at</span></span><br><span class="line"><span class="comment">// sector 1 and then jumps to the kernel entry routine.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"elf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"x86.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memlayout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE  512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(uchar*, uint, uint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">  <span class="keyword">void</span> (*entry)(<span class="keyword">void</span>);</span><br><span class="line">  uchar* pa;</span><br></pre></td></tr></tbody></table></figure><ul><li>為了存取 ELF 開頭，<em>bootmain</em> 載入 ELF 文件的前 4096 bytes，並拷貝到 010000 中。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">elf = (struct elfhdr*)<span class="number">0x10000</span>;  <span class="comment">// scratch space</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 1st page off disk</span></span><br><span class="line">readseg((uchar*)elf, <span class="number">4096</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著確認是否為 ELF 文件。</li></ul><div class="alert alert-danger"><p>正常情況下 <em>bootmain</em> 不會<code>return</code>，這裡<code>return</code>會跳回 <em>bootasm.S</em> 中，由 <em>bootasm.S</em> 來處理此錯誤。</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Is this an ELF executable?</span></span><br><span class="line"><span class="keyword">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">// let bootasm.S handle error</span></span><br></pre></td></tr></tbody></table></figure><ul><li><em>bootmain</em> 從 ELF 開頭之後的 off bytes 讀取內容，並存入 paddr 中(呼叫<code>readseg</code>)。</li><li>呼叫<code>stosb</code>將段的剩餘部分設 0</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load each program segment (ignores ph flags).</span></span><br><span class="line">ph = (struct proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class="line">eph = ph + elf-&gt;phnum;</span><br><span class="line"><span class="keyword">for</span>(; ph &lt; eph; ph++){</span><br><span class="line">  pa = (uchar*)ph-&gt;paddr;</span><br><span class="line">  readseg(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class="line">  <span class="keyword">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class="line">    stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Boot loader 最後一項工作：呼叫 kernel 的進入指令，即 kernel 第一條執行指令的地址(0x10000c)。</li><li><em>entry.S</em> 中定義的<code>_start</code>即為 ELF 入口。</li><li>XV6 虛擬記憶體尚未建立，因此 entry 為物理地址。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Call the entry point from the ELF header.</span></span><br><span class="line">  <span class="comment">// Does not return!</span></span><br><span class="line">  entry = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>))(elf-&gt;entry);</span><br><span class="line">  entry();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p><strong>函數指標</strong>的補充<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[指標函數和函數指標有什麼區別](http://bluelove1968.pixnet.net/blog/post/222285883-%E6%8C%87%E6%A8%99%E5%87%BD%E6%95%B8%E5%92%8C%E5%87%BD%E6%95%B8%E6%8C%87%E6%A8%99%E6%9C%89%E4%BB%80%E9%BA%BC%E5%8D%80%E5%88%A5)">[1]</span></a></sup>：<br><br>上述用一個 <code>void (*entry)(void)</code> 指標即為一個函數指標，此指標指向一個函數，於上述 42 行將此指標指向 <code>elf-&gt;entry</code>，此動作將 <code>entry</code> 指標指向一個函數的進入點位置（<code>elf-&gt;entry</code>）。<br>此時呼叫 <code>entry()</code> 會進入此指標位置，並當作一個副函式執行；因此執行完上述程式碼會進入 <em>entry.S</em>，並執行其中的程式碼。</p></div><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>等待磁碟</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">waitdisk(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">// Wait for disk ready.</span></span><br><span class="line">  <span class="keyword">while</span>((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">    ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>讀取一個磁碟區</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*dst</code></th><th><code>offset</code></th></tr></thead><tbody><tr><td>目標磁碟</td><td>目標磁碟區</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read a single sector at offset into dst.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, uint offset)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">// Issue command.</span></span><br><span class="line">  waitdisk();</span><br><span class="line">  outb(<span class="number">0x1F2</span>, <span class="number">1</span>);   <span class="comment">// count = 1</span></span><br><span class="line">  outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">  outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">  outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);  <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read data.</span></span><br><span class="line">  waitdisk();</span><br><span class="line">  insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>讀取一段磁碟資料</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*pa</code></th><th><code>count | </code>offset`</th></tr></thead><tbody><tr><td>目標位址</td><td>數量</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// Might copy more than asked.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readseg(uchar* pa, uint count, uint offset)</span><br><span class="line">{</span><br><span class="line">  uchar* epa;</span><br><span class="line"></span><br><span class="line">  epa = pa + count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Round down to sector boundary.</span></span><br><span class="line">  pa -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Translate from bytes to sectors; kernel starts at sector 1.</span></span><br><span class="line">  offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">  <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">  <span class="comment">// we load in increasing order.</span></span><br><span class="line">  <span class="keyword">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)</span><br><span class="line">    readsect(pa, offset);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://bluelove1968.pixnet.net/blog/post/222285883-%E6%8C%87%E6%A8%99%E5%87%BD%E6%95%B8%E5%92%8C%E5%87%BD%E6%95%B8%E6%8C%87%E6%A8%99%E6%9C%89%E4%BB%80%E9%BA%BC%E5%8D%80%E5%88%A5" target="_blank" rel="noopener">指標函數和函數指標有什麼區別</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - PC Hardware</title>
      <link href="/posts/xv6/hardware.html"/>
      <url>/posts/xv6/hardware.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="通用暫存器">通用暫存器<a class="header-anchor" href="#通用暫存器">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Name</th><th>Function</th></tr></thead><tbody><tr><td><code>%eax</code></td><td>Accumulator 累加器</td></tr><tr><td><code>%ebx</code></td><td>Based 基址暫存器</td></tr><tr><td><code>%ecx</code></td><td>Counter 計數器</td></tr><tr><td><code>%edx</code></td><td>Data 數據暫存器</td></tr><tr><td><code>%edi</code></td><td>Destination Index 目的地址指針暫存器</td></tr><tr><td><code>%esi</code></td><td>Source Index 源地址指針暫存器</td></tr><tr><td><code>%ebp</code></td><td>Based 基址指針暫存器</td></tr><tr><td><code>%esp</code></td><td>Stack 堆疊指針暫存器</td></tr></tbody></table></div><ul><li><strong>程式計數器</strong> <code>%eip</code>：Instruction Pointer 指令指針暫存器</li></ul><p><code>e</code> 指的是 extended，為 16 位元暫存器的 32 位元擴展。<br>同時 <code>%ax</code> 為 <code>%eax</code> 的低位，以此類推；修改任意一個都會影響另一個。<br>另外，前四個暫存器有另一套低位別名：<code>%al</code>、<code>%ah</code>…etc，低八位為 <code>%al</code>，高八位為 <code>%ah</code>。</p><p><div class="img-item" data-src="https://i.imgur.com/biz7b4q.png" data-sub-html=".caption"><img src="https://i.imgur.com/biz7b4q.png" alt="eax" title="Layout of eax."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">eax</span></div></div></p><hr><h2 id="控制暫存器">控制暫存器<a class="header-anchor" href="#控制暫存器">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Name</th><th>Function</th></tr></thead><tbody><tr><td><code>%cr0</code></td><td>包含了兩個標誌：</td></tr><tr><td></td><td>0 位（PE）用於啟動 <strong>protected mode</strong>，若 PE = 1，則啟動 protected mode，為 0 則在 <strong>real mode</strong> 下運行。</td></tr><tr><td></td><td>31 位（PG）為分頁允許位，用來表示分頁硬體是否允許作業</td></tr><tr><td><code>%cr1</code></td><td>保留</td></tr><tr><td><code>%cr2</code></td><td>保存最後一次出現夜故障時的32位線性地址</td></tr><tr><td><code>%cr3</code></td><td>保存頁目錄表的物理地址</td></tr></tbody></table></div><p><div class="img-item" data-src="https://i.imgur.com/LjEa8lY.png" data-sub-html=".caption"><img src="https://i.imgur.com/LjEa8lY.png" alt="cr" title="Layout of CR."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">cr</span></div></div></p><hr><h2 id="段暫存器">段暫存器<a class="header-anchor" href="#段暫存器">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Name</th><th>Function</th><th>Name</th><th>Function</th></tr></thead><tbody><tr><td><code>%cs</code></td><td>Code Segment</td><td><code>%es</code></td><td>extra Segment</td></tr><tr><td><code>%ds</code></td><td>Data Segment</td><td><code>%fs</code></td><td>extra Segment</td></tr><tr><td><code>%fs</code></td><td>Stack Segment</td><td><code>%gs</code></td><td>extra Segment</td></tr></tbody></table></div><hr><h2 id="其他">其他<a class="header-anchor" href="#其他">#</a></h2><ul><li><p><code>%gdtr</code> 全域段描述符表、<code>%ldtr</code> 區域段描述符表<br>（參考<a href="/xv6-b-bootloader/#gdt">Appendix B</a>)</p></li><li><p><code>%eflags</code> <strong>標誌暫存器</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[X86 彙編/X86 架構](https://zh.wikibooks.org/zh-tw/X86_汇编/X86_架构#16-位通用暂存器_(通存器_GPR)">[1]</span></a></sup></p><p><div class="img-item" data-src="https://i.imgur.com/tfPZm5w.png" data-sub-html=".caption"><img src="https://i.imgur.com/tfPZm5w.png" alt="eflags" title="Layout of eflags."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">eflags</span></div></div></p><ul><li>灰色為保留位，值不變<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[x86—EFLAGS寄存器详解](https://blog.csdn.net/jn1158359135/article/details/7761011)">[2]</span></a></sup></li></ul></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>Name</th><th>Function</th><th>Name</th><th>Function</th></tr></thead><tbody><tr><td>CF</td><td>Carry Flag</td><td>IOPL</td><td>I/O Privilege Level field</td></tr><tr><td>PF</td><td>Parity Flag</td><td>NT</td><td>Nested Task flag</td></tr><tr><td>AF</td><td>Auxiliary Carry Flag</td><td>RF</td><td>Resume Flag</td></tr><tr><td>ZF</td><td>Zero Flag</td><td>VM</td><td>Virtual-8086 Mode Flag</td></tr><tr><td>SF</td><td>Sign Flag</td><td>AC</td><td>Alignment Check Flag</td></tr><tr><td>TF</td><td>Trap Flag</td><td>VIF</td><td>Virtual Interrupt Flag</td></tr><tr><td>IF</td><td>Interrupt Enable Flag</td><td>VIP</td><td>Virtual Interrupt Pending flag</td></tr><tr><td>DF</td><td>Direction Flag</td><td>ID</td><td>Identification Flag</td></tr><tr><td>OF</td><td>Overflow Flag</td><td></td><td></td></tr></tbody></table></div><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[X86 彙編/X86 架構](https://zh.wikibooks.org/zh-tw/X86_汇编/X86_架构#16-位通用暂存器_(通存器_GPR)<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.csdn.net/jn1158359135/article/details/7761011" target="_blank" rel="noopener">x86—EFLAGS寄存器详解</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - File System</title>
      <link href="/posts/xv6/fs.html"/>
      <url>/posts/xv6/fs.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本文沒有按照 XV6 官方文本的順序介紹</p></blockquote><h2 id="概觀">概觀<a class="header-anchor" href="#概觀">#</a></h2><ul><li>XV6 的檔案系統分為 6 層，本文將從上到下介紹。<br><div class="img-item" data-src="https://i.imgur.com/yTmir5p.png" data-sub-html=".caption"><img src="https://i.imgur.com/yTmir5p.png" alt="" title="Layers of the XV6 file system"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li></ul><hr><h2 id="檔案描述符">檔案描述符<a class="header-anchor" href="#檔案描述符">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> proc.h</p></div><ul><li>UNIX 大部分的資源都是一個文件，而此統一性由檔案描述符實現。</li><li>每個 process 都有一個表記錄著開啟的文件（行 13），一個開啟的文件即為 <code>struct file</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> {</span></span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;                <span class="comment">// Page table</span></span><br><span class="line">  <span class="keyword">char</span> *kstack;                <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="keyword">enum</span> procstate state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> pid;            <span class="comment">// Process ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// Trap frame for current syscall</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>     <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-success"><p><strong>File:</strong> file.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> {</span></span><br><span class="line">  <span class="keyword">enum</span> { FD_NONE, FD_PIPE, FD_INODE } type;</span><br><span class="line">  <span class="keyword">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="keyword">char</span> readable;</span><br><span class="line">  <span class="keyword">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  uint off;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-success"><p><strong>File:</strong> proc.c</p></div><ul><li>所有的 open files 皆被存放在 <code>ftable</code> 中：</li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">} ftable;</span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> file.c</p></div><h3 id="Code-filealloc、dup-and-close">Code: filealloc、dup and close<a class="header-anchor" href="#Code-filealloc、dup-and-close">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立一個檔案</td><td>檔案結構</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class"><span class="title">filealloc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++){</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>){</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>filealloc</code> 在 <code>ftable</code> 找到一個 <code>f-&gt;ref</code> 為零的，並返回。</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*f</code></th></tr></thead><tbody><tr><td>再次一個檔案</td><td>開啟的檔案結構</td><td>欲開啟的檔案</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class"><span class="title">filedup</span>(<span class="title">struct</span> <span class="title">file</span> *<span class="title">f</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"filedup"</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>filedup</code> 增加引用次數。</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*f</code></th></tr></thead><tbody><tr><td>關閉檔案</td><td>void</td><td>欲關閉的檔案</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fileclose(struct file *f)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"fileclose"</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>){</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>fileclose</code> 減少引用次數。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE){</span><br><span class="line">    begin_trans();</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    commit_trans();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若引用次數降為 0 時，則依據類型的不同釋放當前的 pipe 或是 inode。</li></ul><h3 id="Code-filestat、read-and-write">Code: filestat、read and write<a class="header-anchor" href="#Code-filestat、read-and-write">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>讀取檔案狀態</td><td>0 (ok) / -1 (err)</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*f</code></th><th><code>*st</code></th></tr></thead><tbody><tr><td>欲讀取的檔案</td><td>寫入狀態的結構</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">filestat(struct file *f, struct stat *st)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE){</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>須為 <code>inode</code> 才可使用 <code>filestat</code>，通過呼叫 <code>stati</code> 來實現操作。</li></ul><hr><p><i class="fa fa-code"></i> Code: <code>fileread</code></p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>讀取檔案</td><td>讀取大小</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*f</code></th><th><code>*addr</code></th><th><code>n</code></th></tr></thead><tbody><tr><td>欲讀取的檔案</td><td>欲寫入資料的記憶體</td><td>欲寫入的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">fileread(struct file *f, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)</span><br><span class="line">    <span class="keyword">return</span> piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE){</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  }</span><br><span class="line">  panic(<span class="string">"fileread"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>fileread</code> 針對不同類型有不同的操作：<ul><li>pipe：呼叫 <code>piperead</code>，於 <a href="https://omuskywalker.github.io/2018/08/14/ch5/#piperead" target="_blank" rel="noopener">ch5</a> 介紹過。</li><li>inode：由 <code>readi</code> 完成動作，下面會介紹。</li></ul></li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>寫入檔案</td><td>寫入大小</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*f</code></th><th><code>*addr</code></th><th><code>n</code></th></tr></thead><tbody><tr><td>欲寫入的檔案</td><td>欲寫入的資料</td><td>欲寫入的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">filewrite(struct file *f, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)</span><br><span class="line">    <span class="keyword">return</span> pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE){</span><br><span class="line">    <span class="comment">// write a few blocks at a time to avoid exceeding</span></span><br><span class="line">    <span class="comment">// the maximum log transaction size, including</span></span><br><span class="line">    <span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line">    <span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line">    <span class="comment">// this really belongs lower down, since writei()</span></span><br><span class="line">    <span class="comment">// might be writing a device like the console.</span></span><br><span class="line">    <span class="keyword">int</span> max = ((LOGSIZE<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n){</span><br><span class="line">      <span class="keyword">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_trans();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      commit_trans();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(r != n1)</span><br><span class="line">        panic(<span class="string">"short filewrite"</span>);</span><br><span class="line">      i += r;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i == n ? n : <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  panic(<span class="string">"filewrite"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>filewrite</code> 針對不同類型有不同的操作：<ul><li>pipe：呼叫 <code>pipewrite</code>，於 <a href="https://omuskywalker.github.io/2018/08/14/ch5/#pipewrite" target="_blank" rel="noopener">ch5</a> 介紹過。</li><li>inode：由 <code>writei</code> 完成動作，下面會介紹。</li></ul></li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> fs.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>寫入檔案狀態</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*ip</code></th><th><code>*st</code></th></tr></thead><tbody><tr><td>欲讀取的檔案</td><td>寫入狀態的結構</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy stat information from inode.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">stati(struct inode *ip, struct stat *st)</span><br><span class="line">{</span><br><span class="line">  st-&gt;dev = ip-&gt;dev;</span><br><span class="line">  st-&gt;ino = ip-&gt;inum;</span><br><span class="line">  st-&gt;type = ip-&gt;type;</span><br><span class="line">  st-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">  st-&gt;size = ip-&gt;size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-Path-names">Code: Path names<a class="header-anchor" href="#Code-Path-names">#</a></h2><h3 id="namex">namex<a class="header-anchor" href="#namex">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>從路徑尋找檔案</td><td>inode 結構</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*path</code></th><th><code>nameiparent</code></th><th><code>*name</code></th></tr></thead><tbody><tr><td>路徑名</td><td>-</td><td>-</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">namex</span>(<span class="title">char</span> *<span class="title">path</span>, <span class="title">int</span> <span class="title">nameiparent</span>, <span class="title">char</span> *<span class="title">name</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">'/'</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>){</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR){</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">'\0'</span>){</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>){</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(nameiparent){</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-目錄">Code: 目錄<a class="header-anchor" href="#Code-目錄">#</a></h2><ul><li>目錄的 inode type 為 <code>T_DIR</code>，存在 <code>struct dirent</code> 中。</li></ul><div class="alert alert-success"><p><strong>File:</strong> file.</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> {</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="keyword">char</span> name[DIRSIZ];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>inum</code> 為 inode 編號，為 0 的代表可用。</li></ul><hr><h2 id="Inode">Inode<a class="header-anchor" href="#Inode">#</a></h2><hr><h2 id="Logging">Logging<a class="header-anchor" href="#Logging">#</a></h2><hr><h2 id="Buffer">Buffer<a class="header-anchor" href="#Buffer">#</a></h2><ul><li>buffer 有兩個任務：<ol><li>同步硬碟，保證只會有一份拷貝放在記憶體，並只有一個 kernel thread 使用。</li><li>快取常用的 block 以提升性能 (<em>bio.c</em>);</li></ol></li></ul><h3 id="Code-Buffer-cache">Code: Buffer cache<a class="header-anchor" href="#Code-Buffer-cache">#</a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - Scheduling</title>
      <link href="/posts/xv6/scheduler.html"/>
      <url>/posts/xv6/scheduler.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Multiplexing">Multiplexing<a class="header-anchor" href="#Multiplexing">#</a></h2><ul><li>如果 process 需要等待 I/O 或是子 process 結束，XV6 讓其進入睡眠狀態，接著將處理器 switch 給其他 process。</li><li>此機制使 process 有獨佔 CPU 的假象。</li><li>完成 switch 的動作由 context switch 完成：<ul><li>透明化 -&gt; 使用 <strong>timer interrupt handler</strong> 驅動 context switch。</li><li>同時多個 process 需要 switch -&gt; lock</li></ul></li></ul><hr><h2 id="Code-Context-switch">Code: Context switch<a class="header-anchor" href="#Code-Context-switch">#</a></h2><ul><li>從 process 的 kernel stack -&gt; schedluler kernel stack (CPU) -&gt; 另一個 process 的 kernel stack。</li><li>永遠不會從 process 的 kernel stack -&gt; process 的 kernel stack。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/qtfH1Vj.png" data-sub-html=".caption"><img src="https://i.imgur.com/qtfH1Vj.png" alt="context switch" title="Switching from one user process to another."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">context switch</span></div></div></p><ul><li>每個 process 都有自己的 kernel stack 及暫存器集合，每個 CPU 有自己的 scheduler stack。</li><li>context 即 process 的暫存器集合，用一個 <code>struct context *</code> 表示。</li></ul><div class="alert alert-success"><p><strong>File:</strong> proc.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> {</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>trap 有可能會呼叫 <code>yield</code>，<code>yield</code> 會呼叫 <code>sched</code>，最後 <code>sched</code> 呼叫 <code>swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</code>。</li></ul><h3 id="File-swtch-S">File: swtch.S<a class="header-anchor" href="#File-swtch-S">#</a></h3><ul><li><em>swtch</em> 有兩個參數：<code>struct context ** old</code>、<code>struct context * new</code>。</li></ul><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context **old, struct context *new)<span class="comment">;</span></span><br><span class="line"># </span><br><span class="line"># Save current register context <span class="keyword">in</span> old</span><br><span class="line"># <span class="keyword">and</span> then load register context from new.</span><br><span class="line"></span><br><span class="line"><span class="meta">.globl</span> swtch</span><br><span class="line"><span class="symbol">swtch:</span></span><br><span class="line">  movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">  movl <span class="number">8</span>(%esp), %edx</span><br></pre></td></tr></tbody></table></figure><ul><li>將 <code>%eax</code> 指向 <code>struct context ** old</code>，<code>%ebx</code> 指向 <code>struct context * new</code>。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/0QWW7gZ.png" data-sub-html=".caption"><img src="https://i.imgur.com/0QWW7gZ.png" alt="swtch" title="Context switch step. 1"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">swtch</span></div></div></p><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Save old callee-save registers</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br></pre></td></tr></tbody></table></figure><ul><li>依序將 context push 進堆疊</li></ul><p><div class="img-item" data-src="https://i.imgur.com/CXUNIYY.png" data-sub-html=".caption"><img src="https://i.imgur.com/CXUNIYY.png" alt="swtch" title="Context switch step. 2"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">swtch</span></div></div></p><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Switch stacks</span><br><span class="line">movl %esp, (%eax)</span><br><span class="line">movl %edx, %esp</span><br></pre></td></tr></tbody></table></figure><ul><li>將 <code>struct context ** old</code>（<code>%eax</code>） 指向 <code>%esp</code>（當前堆疊的 <strong>top</strong>）</li><li>將 <code>%esp</code> 指向 <code>struct context * new</code>（<code>%ebx</code>）</li></ul><p><div class="img-item" data-src="https://i.imgur.com/AB38T7t.png" data-sub-html=".caption"><img src="https://i.imgur.com/AB38T7t.png" alt="swtch" title="Context switch step. 3"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">swtch</span></div></div></p><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Load new callee-save registers</span><br><span class="line">popl %edi</span><br><span class="line">popl %esi</span><br><span class="line">popl %ebx</span><br><span class="line">popl %ebp</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></tbody></table></figure><ul><li>恢復保存的暫存器，用<code>ret</code> 指令跳回</li></ul><hr><h2 id="Scheduling">Scheduling<a class="header-anchor" href="#Scheduling">#</a></h2><ul><li>process 要讓出 CPU 前需要先取得 ptable.lock，釋放其他擁有的鎖，修改 p-&gt;state，呼叫 <code>sched</code>。</li><li><code>sched</code> 會再次檢查以上動作，並且確定此時中斷是關閉的，最後呼叫 <code>swtch</code>，將 process 的暫存器保存在 proc-&gt;context，switch 到 cpu-&gt;scheduler。</li></ul><div class="alert alert-success"><p><strong>File:</strong> proc.c</p></div><h3 id="sched">sched<a class="header-anchor" href="#sched">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>檢查並跳至 swtch.h</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;ptable.lock))</span><br><span class="line">    panic(<span class="string">"sched ptable.lock"</span>);</span><br><span class="line">  <span class="keyword">if</span>(cpu-&gt;ncli != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"sched locks"</span>);</span><br><span class="line">  <span class="keyword">if</span>(proc-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">"sched running"</span>);</span><br><span class="line">  <span class="keyword">if</span>(readeflags()&amp;FL_IF)</span><br><span class="line">    panic(<span class="string">"sched interruptible"</span>);</span><br><span class="line">  intena = cpu-&gt;intena;</span><br><span class="line">  swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</span><br><span class="line">  cpu-&gt;intena = intena;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>swtch</code> 會 return 回 scheduler 的堆疊上，scheduler 繼續執行迴圈：找到一個 process 運行，<code>swtch</code> 到該 process，repeat。</li></ul><h3 id="scheduler">scheduler<a class="header-anchor" href="#scheduler">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>執行調度，指定執行的 process</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">scheduler(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;){</span><br><span class="line">    <span class="comment">// Enable interrupts on this processor.</span></span><br><span class="line">    sti();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over process table looking for process to run.</span></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != RUNNABLE)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">      <span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line">      <span class="comment">// before jumping back to us.</span></span><br><span class="line">      proc = p;</span><br><span class="line">      switchuvm(p);</span><br><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line">      swtch(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">      switchkvm();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      proc = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>scheduler</code> 找到一個 <code>RUNNABLE</code> 的 process，將 per-cpu 設為此 process，呼叫 <code>switchuvm</code> 切換到該 process 的頁表，更新狀態為<code>RUNNING</code>，<code>swtch</code> 到該 process 中運行。</li></ul><hr><h2 id="Code-mycpu-and-myproc">Code:  mycpu  and  myproc<a class="header-anchor" href="#Code-mycpu-and-myproc">#</a></h2><ul><li>CPU 需要辨識目前正在執行的 process，XV6 有一個 struct cpu 的陣列，裡面包含了一些 CPU 的資訊，及當前 process 的資訊。</li><li><code>mycpu</code> 尋找當前的 <code>lapicid</code> 是哪顆 CPU 的。</li></ul><h3 id="mycpu">mycpu<a class="header-anchor" href="#mycpu">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>找到目前所在的 CPU</td><td>CPU 結構指標</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span>*</span></span><br><span class="line"><span class="class"><span class="title">mycpu</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">int</span> apicid, i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(readeflags()&amp;FL_IF)</span><br><span class="line">    panic(<span class="string">"mycpu called with interrupts enabled\n"</span>);</span><br><span class="line">  </span><br><span class="line">  apicid = lapicid();</span><br><span class="line">  <span class="comment">// APIC IDs are not guaranteed to be contiguous. Maybe we should have</span></span><br><span class="line">  <span class="comment">// a reverse map, or reserve a register to store &amp;cpus[i].</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ncpu; ++i) {</span><br><span class="line">    <span class="keyword">if</span> (cpus[i].apicid == apicid)</span><br><span class="line">      <span class="keyword">return</span> &amp;cpus[i];</span><br><span class="line">  }</span><br><span class="line">  panic(<span class="string">"unknown apicid\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>myproc</code> 呼叫 <code>mycpu</code>，從正確的 CPU 上尋找當前的 process。</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>找到當前的 process</td><td>proc 結構指標</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">myproc</span>(<span class="title">void</span>) {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  pushcli();</span><br><span class="line">  c = mycpu();</span><br><span class="line">  p = c-&gt;proc;</span><br><span class="line">  popcli();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="睡眠與喚醒（例子）">睡眠與喚醒（例子）<a class="header-anchor" href="#睡眠與喚醒（例子）">#</a></h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">q</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">send(struct q *q, <span class="keyword">void</span> *p)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;ptr != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    q-&gt;ptr = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">recv(struct q * q)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">while</span>((p = q-&gt;ptr) == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    q-&gt;ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>send</code> 直到隊伍 <code>q</code> 為空時，將要傳送的資料 <code>p</code> 放入隊中，<code>recv</code> 直到 <code>q</code> 有東西時將資料取出，把 <code>q</code> 再次設為 <code>0</code></li><li>這允許不同的 process 交換資料，但是很耗資源。</li></ul><h3 id="方案-1">方案 1<a class="header-anchor" href="#方案-1">#</a></h3><ul><li>加入 <code>sleep</code> 及 <code>wakeup</code> 機制，<code>sleep(chan)</code> 將 process 在 <code>chan</code> 中睡眠（一個 wait channel），<code>wakeup(chan)</code> 將 <code>chan</code> 上睡眠的 process 喚醒。</li></ul><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">void*</span><br><span class="line">send(struct q *q, void *p)</span><br><span class="line">{</span><br><span class="line">    while(q-&gt;ptr != 0)</span><br><span class="line">        ;</span><br><span class="line">    q-&gt;ptr = p;</span><br><span class="line"><span class="addition">+    wakeup(q);    /*wake recv*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void*</span><br><span class="line">recv(struct q *q)</span><br><span class="line">{</span><br><span class="line">    void *p;</span><br><span class="line">    while((p = q-&gt;ptr) == 0)</span><br><span class="line"><span class="addition">+        sleep(q);</span></span><br><span class="line">    q-&gt;ptr = 0;</span><br><span class="line">    return p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如此一來 <code>recv</code> 能讓出 CPU，直到有人（<code>send</code>）將它喚醒。</li></ul><div class="alert alert-danger"><p><strong>問題</strong>：遺失的喚醒：<br><div class="img-item" data-src="https://i.imgur.com/aPcvuOZ.png" data-sub-html=".caption"><img src="https://i.imgur.com/aPcvuOZ.png" alt="遺失的喚醒" title="Example lost wakeup problem"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">遺失的喚醒</span></div></div></p><ul><li>假設 <code>recv</code> 在 215 行查看隊伍，發現需要睡眠，就在要呼叫 <code>sleep</code> 之前發生中斷，<code>send</code> 在其他的 CPU 將資料放進隊伍中，呼叫 <code>wakeup</code>，發現沒有正在休眠的 process，於是不做事；接著 <code>recv</code> 終於呼叫 <code>sleep</code> 進入睡眠。</li><li>此時，<code>revc</code> 正在等待 <code>send</code> 將它喚醒，但是 <code>send</code> 正在等待隊伍清空，清空的動作須由 <code>recv</code> 完成（休眠中），於是就產生了 <strong>deadlock</strong>。</li></ul></div><h3 id="方案-2">方案 2<a class="header-anchor" href="#方案-2">#</a></h3><ul><li>讓 <code>send</code> 及 <code>recv</code> 在睡眠及喚醒前都持有鎖。</li></ul><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">struct q {</span><br><span class="line">    struct spinlock lock;</span><br><span class="line">    void *ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">send(struct q *q, void *p)</span><br><span class="line">{</span><br><span class="line"><span class="addition">+    acquire(&amp;q-&gt;lock);</span></span><br><span class="line">    while(q-&gt;ptr != 0)</span><br><span class="line">        ;</span><br><span class="line">    q-&gt;ptr = p;</span><br><span class="line">    wakeup(q);</span><br><span class="line"><span class="addition">+    release(&amp;q-&gt;lock);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void*</span><br><span class="line">recv(struct q *q)</span><br><span class="line">{</span><br><span class="line">    void *p;</span><br><span class="line"><span class="addition">+    acquire(&amp;q-&gt;lock);</span></span><br><span class="line">    while((p = q-&gt;ptr) == 0)</span><br><span class="line">        sleep(q);</span><br><span class="line">    q-&gt;ptr = 0;</span><br><span class="line"><span class="addition">+    release(&amp;q-&gt;lock);</span></span><br><span class="line">    return p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>但這一樣有問題：<code>recv</code> 帶著鎖進入睡眠，<code>send</code> 也同時需要鎖來喚醒，於是就產生了 <strong>deadlock</strong>。</li></ul><h3 id="方案-3">方案 3<a class="header-anchor" href="#方案-3">#</a></h3><ul><li>在 <code>sleep</code> 時一併釋放鎖，也就是將鎖當成參數傳進去。</li></ul><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">struct q {</span><br><span class="line">    struct spinlock lock;</span><br><span class="line">    void *ptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">send(struct q *q, void *p)</span><br><span class="line">{</span><br><span class="line">    acquire(&amp;q-&gt;lock);</span><br><span class="line">    while(q-&gt;ptr != 0)</span><br><span class="line">        ;</span><br><span class="line">    q-&gt;ptr = p;</span><br><span class="line">    wakeup(q);</span><br><span class="line">    release(&amp;q-&gt;lock);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void*</span><br><span class="line">recv(struct q *q)</span><br><span class="line">{</span><br><span class="line">    void *p;</span><br><span class="line">    acquire(&amp;q-&gt;lock);</span><br><span class="line">    while((p = q-&gt;ptr) == 0)</span><br><span class="line"><span class="addition">+        sleep(q, &amp;q-&gt;lock);</span></span><br><span class="line">    q-&gt;ptr = 0;</span><br><span class="line">    release(&amp;q-&gt;lock);</span><br><span class="line">    return p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-睡眠與喚醒">Code: 睡眠與喚醒<a class="header-anchor" href="#Code-睡眠與喚醒">#</a></h2><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>副程式</th><th>目標</th></tr></thead><tbody><tr><td><code>sleep</code></td><td>將狀態改成 <code>SLEEPING</code>，呼叫 <code>sched</code> 釋放 CPU</td></tr><tr><td><code>wakeup</code></td><td>尋找狀態為 <code>SLEEPING</code> 的 process，改成 <code>RUNNABLE</code></td></tr></tbody></table></div><h3 id="sleep">sleep<a class="header-anchor" href="#sleep">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>讓 process 睡眠</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*chan</code></th><th><code>*lk</code></th></tr></thead><tbody><tr><td>欲睡眠的頻道</td><td>持有的鎖</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sleep(<span class="keyword">void</span> *chan, struct spinlock *lk)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"sleep"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(lk == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"sleep without lk"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先確保 process 存在，及持有鎖。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk != &amp;ptable.lock){  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">  acquire(&amp;ptable.lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">  release(lk);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著檢查是否持有 <code>ptable-&gt;lock</code>，如果沒有則要求一個，把 <code>lk</code> 釋出。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go to sleep.</span></span><br><span class="line">p-&gt;chan = chan;</span><br><span class="line">p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">sched();</span><br></pre></td></tr></tbody></table></figure><ul><li>睡眠，並呼叫 <code>sched</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;ptable.lock){  <span class="comment">//DOC: sleeplock2</span></span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="wakeup1">wakeup1<a class="header-anchor" href="#wakeup1">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*chan</code></th></tr></thead><tbody><tr><td>叫醒頻道上的 process</td><td>void</td><td>頻道</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">wakeup1(<span class="keyword">void</span> *chan)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan)</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="wakeup">wakeup<a class="header-anchor" href="#wakeup">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*chan</code></th></tr></thead><tbody><tr><td>叫醒頻道上的 process</td><td>void</td><td>頻道</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">wakeup(<span class="keyword">void</span> *chan)</span><br><span class="line">{</span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line">  wakeup1(chan);</span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>wakeup</code> 找到 <code>chan</code> 上在睡眠的 process，並喚醒。</li></ul><hr><h2 id="Code-Pipes">Code: Pipes<a class="header-anchor" href="#Code-Pipes">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> pipe.c</p></div><ul><li>pipe 為一個結構，包含一個鎖，一個 <code>buf</code> 等。</li><li>當 pipe 為空時，<code>nread == nwrite</code></li><li>當 pipe 為滿時，<code>nwrite == nread % PIPESIZE</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="keyword">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="keyword">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="keyword">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="pipewrite">pipewrite<a class="header-anchor" href="#pipewrite">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>寫入 pipe</td><td>寫入的大小</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*p</code></th><th><code>*addr</code></th><th><code>n</code></th></tr></thead><tbody><tr><td>欲寫入的 pipe</td><td>欲寫入的值</td><td>欲寫入的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">pipewrite(struct pipe *p, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;nwrite == p-&gt;nread + PIPESIZE){  <span class="comment">//DOC: pipewrite-full</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;readopen == <span class="number">0</span> || myproc()-&gt;killed){</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      }</span><br><span class="line">      wakeup(&amp;p-&gt;nread);</span><br><span class="line">      sleep(&amp;p-&gt;nwrite, &amp;p-&gt;lock);  <span class="comment">//DOC: pipewrite-sleep</span></span><br><span class="line">    }</span><br><span class="line">    p-&gt;data[p-&gt;nwrite++ % PIPESIZE] = addr[i];</span><br><span class="line">  }</span><br><span class="line">  wakeup(&amp;p-&gt;nread);  <span class="comment">//DOC: pipewrite-wakeup1</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先須取得鎖。</li><li><code>pipewrite</code> 從 0 開始將資料讀入 <code>buf</code>，更新 <code>nwrite</code> 計數器，當 <code>buf</code> 滿了，則喚醒 <code>piperead</code> 並睡眠；或是讀入完畢，一樣喚醒 <code>pipiread</code>。</li></ul><hr><h3 id="piperead">piperead<a class="header-anchor" href="#piperead">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>讀取 pipe</td><td>讀入的大小</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*p</code></th><th><code>*addr</code></th><th><code>n</code></th></tr></thead><tbody><tr><td>欲讀取的 pipe</td><td>讀取資料存放區</td><td>欲讀入的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">piperead(struct pipe *p, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;nread == p-&gt;nwrite &amp;&amp; p-&gt;writeopen){  <span class="comment">//DOC: pipe-empty</span></span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed){</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    sleep(&amp;p-&gt;nread, &amp;p-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;nread == p-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    addr[i] = p-&gt;data[p-&gt;nread++ % PIPESIZE];</span><br><span class="line">  }</span><br><span class="line">  wakeup(&amp;p-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先須取得鎖。</li><li><code>piperead</code> 確認 pipe 是否為空，為空則進入睡眠。</li><li>當 pipe 不為空時，寫入資料，更新 <code>nread</code> 計數器。</li><li>讀取完畢後，喚醒 <code>pipewrite</code>。</li></ul><hr><h2 id="Code-Wait-exit-and-kill">Code: Wait, exit and kill<a class="header-anchor" href="#Code-Wait-exit-and-kill">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> proc.c</p></div><h3 id="wait">wait<a class="header-anchor" href="#wait">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>等待子 process 結束</td><td>pid (ok) / -1 (err)</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">wait(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">for</span>(;;){</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;parent != curproc)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      havekids = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == ZOMBIE){</span><br><span class="line">        <span class="comment">// Found one.</span></span><br><span class="line">        pid = p-&gt;pid;</span><br><span class="line">        kfree(p-&gt;kstack);</span><br><span class="line">        p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        freevm(p-&gt;pgdir);</span><br><span class="line">        p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">        p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">        p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">        p-&gt;state = UNUSED;</span><br><span class="line">        release(&amp;ptable.lock);</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don't have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || curproc-&gt;killed){</span><br><span class="line">      release(&amp;ptable.lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for children to exit.  (See wakeup1 call in proc_exit.)</span></span><br><span class="line">    sleep(curproc, &amp;ptable.lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先須取得鎖。</li><li>接著尋找是否有子 process，如果有，並且還沒退出，則睡眠，等待子 process 退出。</li><li>如果找到已退出的子 process，紀錄該子 process 的 pid，清理 <code>struct proc</code>，釋放相關記憶體。</li></ul><hr><h3 id="exit">exit<a class="header-anchor" href="#exit">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>自行結束 process</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(curproc == initproc)</span><br><span class="line">    panic(<span class="string">"init exiting"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close all open files.</span></span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++){</span><br><span class="line">    <span class="keyword">if</span>(curproc-&gt;ofile[fd]){</span><br><span class="line">      fileclose(curproc-&gt;ofile[fd]);</span><br><span class="line">      curproc-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(curproc-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  curproc-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  wakeup1(curproc-&gt;parent);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass abandoned children to init.</span></span><br><span class="line">  <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;parent == curproc){</span><br><span class="line">      p-&gt;parent = initproc;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == ZOMBIE)</span><br><span class="line">        wakeup1(initproc);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  curproc-&gt;state = ZOMBIE;</span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">"zombie exit"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先須取得鎖。</li><li>喚醒父 process，將子 process 交給 <em>initproc</em>，修改狀態，呼叫 <code>sched</code> switch 至 scheduler。</li></ul><hr><h3 id="kill">kill<a class="header-anchor" href="#kill">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>pid</code></th></tr></thead><tbody><tr><td>使 process 終止</td><td>0 (ok) / -1 (err)</td><td>欲終止的 process id</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">kill(<span class="keyword">int</span> pid)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid){</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// Wake process from sleep if necessary.</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      release(&amp;ptable.lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>kill</code> 將 <code>p-&gt;killed</code> 設為 1 ，當此 process 發生中斷或是 system call 進入 kernel，離開時 <code>trap</code> 會檢查 <code>p-&gt;killed</code>，如果被設置了，則呼叫 <code>exit</code>。</li><li>當要被 kill 的 process 處於睡眠狀態，則喚醒它。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> scheduler </tag>
            
            <tag> XV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - Locking</title>
      <link href="/posts/xv6/lock.html"/>
      <url>/posts/xv6/lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Race-conditions">Race conditions<a class="header-anchor" href="#Race-conditions">#</a></h2><h3 id="例子">例子<a class="header-anchor" href="#例子">#</a></h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span> = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">insert(<span class="keyword">int</span> data)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">l</span>;</span></span><br><span class="line">    l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span> = l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><div class="img-item" data-src="https://i.imgur.com/T6893f9.png" data-sub-html=".caption"><img src="https://i.imgur.com/T6893f9.png" alt="" title="Example race"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><p>假設現在有兩個 process 同時在不同的 CPU 上執行上述程式碼，當兩個 process 都執行到 14 行，則兩條鏈結的 <code>next</code> 都設置為 <code>list</code>；接著，先執行的 process A 將 list 設定為自己的鏈結，後執行的 process B 也將 list 設為自己的鏈結。</p><p><strong>問題</strong>：此時 list 上將會遺失原本 process A <code>insert</code> 的節點。</p><h3 id="圖解">圖解<a class="header-anchor" href="#圖解">#</a></h3><ul><li>一開始的 list</li></ul><p><div class="img-item" data-src="https://i.imgur.com/2eXmAxp.png" data-sub-html=".caption"><img src="https://i.imgur.com/2eXmAxp.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><ul><li>假設 pocess A 及 B 同時將自己的資料插在 list 的第一顆<br><div class="img-item" data-src="https://i.imgur.com/h95r477.png" data-sub-html=".caption"><img src="https://i.imgur.com/h95r477.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li><li>接著 process A 以些微的差距先將 list 設為 l（自己的鏈結），此時 list 的第一顆為 A 的資料<br><div class="img-item" data-src="https://i.imgur.com/u0udl7M.png" data-sub-html=".caption"><img src="https://i.imgur.com/u0udl7M.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li><li>最後 process B 也將 list 設為 l，此時 list 上的第一顆為 B 的資料，且 A 的資料遺失了。<br><div class="img-item" data-src="https://i.imgur.com/B659a3t.png" data-sub-html=".caption"><img src="https://i.imgur.com/B659a3t.png" alt=""><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li></ul><h3 id="使用鎖">使用鎖<a class="header-anchor" href="#使用鎖">#</a></h3><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">struct list *list = 0;</span><br><span class="line">struct lock listlock;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">insert(int data)</span><br><span class="line">{</span><br><span class="line">    struct list *l;</span><br><span class="line"><span class="addition">+    acquire(&amp;listlock);</span></span><br><span class="line">    l = malloc(sizeof *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    l-&gt;next = list;</span><br><span class="line">    list = l;</span><br><span class="line"><span class="addition">+    release(&amp;listlock);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-鎖">Code: 鎖<a class="header-anchor" href="#Code-鎖">#</a></h2><ul><li>XV6 使用 <code>struct spinlock</code>，其中以 locked 作為標記。<ul><li>為 0 時，此鎖無人使用，可以被取用</li><li><strong>非</strong> 0 時，此鎖有人在使用，無法被取用</li></ul></li></ul><h3 id="File-spinlock-h">File: spinlock.h<a class="header-anchor" href="#File-spinlock-h">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> {</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="keyword">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">  uint pcs[<span class="number">10</span>];      <span class="comment">// The call stack (an array of program counters)</span></span><br><span class="line">                     <span class="comment">// that locked the lock.</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>邏輯上，<code>acquire</code> 應該長這樣：</li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(;;) {</span><br><span class="line">        <span class="keyword">if</span>(!lk-&gt;locked) {</span><br><span class="line">            lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>但是我們發現，可能會有多個 CPU 執行至第五行，發現 <code>lk-&gt;locked</code> 為 <code>0</code>，接著都拿到了鎖，即違反了互斥</li><li>XV6 使用 x86 的特殊指令 <code>xchg</code> 來完成動作。</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> spinlock.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*lk</code></th></tr></thead><tbody><tr><td>要求鎖</td><td>void</td><td>欲要求的鎖</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="comment">// Holding a lock for a long time may cause</span></span><br><span class="line"><span class="comment">// other CPUs to waste time spinning to acquire it.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">{</span><br><span class="line">  pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The xchg is atomic.</span></span><br><span class="line">  <span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">  <span class="comment">// reordered before it. </span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line">  lk-&gt;cpu = cpu;</span><br><span class="line">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*lk</code></th></tr></thead><tbody><tr><td>還鎖</td><td>void</td><td>欲還的鎖</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The xchg serializes, so that reads before release are </span></span><br><span class="line">  <span class="comment">// not reordered after it.  The 1996 PentiumPro manual (Volume 3,</span></span><br><span class="line">  <span class="comment">// 7.2) says reads can be carried out speculatively and in</span></span><br><span class="line">  <span class="comment">// any order, which implies we need to serialize here.</span></span><br><span class="line">  <span class="comment">// But the 2007 Intel 64 Architecture Memory Ordering White</span></span><br><span class="line">  <span class="comment">// Paper says that Intel 64 and IA-32 will not move a load</span></span><br><span class="line">  <span class="comment">// after a store. So lock-&gt;locked = 0 would work here.</span></span><br><span class="line">  <span class="comment">// The xchg being asm volatile ensures gcc emits it after</span></span><br><span class="line">  <span class="comment">// the above assignments (and after the critical section).</span></span><br><span class="line">  xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  popcli();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> x86.h</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>交換值（x86特殊指令）</td><td>結果</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*addr</code></th><th><code>newval</code></th></tr></thead><tbody><tr><td>欲交換值得目標</td><td>欲填的值</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint</span><br><span class="line">xchg(<span class="keyword">volatile</span> uint *addr, uint newval)</span><br><span class="line">{</span><br><span class="line">  uint result;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// The + in "+m" denotes a read-modify-write operand.</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"+m"</span> (*addr), <span class="string">"=a"</span> (result) :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"1"</span> (newval) :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"cc"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - Traps and Drivers</title>
      <link href="/posts/xv6/trap.html"/>
      <url>/posts/xv6/trap.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>CPU 執行一個 process 時，是不斷的進行：讀取指令、增加程式計數器、執行指令的迴圈；但有時候一個程式需要進入 kernel，而不是執行下一行指令；包括：設備信號的發出、使用者程式做一些非法的事或是呼叫一個 system call。</p></blockquote><ul><li>處理上述情況有三大挑戰：<ol><li>Kernel 需使處理器能夠從 user mode 轉至 kernel mode（再轉回來）。</li><li>Kernel 及設備須協調好他們平行的活動。</li><li>Kernel 需了解設備的介面。</li></ol></li></ul><h2 id="System-call，例外及中斷">System call，例外及中斷<a class="header-anchor" href="#System-call，例外及中斷">#</a></h2><ul><li>有三種情況須從 user 轉至 kernel：<ol><li>system call：使用者程式要求 OS 服務。</li><li>例外 exception：程式執行非法動作（如除零）。</li><li>中斷 interrupt：設備發出一個信號來引起 OS 注意。</li></ol></li><li>所有中斷由 kernel 管理。</li><li>OS 必須在此三種情況保證以下事情：<ol><li>保存暫存器以備將來的狀態回復。</li><li>系統需準備好在 kernel 中執行。</li><li>選擇一個 kernel 開始的位置。</li><li>Kernel 能夠取得此事件的資訊。</li><li>保證安全性（獨立）。</li></ol></li><li>XV6 使用的方法概述：<ol><li>一個中斷停止了處理器的迴圈，並開始執行 interrupt handler。</li><li>在開始執行 interrupt handler 之前，處理器儲存他的暫存器。</li></ol></li><li>Trap：當前 process 引起</li><li>中斷：由設備引起</li></ul><div class="alert alert-warning"><p>XV6 用 trap 來表示中斷，這是因為此術語被 PDP11/40 使用，也是 UNIX 的傳統術語。</p></div><hr><h2 id="X86-的保護機制">X86 的保護機制<a class="header-anchor" href="#X86-的保護機制">#</a></h2><ul><li>x86 有 4 個 protection level，0（最高）至 3（最低）。</li><li>實際上大部分只使用兩個層級：0（kernel mode）及 3（user mode）；當前的層級儲存在 <code>%cs</code> 的 CPL 中。</li><li>Interrupt handler 在 IDT 中被定義。</li><li>IDT interrupt descriptor table：有 256 格，每一格都提供了相對應的 <code>%cs</code> 及 <code>%eip</code>。</li><li>呼叫一個 system call 需要呼叫一個 <code>int n</code> 指令，n 為 IDT 的索引；<code>int n</code> 進行下面步驟：<ol><li>從 IDT 獲得第 n 個描述符</li><li>檢查 <code>%cs</code> 中的 CPL 是否 &lt;= DPL，DPL 為描述符的層級</li><li>如果目標的段選擇器的 PL &lt; CPL，儲存 CPU 內部的 <code>%esp</code> 及 <code>%ss</code></li><li>讀取 task segment descriptor 的 <code>%ss</code> 及 <code>%esp</code></li><li>Push <code>%ss</code>、<code>%esp</code>、<code>%eflags</code>、<code>%cs</code> 及 <code>%eip</code></li><li>清除 <code>%eflags</code> 的 IF bit</li></ol></li></ul><p><div class="img-item" data-src="https://i.imgur.com/Syfs25x.png" data-sub-html=".caption"><img src="https://i.imgur.com/Syfs25x.png" alt="kstack" title="Kernel stack after an int instruction."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">kstack</span></div></div></p><hr><h2 id="Code-第一個-system-call">Code: 第一個 system call<a class="header-anchor" href="#Code-第一個-system-call">#</a></h2><h3 id="File-initcode-S">File: initcode.S<a class="header-anchor" href="#File-initcode-S">#</a></h3><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.globl</span> start</span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">  pushl $argv</span><br><span class="line">  pushl $init</span><br><span class="line">  pushl <span class="number">$0</span>  // where caller pc would be</span><br><span class="line">  movl $SYS_exec, %eax</span><br><span class="line">  <span class="keyword">int</span> $T_SYSCALL</span><br></pre></td></tr></tbody></table></figure><ul><li>Process 將<code>exec</code> 的參數 push 進堆疊，並將 system call number 放進 <code>%eax</code>。</li><li><code>SYS_exec</code> 即為 system call number，對應到 syscalls 的陣列索引（syscall.c 中），一個函數指標陣列。</li></ul><div class="alert alert-success"><p><strong>File:</strong> syscall.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= {</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-Assembly-trap-handler">Code: Assembly trap handler<a class="header-anchor" href="#Code-Assembly-trap-handler">#</a></h2><ul><li>x86 提供 256 種中斷，0-31 為軟體異常。</li><li>XV6 將 32-63 給硬體中斷，64 作為 system call。</li><li>Main 呼叫 <code>tvinit</code>。</li></ul><div class="alert alert-success"><p><strong>File:</strong> trap.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 trap handler</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">tvinit(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Tvinit</code> 設置 <code>idt</code> 表的 256 項。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">  SETGATE(idt[i], <span class="number">0</span>, SEG_KCODE&lt;&lt;<span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著執行 <code>T_SYSCALL</code>，user 會呼叫 <code>trap</code>（將 <code>1</code> 傳入 <code>SETGATE</code> 的第二變數來指定為 trap gate）。</li><li>Trap gate 不會清除 IF bit。</li><li>並將 system call 的權限設為 <code>DPL_USER</code>，允許使用者程式使用 <code>int</code> 指令產生 <code>trap</code>；XV6 不允許 process 用 <code>int</code> 產生其他中斷，如果這麼做會拋出錯誤並產生 13 號中斷。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  SETGATE(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE&lt;&lt;<span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">  </span><br><span class="line">  initlock(&amp;tickslock, <span class="string">"time"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="alert alert-success"><p><strong>File:</strong> mmu.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, d)                \</span></span><br><span class="line">{                                                         \</span><br><span class="line">  (gate).off_15_0 = (uint)(off) &amp; <span class="number">0xffff</span>;                 \</span><br><span class="line">  (gate).cs = (sel);                                      \</span><br><span class="line">  (gate).args = <span class="number">0</span>;                                        \</span><br><span class="line">  (gate).rsv1 = <span class="number">0</span>;                                        \</span><br><span class="line">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \</span><br><span class="line">  (gate).s = <span class="number">0</span>;                                           \</span><br><span class="line">  (gate).dpl = (d);                                       \</span><br><span class="line">  (gate).p = <span class="number">1</span>;                                           \</span><br><span class="line">  (gate).off_31_16 = (uint)(off) &gt;&gt; <span class="number">16</span>;                   \</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STS_IG32    0xE     <span class="comment">// 32-bit Interrupt Gate</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STS_TG32    0xF     <span class="comment">// 32-bit Trap Gate</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="Trap-發生時">Trap 發生時<a class="header-anchor" href="#Trap-發生時">#</a></h3><ul><li>user mode：從 task segment descriptor 讀取 <code>%esp</code>、<code>%ss</code>， 接著 push 舊的 <code>%ss</code>、<code>%esp</code> 進新的堆疊。</li><li>kernel mode：不用上述動作。</li><li>接著 push <code>%eflags</code>、<code>%cs</code>、<code>%eip</code>。</li><li>從對應的 IDT 讀取 <code>%eip</code>、<code>%cs</code>。</li></ul><h4 id="File-vector-pl">File: <a href="http://vector.pl" target="_blank" rel="noopener">vector.pl</a><a class="header-anchor" href="#File-vector-pl">#</a></h4><figure class="highlight pl line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate vectors.S, the trap/interrupt entry points.</span></span><br><span class="line"><span class="comment"># There has to be one entry point per interrupt number</span></span><br><span class="line"><span class="comment"># since otherwise there's no way for trap() to discover</span></span><br><span class="line"><span class="comment"># the interrupt number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"# generated by vectors.pl - do not edit\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"# handlers\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">".globl alltraps\n"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">my</span> $i = <span class="number">0</span>; $i &lt; <span class="number">256</span>; $i++){</span><br><span class="line">    <span class="keyword">print</span> <span class="string">".globl vector$i\n"</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"vector$i:\n"</span>;</span><br><span class="line">    <span class="keyword">if</span>(!($i == <span class="number">8</span> || ($i &gt;= <span class="number">10</span> &amp;&amp; $i &lt;= <span class="number">14</span>) || $i == <span class="number">17</span>)){</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"  pushl \$0\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"  pushl \$$i\n"</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"  jmp alltraps\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n# vector table\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">".data\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">".globl vectors\n"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"vectors:\n"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">my</span> $i = <span class="number">0</span>; $i &lt; <span class="number">256</span>; $i++){</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"  .long vector$i\n"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>XV6 用 Perl 腳本來生成 IDT 的進入點（<code>vector[]</code>）。</li><li>如果處理器沒有 push 錯誤碼，則在其項 push。</li><li>Push 中斷號碼，跳至 <code>alltraps</code>。</li></ul><h4 id="File-trapret-S">File: trapret.S<a class="header-anchor" href="#File-trapret-S">#</a></h4><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"mmu.h"</span></span><br><span class="line"></span><br><span class="line">  # vectors.S sends all traps here.</span><br><span class="line"><span class="meta">.globl</span> alltraps</span><br><span class="line"><span class="symbol">alltraps:</span></span><br><span class="line">  # Build trap frame.</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushl %fs</span><br><span class="line">  pushl %gs</span><br><span class="line">  pushal</span><br></pre></td></tr></tbody></table></figure><ul><li>接著繼續 push <code>%ds</code>、<code>%es</code>、<code>%fs</code>、<code>%gs</code> 及通用暫存器，現在 kernel stack 包含一個 <code>struct trapframe</code>。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Set up data <span class="keyword">and</span> per-cpu segments.</span><br><span class="line">movw $(SEG_KDATA&lt;&lt;<span class="number">3</span>), %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line">movw $(SEG_KCPU&lt;&lt;<span class="number">3</span>), %ax</span><br><span class="line">movw %ax, %fs</span><br><span class="line">movw %ax, %gs</span><br><span class="line"></span><br><span class="line"># Call trap(tf), where tf=%esp</span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br><span class="line">addl $<span class="number">4</span>, %esp</span><br></pre></td></tr></tbody></table></figure><ul><li>push <code>%esp</code>（trap frame），呼叫 <em>trap</em>。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  # Return falls through to trapret...</span><br><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">  popal</span><br><span class="line">  popl %gs</span><br><span class="line">  popl %fs</span><br><span class="line">  popl %es</span><br><span class="line">  popl %ds</span><br><span class="line">  addl $<span class="number">0x8</span>, %esp  <span class="meta"># trapno and errcode</span></span><br><span class="line">  iret</span><br></pre></td></tr></tbody></table></figure><ul><li>trap return 後跳回 user space。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/fKFlWjq.jpg" data-sub-html=".caption"><img src="https://i.imgur.com/fKFlWjq.jpg" alt="trapframe" title="Layout of trapframe"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">trapframe</span></div></div></p><div class="alert alert-success"><p><strong>File:</strong> x86.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> {</span></span><br><span class="line">  <span class="comment">// registers as pushed by pusha</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      <span class="comment">// useless &amp; ignored</span></span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rest of trap frame</span></span><br><span class="line">  ushort gs;</span><br><span class="line">  ushort padding1;</span><br><span class="line">  ushort fs;</span><br><span class="line">  ushort padding2;</span><br><span class="line">  ushort es;</span><br><span class="line">  ushort padding3;</span><br><span class="line">  ushort ds;</span><br><span class="line">  ushort padding4;</span><br><span class="line">  uint trapno;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here defined by x86 hardware</span></span><br><span class="line">  uint err;</span><br><span class="line">  uint eip;</span><br><span class="line">  ushort cs;</span><br><span class="line">  ushort padding5;</span><br><span class="line">  uint eflags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here only when crossing rings, such as from user to kernel</span></span><br><span class="line">  uint esp;</span><br><span class="line">  ushort ss;</span><br><span class="line">  ushort padding6;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-C-trap-handler">Code: C trap handler<a class="header-anchor" href="#Code-C-trap-handler">#</a></h2><h3 id="trap">trap<a class="header-anchor" href="#trap">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*tf</code></th></tr></thead><tbody><tr><td>執行 trap</td><td>void</td><td>trapframe</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap(struct trapframe *tf)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(tf-&gt;trapno == T_SYSCALL){</span><br><span class="line">    <span class="keyword">if</span>(proc-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    proc-&gt;tf = tf;</span><br><span class="line">    syscall();</span><br><span class="line">    <span class="keyword">if</span>(proc-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><ul><li>如果是 <code>TY_SYSCALL</code>，呼叫 syscall()。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(tf-&gt;trapno){</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">  <span class="keyword">if</span>(cpu-&gt;id == <span class="number">0</span>){</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    ticks++;</span><br><span class="line">    wakeup(&amp;ticks);</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">  }</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_IDE:</span><br><span class="line">  ideintr();</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_IDE+<span class="number">1</span>:</span><br><span class="line">  <span class="comment">// Bochs generates spurious IDE1 interrupts.</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_KBD:</span><br><span class="line">  kbdintr();</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_COM1:</span><br><span class="line">  uartintr();</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_SPURIOUS:</span><br><span class="line">  cprintf(<span class="string">"cpu%d: spurious interrupt at %x:%x\n"</span>,</span><br><span class="line">          cpu-&gt;id, tf-&gt;cs, tf-&gt;eip);</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>檢查是否為硬體中斷</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//PAGEBREAK: 13</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(proc == <span class="number">0</span> || (tf-&gt;cs&amp;<span class="number">3</span>) == <span class="number">0</span>){</span><br><span class="line">      <span class="comment">// In kernel, it must be our mistake.</span></span><br><span class="line">      cprintf(<span class="string">"unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n"</span>,</span><br><span class="line">              tf-&gt;trapno, cpu-&gt;id, tf-&gt;eip, rcr2());</span><br><span class="line">      panic(<span class="string">"trap"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// In user space, assume process misbehaved.</span></span><br><span class="line">    cprintf(<span class="string">"pid %d %s: trap %d err %d on cpu %d "</span></span><br><span class="line">            <span class="string">"eip 0x%x addr 0x%x--kill proc\n"</span>,</span><br><span class="line">            proc-&gt;pid, proc-&gt;name, tf-&gt;trapno, tf-&gt;err, cpu-&gt;id, tf-&gt;eip, </span><br><span class="line">            rcr2());</span><br><span class="line">    proc-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Force process exit if it has been killed and is in user space.</span></span><br><span class="line">  <span class="comment">// (If it is still executing in the kernel, let it keep running </span></span><br><span class="line">  <span class="comment">// until it gets to the regular system call return.)</span></span><br><span class="line">  <span class="keyword">if</span>(proc &amp;&amp; proc-&gt;killed &amp;&amp; (tf-&gt;cs&amp;<span class="number">3</span>) == DPL_USER)</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force process to give up CPU on clock tick.</span></span><br><span class="line">  <span class="comment">// If interrupts were on while locks held, would need to check nlock.</span></span><br><span class="line">  <span class="keyword">if</span>(proc &amp;&amp; proc-&gt;state == RUNNING &amp;&amp; tf-&gt;trapno == T_IRQ0+IRQ_TIMER)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the process has been killed since we yielded</span></span><br><span class="line">  <span class="keyword">if</span>(proc &amp;&amp; proc-&gt;killed &amp;&amp; (tf-&gt;cs&amp;<span class="number">3</span>) == DPL_USER)</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果非 system call 或硬體中斷，trap 就認定為一個錯誤：<ul><li>user：cp-&gt;killed (ch5)</li><li>kernel：panic</li></ul></li></ul><hr><h2 id="Code-System-calls（機制）">Code: System calls（機制）<a class="header-anchor" href="#Code-System-calls（機制）">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> syscall.c</p></div><ul><li>從 trap frame 中的 <code>%eax</code> 讀取 system call 號碼，及對應 syscall table 的索引。</li><li>如果 system call 號碼是非法的，<code>return -1</code>。</li></ul><h3 id="syscall">syscall<a class="header-anchor" href="#syscall">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>執行 system call</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">  num = proc-&gt;tf-&gt;eax;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {</span><br><span class="line">    proc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    cprintf(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            proc-&gt;pid, proc-&gt;name, num);</span><br><span class="line">    proc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= {</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="literal">NULL</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-success"><p><strong>File:</strong> syscall.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_close  21</span></span><br></pre></td></tr></tbody></table></figure><ul><li>取得 system call 參數：<ul><li><code>argint</code>：整數</li><li><code>argptr</code>：指標</li><li><code>argstr</code>：字串</li><li><code>argfd</code>：檔案描述符</li></ul></li></ul><hr><h2 id="Code-interrupts">Code: interrupts<a class="header-anchor" href="#Code-interrupts">#</a></h2><h3 id="PIC">PIC<a class="header-anchor" href="#PIC">#</a></h3><ul><li>早期主機板（單核心）上有一塊 PIC，code: picirq.c</li><li>多核心主機板的每顆 CPU 都需要一個 PIC，需要一個方法來分發中斷，操作方式分為兩部份：<ul><li>IO APIC (ioapic.c)：於 I/O 系統上</li><li>Local APIC (lapic.c)：與每個 CPU 有關</li></ul></li><li>IO APIC 包含一張表，處理器可以通過記憶體映射 I/O 來寫其中的一項。</li><li>在初始化時，XV6 將 0 中斷映射到 CR0，以此類推，但將其關閉。</li><li>不同的設備自己開啟自己的中斷，同時指定接收中斷的處理器。</li><li><code>%eflags</code> 的 IF bit 是處理器用來控制是否要接收中斷，<code>cli</code> 清除 IF 來關閉中斷，<code>sti</code> 打開。</li></ul><hr><h2 id="Code-硬碟驅動程式">Code: 硬碟驅動程式<a class="header-anchor" href="#Code-硬碟驅動程式">#</a></h2><ul><li>硬碟驅動程式用 <code>struct buf</code> 來表示一個磁碟區</li></ul><h3 id="File-buf-h">File: buf.h<a class="header-anchor" href="#File-buf-h">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> {</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  uint dev;          <span class="comment">// device number</span></span><br><span class="line">  uint sector;       <span class="comment">// sector number</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span>  <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span> <span class="comment">// disk queue</span></span><br><span class="line">  uchar data[<span class="number">512</span>];   <span class="comment">// copy of the disk sector</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_BUSY  0x1  <span class="comment">// buffer is locked by some process</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_VALID 0x2  <span class="comment">// buffer has been read from disk</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_DIRTY 0x4  <span class="comment">// buffer needs to be written to disk</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>flags</code> 紀錄記憶體與硬碟的關係：<ul><li><code>B_VALID</code> 表示已被讀入</li><li><code>B_DIRTY</code> 表示資料須被寫出</li><li><code>B_BUSY</code> 為一個鎖，代表別的 process 正在使用此 buf</li></ul></li><li>main 呼叫 ideinit 初始化硬碟驅動程式</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> ide.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化 IDE</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ideinit(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;idelock, <span class="string">"ide"</span>);</span><br><span class="line">  picenable(IRQ_IDE);</span><br><span class="line">  ioapicenable(IRQ_IDE, ncpu - <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>呼叫 <code>picenable</code> 打開單處理器的中斷</li><li>呼叫 <code>ioapicenable</code> 打開多處理器的中斷（只打開最後一個 CPU）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">idewait(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li><code>idewait</code> 等待硬碟接受命令，直到 busy 位（<code>IDE_BUSY</code>）被清除，ready 位（<code>IDE_DRDY</code>）被設置。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Check if disk 1 is present</span></span><br><span class="line">  outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++){</span><br><span class="line">    <span class="keyword">if</span>(inb(<span class="number">0x1f7</span>) != <span class="number">0</span>){</span><br><span class="line">      havedisk1 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Switch back to disk 0.</span></span><br><span class="line">  outb(<span class="number">0x1f6</span>, <span class="number">0xe0</span> | (<span class="number">0</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>設置完成後，只能通過 buffer cache 調用 <code>iderw</code>，<code>iderw</code> 根據 <code>flags</code> 值更新一個鎖著的 buf:<ul><li>B_DIRTY：將 buf 寫回硬碟</li><li>若 B_VALID 未設置：從硬碟讀資料進 buf</li></ul></li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>checkerr</code></th></tr></thead><tbody><tr><td>等待 IDE</td><td>void</td><td>錯誤碼</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for IDE disk to become ready.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">idewait(<span class="keyword">int</span> checkerr)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(((r = inb(<span class="number">0x1f7</span>)) &amp; (IDE_BSY|IDE_DRDY)) != IDE_DRDY) </span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span>(checkerr &amp;&amp; (r &amp; (IDE_DF|IDE_ERR)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*b</code></th></tr></thead><tbody><tr><td>讀寫 IDE</td><td>void</td><td>欲寫入或讀取的 buffer</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">iderw(struct buf *b)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!(b-&gt;flags &amp; B_BUSY))</span><br><span class="line">    panic(<span class="string">"iderw: buf not busy"</span>);</span><br><span class="line">  <span class="keyword">if</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) == B_VALID)</span><br><span class="line">    panic(<span class="string">"iderw: nothing to do"</span>);</span><br><span class="line">  <span class="keyword">if</span>(b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1)</span><br><span class="line">    panic(<span class="string">"iderw: ide disk 1 not present"</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;idelock);  <span class="comment">//DOC:acquire-lock</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append b to idequeue.</span></span><br><span class="line">  b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(pp=&amp;idequeue; *pp; pp=&amp;(*pp)-&gt;qnext)  <span class="comment">//DOC:insert-queue</span></span><br><span class="line">    ;</span><br><span class="line">  *pp = b;</span><br></pre></td></tr></tbody></table></figure><ul><li>把 buf b 放置隊伍的末端</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start disk if necessary.</span></span><br><span class="line"><span class="keyword">if</span>(idequeue == b)</span><br><span class="line">  idestart(b);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果此 buf 在隊首，呼叫 <code>idestart</code> 將其送到硬碟。</li><li>其他情況需等上一個處理完畢時才處理。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Wait for request to finish.</span></span><br><span class="line">  <span class="keyword">while</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID){</span><br><span class="line">    sleep(b, &amp;idelock);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  release(&amp;idelock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>iderw</code> 將請求加入的隊伍裡，並睡眠，等待 interrupt handler 處理完後更新其 flags。</li><li>最後，硬碟完成其工作並觸發一個中斷，trap 呼叫 <code>ideintr</code> 來處理。</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>IDE trap</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ideintr(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// First queued buffer is the active request.</span></span><br><span class="line">  acquire(&amp;idelock);</span><br><span class="line">  <span class="keyword">if</span>((b = idequeue) == <span class="number">0</span>){</span><br><span class="line">    release(&amp;idelock);</span><br><span class="line">    <span class="comment">// cprintf("spurious IDE interrupt\n");</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  idequeue = b-&gt;qnext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read data if needed.</span></span><br><span class="line">  <span class="keyword">if</span>(!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; idewait(<span class="number">1</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    insl(<span class="number">0x1f0</span>, b-&gt;data, <span class="number">512</span>/<span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>查詢隊首的 buf，如果正在被寫入，且 IDE 有資料在等待，呼叫 <code>insl</code> 將資料寫入。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake process waiting for this buf.</span></span><br><span class="line">b-&gt;flags |= B_VALID;</span><br><span class="line">b-&gt;flags &amp;= ~B_DIRTY;</span><br><span class="line">wakeup(b);</span><br></pre></td></tr></tbody></table></figure><ul><li>設置 <code>B_VALID</code>，清除 <code>B_DIRTY</code>。</li><li>喚醒 <code>b</code></li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Start disk on next buf in queue.</span></span><br><span class="line">  <span class="keyword">if</span>(idequeue != <span class="number">0</span>)</span><br><span class="line">    idestart(idequeue);</span><br><span class="line"></span><br><span class="line">  release(&amp;idelock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後將下一個 buf 傳給硬碟。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interrupt </tag>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
            <tag> trap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - Page Tables</title>
      <link href="/posts/xv6/mem.html"/>
      <url>/posts/xv6/mem.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="alert alert-success"><p><strong>File:</strong> vm.c</p></div><h2 id="分頁硬體">分頁硬體<a class="header-anchor" href="#分頁硬體">#</a></h2><ul><li>PTE：Page table entry，包含 20-bit PPN 及 flags</li><li>PPN：Physical Page number</li><li>x86的頁表：$2^{20}$ 條 PTE。</li></ul><h3 id="目標">目標<a class="header-anchor" href="#目標">#</a></h3><blockquote><p>分頁硬體使用虛擬位址找到對應的 PTE，接著把高 20-bit 替換為 PTE 的 PPN，低 12-bit 直接沿用，即完成轉譯的動作。</p></blockquote><h3 id="XV6-頁表">XV6 頁表<a class="header-anchor" href="#XV6-頁表">#</a></h3><p><div class="img-item" data-src="https://i.imgur.com/Jj4vbJt.png" data-sub-html=".caption"><img src="https://i.imgur.com/Jj4vbJt.png" alt="" title="x86 page table hardware."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><ul><li>一個頁表在物理記憶體中為一顆兩層的樹<ul><li>樹根為一個 4096 字節的目錄（page dir），包含 1024 個類 PTE，分別指向不同的頁表頁（page table page）。</li><li>每頁包含 1024 個 32-bit PTE。</li></ul></li><li>轉譯過程<ol><li>分頁硬體用虛擬地址的高 10-bit 找到指定的頁。</li><li>如果指向的頁存在的話，繼續使用接著的 10-bit 來找到指定的 PTE。</li><li>不存在的話，拋出錯誤。</li></ol></li></ul><h3 id="flags">flags<a class="header-anchor" href="#flags">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">flags</th><th>name</th><th>為 1 時</th><th>為 0 時</th></tr></thead><tbody><tr><td style="text-align:center">P</td><td>Present</td><td>表示頁存在</td><td>不存在</td></tr><tr><td style="text-align:center">W</td><td>Writable</td><td>可以寫入</td><td>只能讀/取</td></tr><tr><td style="text-align:center">U</td><td>User</td><td>user 能使用此頁</td><td>只有 kernel 能使用</td></tr><tr><td style="text-align:center">WT</td><td>-</td><td>Write-through</td><td>Write-back</td></tr><tr><td style="text-align:center">CD</td><td>Cache Disable</td><td>不會對此頁進行 cache</td><td>進行 cache</td></tr><tr><td style="text-align:center">A</td><td>Accessed</td><td>為 0 時被存取， 處理器會將此位設為 1</td><td>-</td></tr><tr><td style="text-align:center">D</td><td>Dirty</td><td>為 0 時寫入此頁， 處理器會將此位設為 1</td><td>-</td></tr><tr><td style="text-align:center">AVL</td><td>Available for system use</td><td>-</td><td>-</td></tr></tbody></table></div><div class="alert alert-warning"><p>只有軟體可以將 A、D 清 0。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[記憶體管理／分頁架構](https://www.csie.ntu.edu.tw/~wcchen/asm98/asm/proj/b85506061/chap2/paging.html)">[1]</span></a></sup></p></div><h3 id="名詞解釋">名詞解釋<a class="header-anchor" href="#名詞解釋">#</a></h3><ul><li>物理記憶體：DRAM</li><li>物理地址：DRAM 的位址</li></ul><hr><h2 id="Process-address-space">Process address space<a class="header-anchor" href="#Process-address-space">#</a></h2><ul><li><code>main</code> 呼叫 <code>kvmalloc</code> 跳到新的頁表，重新映射至記憶體。<br><div class="img-item" data-src="https://i.imgur.com/xq8Po1n.png" data-sub-html=".caption"><img src="https://i.imgur.com/xq8Po1n.png" alt="" title="Layout of the virtual address space of a process and physical address space."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></li><li>每個 process 都有自己的頁表，在切換 process 時也會切換頁表。</li><li>process 的頁表從 0 開始，最多至 <code>KERNBASE</code>，限制 process 最多使用 2GB。</li><li>如果需要更多記憶體時：<ol><li>XV6 先找到一個空的頁</li><li>將對應的 PTE 加入 process 的頁表裡</li></ol></li><li>每個 process 的頁表都有包含對應的 kernel 映射（ <code>KERNBASE</code> 之上），這樣當發生中斷時就不需要切換頁表。</li><li><code>KERNBASE</code> 之上的頁對應的 PTE，PTE_U 均設為 0。</li></ul><hr><h2 id="Code-建立-address-space">Code: 建立 address space<a class="header-anchor" href="#Code-建立-address-space">#</a></h2><ul><li><code>main</code> 呼叫 <code>kvmalloc</code> 來建立 <code>KERNBASE</code> 之上的頁表</li></ul><h3 id="kvmalloc">kvmalloc<a class="header-anchor" href="#kvmalloc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立 kernel page</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one page table for the machine for the kernel address</span></span><br><span class="line"><span class="comment">// space for scheduler processes.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kvmalloc(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  kpgdir = setupkvm();</span><br><span class="line">  switchkvm();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>建立頁表的工作由 <code>setupkvm</code> 完成</li></ul><h3 id="setupkvm">setupkvm<a class="header-anchor" href="#setupkvm">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 kernel page</td><td>PDE</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up kernel part of a page table.</span></span><br><span class="line"><span class="keyword">pde_t</span>*</span><br><span class="line">setupkvm(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">pde_t</span> *pgdir;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> *<span class="title">k</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pgdir = (<span class="keyword">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先分配一頁來存放目錄</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">memset</span>(pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">if</span> (p2v(PHYSTOP) &gt; (<span class="keyword">void</span>*)DEVSPACE)</span><br><span class="line">    panic(<span class="string">"PHYSTOP too high"</span>);</span><br><span class="line">  <span class="keyword">for</span>(k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++)</span><br><span class="line">    <span class="keyword">if</span>(mappages(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start, </span><br><span class="line">                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> pgdir;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著呼叫 <code>mappages</code> 來建立 kernel 所需的映射。</li><li>映射存放在 kmap 裡</li></ul><hr><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This table defines the kernel's mappings, which are present in</span></span><br><span class="line"><span class="comment">// every process's page table.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmap</span> {</span></span><br><span class="line">  <span class="keyword">void</span> *virt;</span><br><span class="line">  uint phys_start;</span><br><span class="line">  uint phys_end;</span><br><span class="line">  <span class="keyword">int</span> perm;</span><br><span class="line">} kmap[] = {</span><br><span class="line"> { (<span class="keyword">void</span>*)KERNBASE, <span class="number">0</span>,             EXTMEM,    PTE_W}, <span class="comment">// I/O space</span></span><br><span class="line"> { (<span class="keyword">void</span>*)KERNLINK, V2P(KERNLINK), V2P(data), <span class="number">0</span>},     <span class="comment">// kern text+rodata</span></span><br><span class="line"> { (<span class="keyword">void</span>*)data,     V2P(data),     PHYSTOP,   PTE_W}, <span class="comment">// kern data+memory</span></span><br><span class="line"> { (<span class="keyword">void</span>*)DEVSPACE, DEVSPACE,      <span class="number">0</span>,         PTE_W}, <span class="comment">// more devices</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>kmap 包含 kernel 的資料及指令、<code>PHYTOP</code>以下的物理記憶體、及 I/O 設備的記憶體。</li><li>這裡不會建立有關 user 的映射</li></ul><h3 id="mappages">mappages<a class="header-anchor" href="#mappages">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>設定 PTE</td><td>0 (ok) / -1 (err)</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">mappages(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, uint size, uint pa, <span class="keyword">int</span> perm)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">char</span> *a, *last;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  </span><br><span class="line">  a = (<span class="keyword">char</span>*)PGROUNDDOWN((uint)va);</span><br><span class="line">  last = (<span class="keyword">char</span>*)PGROUNDDOWN(((uint)va) + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;){</span><br><span class="line">    <span class="keyword">if</span>((pte = walkpgdir(pgdir, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先呼叫 <code>walkpgdir</code> 來找到對應的 PTE</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_P)</span><br><span class="line">  panic(<span class="string">"remap"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著確認 PTE_P flags</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">    *pte = pa | perm | PTE_P;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最後初始化 PTE。</li><li>問題：如何初始化</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>從目錄尋找對應的 PTE</td><td>PTE</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*pgdir</code></th><th><code>*va</code></th><th><code>alloc</code></th></tr></thead><tbody><tr><td>目標目錄</td><td>目標虛擬地址</td><td>是否有 alloc</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pgdir</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page table pages.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pte_t</span> *</span><br><span class="line">walkpgdir(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> alloc)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">pde_t</span> *pde;</span><br><span class="line">  <span class="keyword">pte_t</span> *pgtab;</span><br><span class="line"></span><br><span class="line">  pde = &amp;pgdir[PDX(va)];</span><br><span class="line">  <span class="keyword">if</span>(*pde &amp; PTE_P){</span><br><span class="line">    pgtab = (<span class="keyword">pte_t</span>*)p2v(PTE_ADDR(*pde));</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span>(!alloc || (pgtab = (<span class="keyword">pte_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Make sure all those PTE_P bits are zero.</span></span><br><span class="line">    <span class="built_in">memset</span>(pgtab, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// The permissions here are overly generous, but they can</span></span><br><span class="line">    <span class="comment">// be further restricted by the permissions in the page table </span></span><br><span class="line">    <span class="comment">// entries, if necessary.</span></span><br><span class="line">    *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> &amp;pgtab[PTX(va)];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>切換至 kernel 頁</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">switchkvm(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  lcr3(v2p(kpgdir));   <span class="comment">// switch to the kernel page table</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="分配物理記憶體">分配物理記憶體<a class="header-anchor" href="#分配物理記憶體">#</a></h2><p>kernel 在運行時須為以下物件分配物理記憶體：</p><ul><li>Page table</li><li>Process 的 user 記憶體</li><li>kernel stack</li><li>Pipe buffers</li></ul><h2 id="Code-物理記憶體分配器">Code: 物理記憶體分配器<a class="header-anchor" href="#Code-物理記憶體分配器">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> kalloc.c</p></div><ul><li>分配器為一個可分配的記憶體頁所構成的 <strong>free list</strong></li><li><code>main</code> 呼叫 <code>kinit1(end, P2V(4*1024*1024))</code> 及 <code>kinit2(P2V(4*1024*1024), P2V(PHYSTOP))</code> 初始化分配器</li></ul><h3 id="kinit1-2">kinit1 / 2<a class="header-anchor" href="#kinit1-2">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化物理記憶體分配器</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*vstart</code></th><th><code>*vend</code></th></tr></thead><tbody><tr><td>起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">kinit1(<span class="keyword">void</span> *vstart, <span class="keyword">void</span> *vend)</span><br><span class="line">{</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">"kmem"</span>);</span><br><span class="line">  kmem.use_lock = <span class="number">0</span>;</span><br><span class="line">  freerange(vstart, vend);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>初始化物理記憶體分配器</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*vstart</code></th><th><code>*vend</code></th></tr></thead><tbody><tr><td>起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">kinit2(<span class="keyword">void</span> *vstart, <span class="keyword">void</span> *vend)</span><br><span class="line">{</span><br><span class="line">  freerange(vstart, vend);</span><br><span class="line">  kmem.use_lock = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>kinit1 / 2</code> 呼叫 <code>freerange</code> 將記憶體加入 free list</li></ul><h3 id="freerange">freerange<a class="header-anchor" href="#freerange">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>釋放一段記憶體</td><td>void</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*vstart</code></th><th><code>*vend</code></th></tr></thead><tbody><tr><td>起始位址</td><td>結束位址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">freerange(<span class="keyword">void</span> *vstart, <span class="keyword">void</span> *vend)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint)vstart);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)vend; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>freerange</code> 呼叫 <code>kfree</code> 來完成工作</li></ul><h3 id="kfree">kfree<a class="header-anchor" href="#kfree">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>*v</code></th></tr></thead><tbody><tr><td>釋放記憶體</td><td>void</td><td>欲 free 的虛擬地址</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 21</span></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">char</span> *v)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((uint)v % PGSIZE || v &lt; end || v2p(v) &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">"kfree"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">1</span>, PGSIZE);</span><br></pre></td></tr></tbody></table></figure><ul><li>首先將每個字節設為 1</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(kmem.use_lock)</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">  r = (struct run*)v;</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="keyword">if</span>(kmem.use_lock)</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把 v 轉為 <code>struct run</code> 的指標，插在 free list 的第一顆。</li></ul><hr><h2 id="User-part-of-an-address-space">User part of an address space<a class="header-anchor" href="#User-part-of-an-address-space">#</a></h2><p><div class="img-item" data-src="https://i.imgur.com/sZaPwda.png" data-sub-html=".caption"><img src="https://i.imgur.com/sZaPwda.png" alt="" title="Memory layout of a user process with its initial stack"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom"></span></div></div></p><h2 id="Code-sbrk">Code: sbrk<a class="header-anchor" href="#Code-sbrk">#</a></h2><div class="alert alert-success"><p><strong>File:</strong> sysproc.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長/收縮 process 的記憶體</td><td>記憶體大小（結果）</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = proc-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sbrk</code> 透過呼叫 <code>growproc</code> 來完成工作。</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> proc.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th><th><code>n</code></th></tr></thead><tbody><tr><td>增長/收縮 process 的記憶體</td><td>0 (ok) / -1 (err)</td><td>增長/收縮大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow current process's memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">growproc(<span class="keyword">int</span> n)</span><br><span class="line">{</span><br><span class="line">  uint sz;</span><br><span class="line">  </span><br><span class="line">  sz = proc-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">if</span>((sz = allocuvm(proc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">if</span>((sz = deallocuvm(proc-&gt;pgdir, sz, sz + n)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  proc-&gt;sz = sz;</span><br><span class="line">  switchuvm(proc);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 n&gt;0：<code>allocuvm</code></li><li>如果 n&lt;0：<code>deallocuvm</code></li></ul><hr><h3 id="allocuvm、deallocuvm">allocuvm、deallocuvm<a class="header-anchor" href="#allocuvm、deallocuvm">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> vm.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>增長記憶體</td><td>記憶體大小（結果）</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*pgdir</code></th><th><code>oldsz</code></th><th><code>newsz</code></th></tr></thead><tbody><tr><td>從該目錄尋找可用記憶體</td><td>舊的大小</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate page tables and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">allocuvm(<span class="keyword">pde_t</span> *pgdir, uint oldsz, uint newsz)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  uint a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= KERNBASE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br></pre></td></tr></tbody></table></figure><ul><li>首先檢查是否有要超過大小，及動作是否合法。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line">  a = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(; a &lt; newsz; a += PGSIZE){</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>){</span><br><span class="line">      cprintf(<span class="string">"allocuvm out of memory\n"</span>);</span><br><span class="line">      deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    mappages(pgdir, (<span class="keyword">char</span>*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著透過 <code>kalloc()</code> 來要記憶體，並將要到的記憶體清空</li><li>最後回傳 process 目前總共的大小</li></ul><hr><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>縮減記憶體</td><td>記憶體大小（結果）</td></tr></tbody></table></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th><code>*pgdir</code></th><th><code>oldsz</code></th><th><code>newsz</code></th></tr></thead><tbody><tr><td>從該目錄釋放記憶體</td><td>舊的大小</td><td>新的大小</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deallocate user pages to bring the process size from oldsz to</span></span><br><span class="line"><span class="comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">deallocuvm(<span class="keyword">pde_t</span> *pgdir, uint oldsz, uint newsz)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint a, pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br></pre></td></tr></tbody></table></figure><ul><li>一樣先檢查動作是否合法</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">  a = PGROUNDUP(newsz);</span><br><span class="line">  <span class="keyword">for</span>(; a  &lt; oldsz; a += PGSIZE){</span><br><span class="line">    pte = walkpgdir(pgdir, (<span class="keyword">char</span>*)a, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pte)</span><br><span class="line">      a += (NPTENTRIES - <span class="number">1</span>) * PGSIZE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_P) != <span class="number">0</span>){</span><br><span class="line">      pa = PTE_ADDR(*pte);</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"kfree"</span>);</span><br><span class="line">      <span class="keyword">char</span> *v = p2v(pa);</span><br><span class="line">      kfree(v);</span><br><span class="line">      *pte = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著一個一個 pte free，先將 flags 歸0，再透過 <code>kfree</code> 完成工作。</li></ul><hr><h2 id="Code-exec">Code: exec<a class="header-anchor" href="#Code-exec">#</a></h2><ul><li>功用：創建 user part address space</li><li>概觀：打開及讀取 ELF 文件來初始化 user part</li></ul><h3 id="struct-elfhdr">struct elfhdr<a class="header-anchor" href="#struct-elfhdr">#</a></h3><div class="alert alert-success"><p><strong>File:</strong> elf.h</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File header</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> {</span></span><br><span class="line">  uint magic;  <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];</span><br><span class="line">  ushort type;</span><br><span class="line">  ushort machine;</span><br><span class="line">  uint version;</span><br><span class="line">  uint entry;</span><br><span class="line">  uint phoff;</span><br><span class="line">  uint shoff;</span><br><span class="line">  uint flags;</span><br><span class="line">  ushort ehsize;</span><br><span class="line">  ushort phentsize;</span><br><span class="line">  ushort phnum;</span><br><span class="line">  ushort shentsize;</span><br><span class="line">  ushort shnum;</span><br><span class="line">  ushort shstrndx;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>一個 ELF 文件包含一個 elfhdr、program setion hdr(struct proghdr)</li></ul><h3 id="struct-proghdr">struct proghdr<a class="header-anchor" href="#struct-proghdr">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program section header</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> {</span></span><br><span class="line">  uint type;</span><br><span class="line">  uint off;</span><br><span class="line">  uint vaddr;</span><br><span class="line">  uint paddr;</span><br><span class="line">  uint filesz;</span><br><span class="line">  uint memsz;</span><br><span class="line">  uint flags;</span><br><span class="line">  uint align;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>一個 proghdr 描述了須載入至記憶體的 program section</li></ul><div class="alert alert-info"><p>XV6 的 program 只有一個 section，其他 OS 可能會有多個。</p></div><h3 id="File-exec-c">File: exec.c<a class="header-anchor" href="#File-exec-c">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"param.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memlayout.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mmu.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"x86.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"elf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">exec(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">char</span> *s, *last;</span><br><span class="line">  <span class="keyword">int</span> i, off;</span><br><span class="line">  uint argc, sz, sp, ustack[<span class="number">3</span>+MAXARG+<span class="number">1</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="keyword">pde_t</span> *pgdir, *oldpgdir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>用 <code>namei</code> 打開二進制文件（ch6 會說明）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ilock(ip);</span><br><span class="line">pgdir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check ELF header</span></span><br><span class="line"><span class="keyword">if</span>(readi(ip, (<span class="keyword">char</span>*)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) &lt; <span class="keyword">sizeof</span>(elf))</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著確認 ELF 是否正確（藉由 ELF_magic）</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((pgdir = setupkvm()) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load program into memory.</span></span><br><span class="line">sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph)){</span><br><span class="line">  <span class="keyword">if</span>(readi(ip, (<span class="keyword">char</span>*)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(loaduvm(pgdir, (<span class="keyword">char</span>*)ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line">iunlockput(ip);</span><br><span class="line">ip = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><ol><li><code>setupkvm</code> 分配一個沒有 user part 的頁</li><li><code>allocuvm</code> 分配給每個 ELF 的 program section 記憶體。</li><li><code>loaduvm</code> 將 section 載入至記憶體</li></ol><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Make the first inaccessible.  Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  <span class="keyword">if</span>((sz = allocuvm(pgdir, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  clearpteu(pgdir, (<span class="keyword">char</span>*)(sz - <span class="number">2</span>*PGSIZE));</span><br><span class="line">  sp = sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) {</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp = (sp - (<span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>)) &amp; ~<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pgdir, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[<span class="number">3</span>+argc] = sp;</span><br><span class="line">  }</span><br><span class="line">  ustack[<span class="number">3</span>+argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ustack[<span class="number">0</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// fake return PC</span></span><br><span class="line">  ustack[<span class="number">1</span>] = argc;</span><br><span class="line">  ustack[<span class="number">2</span>] = sp - (argc+<span class="number">1</span>)*<span class="number">4</span>;  <span class="comment">// argv pointer</span></span><br><span class="line"></span><br><span class="line">  sp -= (<span class="number">3</span>+argc+<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pgdir, sp, ustack, (<span class="number">3</span>+argc+<span class="number">1</span>)*<span class="number">4</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">'/'</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(proc-&gt;name, last, <span class="keyword">sizeof</span>(proc-&gt;name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpgdir = proc-&gt;pgdir;</span><br><span class="line">  proc-&gt;pgdir = pgdir;</span><br><span class="line">  proc-&gt;sz = sz;</span><br><span class="line">  proc-&gt;tf-&gt;eip = elf.entry;  <span class="comment">// main</span></span><br><span class="line">  proc-&gt;tf-&gt;esp = sp;</span><br><span class="line">  switchuvm(proc);</span><br><span class="line">  freevm(oldpgdir);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pgdir)</span><br><span class="line">    freevm(pgdir);</span><br><span class="line">  <span class="keyword">if</span>(ip)</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.csie.ntu.edu.tw/~wcchen/asm98/asm/proj/b85506061/chap2/paging.html" target="_blank" rel="noopener">記憶體管理／分頁架構</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> 記憶體管理 </tag>
            
            <tag> XV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - OS Organization</title>
      <link href="/posts/xv6/process.html"/>
      <url>/posts/xv6/process.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>OS 必須具備三項技能：多工、獨立及交流。</p></blockquote><h2 id="kernel-組織">kernel 組織<a class="header-anchor" href="#kernel-組織">#</a></h2><ul><li><strong>Monolithic kernel</strong>：整個 OS 都位於 kernel 中，如此一來所有 system calls 都會在 kernel 中執行（XV6）。<ul><li>好處<ol><li>設計者不須決定 OS 的哪些部份不需要完整的硬體特權。</li><li>更方便的讓不同部份的 OS 去合作。</li></ol></li><li>壞處<ol><li>通常在不同部份的 OS 中的介面是複雜的。</li><li>這會容易讓開發者出錯。</li></ol></li></ul></li><li><strong>Microkernel</strong>：為了減少 kernel 出錯的風險，設計者可以將 kernel mode 上執行的 OS 程式碼最小化，並大讓OS 在 user mode 中執行。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/lCf7yfw.png" data-sub-html=".caption"><img src="https://i.imgur.com/lCf7yfw.png" alt="microkernel" title="A mkernel with a file system server"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">microkernel</span></div></div></p><hr><h2 id="Process-概觀">Process 概觀<a class="header-anchor" href="#Process-概觀">#</a></h2><ul><li>為 UNIX（XV6） 中的一個獨立單元。</li><li>確保一個 process 不會破壞或是竊取另一程序的記憶體、CPU、檔案描述符等等。</li><li>亦確保 kernel 不會被破壞。</li><li>Process 為抽象的，這讓一個程式可以假設它佔有一台虛擬機器，即一個接近私有的記憶體或是 address space，其他的 process 不可以 r/w。</li><li>私有的 adderss space 由不同的 page table 實做，即一個 process 有一個 page table</li><li>每個 process 的 page 都分為 kernel 及 user（如上圖），因此當 process 呼叫一個 system call 時，會直接在自己的 kernel 映射（mapping）中執行。</li><li>Thread：用來執行指令，可以被暫緩，稍後再恢復運作。</li><li>大部分 thread 的狀態（區域變數等）被保存在 thread 的堆疊上，每個 process 有兩個堆疊：user/kernel 堆疊。<ul><li>user 指令執行時，只會用到 user 堆疊，此時 kernel 堆疊為空。</li><li>kernel 指令執行時，user 堆疊的資料不會清空，也不會使用到。</li></ul></li><li><code>p-&gt;state</code> 指 process 的狀態：新建、準備執行、執行中、等待I/O及退出。</li><li><code>p-&gt;pgdir</code>：保存 process 的 page table。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/AQ9pMhW.png" data-sub-html=".caption"><img src="https://i.imgur.com/AQ9pMhW.png" alt="address space" title="Layout of a virtual address space"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">address space</span></div></div></p><hr><h2 id="Code-第一個-address-space">Code: 第一個 address space<a class="header-anchor" href="#Code-第一個-address-space">#</a></h2><ul><li>XV6 為 kernel 建立第一個 address space 的流程：<ol><li>開機</li><li>初始化自己</li><li>從硬碟中讀取 boot loader 至記憶體中執行。</li><li>Boot loader 從硬碟讀取 kernel 並從 <em>entry.s</em> 開始執行。</li><li>Boot loader 會把 XV6 的 kernel 載入實體位址 0x100000。</li><li>為了讓剩下的 kernel 能夠執行，設置一個 page table，將虛擬位址 0x80000000（KERNBASE）映射到實體位址 0x0。將兩個虛擬位址映 到同一個實體位址是 page 的常見手法。</li><li>跳到 kernel 的 c code，並在高位址上執行：<ul><li><code>%esp</code> 指向高位址的 stack 記憶體。</li><li>跳到高位址的 <em>main</em>。</li></ul></li></ol></li></ul><p><div class="img-item" data-src="https://i.imgur.com/aks2sld.png" data-sub-html=".caption"><img src="https://i.imgur.com/aks2sld.png" alt="address space" title="Layout of a virtual address space"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">address space</span></div></div></p><div class="alert alert-success"><p><strong><strong>File:</strong></strong> entry.s</p></div><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_start = V2P_WO(entry)</span><br><span class="line"></span><br><span class="line"># Entering XV6 on boot processor, with paging off.</span><br><span class="line"><span class="meta">.globl</span> entry</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">    # Turn on page size extension for 4Mbyte pages</span><br><span class="line">    movl    %cr4, %eax</span><br><span class="line">    orl     $(CR4_PSE), %eax</span><br><span class="line">    movl    %eax, %cr4</span><br><span class="line">    # Set page directory</span><br><span class="line">    movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="line">    movl    %eax, %cr3</span><br><span class="line">    # Turn on paging.</span><br><span class="line">    movl    %cr0, %eax</span><br><span class="line">    orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="line">    movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Set <span class="meta">up</span> the stack pointer.</span><br><span class="line">    movl $(stack + KSTACKSIZE), %esp</span><br><span class="line"></span><br><span class="line">    # Jump to main(), <span class="keyword">and</span> switch to executing <span class="meta">at</span></span><br><span class="line">    # high addresses. The indirect <span class="keyword">call</span> is needed because</span><br><span class="line">    # the assembler produces a PC-relative instruction</span><br><span class="line">    # for a direct jump.</span><br><span class="line">    <span class="keyword">mov</span> $main, %eax</span><br><span class="line">    <span class="keyword">jmp</span> *%eax</span><br><span class="line"></span><br><span class="line"><span class="meta">.comm</span> stack, KSTACKSIZE</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-建立第一個-process">Code: 建立第一個 process<a class="header-anchor" href="#Code-建立第一個-process">#</a></h2><div class="alert alert-success"><p><strong><strong>File:</strong></strong> proc.c</p></div><ul><li>呼叫 <code>userinit()</code> 來建立第一個 process（只有在第一個process時會呼叫）。</li><li>呼叫 <code>allocproc()</code>（每個 process 都會呼叫）。</li><li><code>Allocproc</code> 在 process table 中分配一個 slot（<code>struct proc</code>），並初始化有關 kernel thread 的 process 片段。</li><li><code>Allocproc</code> 掃描 proc tabel，找到 <code>p-&gt;state</code> 是 <code>UNUSED</code>，接著設定為 <code>EMBRYO</code> 來標示被使用，並給予一組唯一的 pid。</li></ul><h3 id="allocproc">allocproc<a class="header-anchor" href="#allocproc">#</a></h3><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立一個 process</td><td>process 結構</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, change state to EMBRYO and initialize</span></span><br><span class="line"><span class="comment">// state required to run in the kernel.</span></span><br><span class="line"><span class="comment">// Otherwise return 0.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">char</span> *sp;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED)</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;state = EMBRYO;</span><br><span class="line">  p-&gt;pid = nextpid++;</span><br><span class="line">  release(&amp;ptable.lock);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著嘗試請求分配一個 kernel stack，如果失敗，把 <code>p-&gt;state</code> 改回 <code>UNUSED</code>。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate kernel stack.</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;kstack = kalloc()) == <span class="number">0</span>){</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">sp = p-&gt;kstack + KSTACKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leave room for trap frame.</span></span><br><span class="line">sp -= <span class="keyword">sizeof</span> *p-&gt;tf;</span><br><span class="line">p-&gt;tf = (struct trapframe*)sp;</span><br></pre></td></tr></tbody></table></figure><p><div class="img-item" data-src="https://i.imgur.com/Q2wSVQX.png" data-sub-html=".caption"><img src="https://i.imgur.com/Q2wSVQX.png" alt="kstack" title="A new kernel stack."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">kstack</span></div></div></p><ul><li>Allocproc 通過設定返回程式計數器的值來導致新 process 的 kernel thread 會先在 forkret 中執行，再回到 trapret。</li><li>Kernel thread 從 p-&gt;context 的拷貝開始執行，因此設定 p-&gt;context-&gt;eip 指向 forkret 會導致 kernel thread 從 forkret 的開頭開始執行。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to trapret.</span></span><br><span class="line">  sp -= <span class="number">4</span>;</span><br><span class="line">  *(uint*)sp = (uint)trapret;</span><br><span class="line">  </span><br><span class="line">  sp -= <span class="keyword">sizeof</span> *p-&gt;context;</span><br><span class="line">  p-&gt;context = (struct context*)sp;</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span> *p-&gt;context);</span><br><span class="line">  p-&gt;context-&gt;eip = (uint)forkret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Forkret</code> return 堆疊（<code>p-&gt;context-&gt;eip</code>）底。</li><li><code>Allocate</code> 將 <code>trapret</code> 放在 <code>eip</code> 的上方，即 <code>forkret</code> return 的位置。</li><li><code>Trapret</code> 從 kernel 堆疊頂恢復 user 的暫存器並跳至程序。</li></ul><hr><ul><li>第一個 process 會運行一個小程式 <em>initcode.s</em>。</li><li>Process 需要實體記憶體來保存此程式。</li><li>Process 需要被拷貝到記憶體中，也需要 page table 來指向此位址。</li><li><code>Userinit</code> 呼叫 <code>setupkvm</code> 來建立 page table 只映射到 kernel 會用到的記憶體。</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>建立系統的初始 process</td><td>void</td></tr></tbody></table></div><h3 id="userinit">userinit<a class="header-anchor" href="#userinit">#</a></h3><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">userinit(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">char</span> _binary_initcode_start[], _binary_initcode_size[];</span><br><span class="line">  </span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  <span class="keyword">if</span>((p-&gt;pgdir = setupkvm()) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"userinit: out of memory?"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li><code>inituvm</code> 請求一個 page 大小的實體記憶體，將虛擬記憶體 0 映射到此記憶體，並將 <code>_binary_initcode_start_</code> 及 <code>_binary_initcode_size_</code> 拷貝到 page。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">inituvm(p-&gt;pgdir, _binary_initcode_start, (<span class="keyword">int</span>)_binary_initcode_size);</span><br></pre></td></tr></tbody></table></figure><ul><li>把 trap frame 設定為初始使用者模式。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;sz = PGSIZE;</span><br><span class="line"><span class="built_in">memset</span>(p-&gt;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(*p-&gt;tf));</span><br><span class="line">p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; <span class="number">3</span>) | DPL_USER;</span><br><span class="line">p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; <span class="number">3</span>) | DPL_USER;</span><br><span class="line">p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;</span><br><span class="line">p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;</span><br><span class="line">p-&gt;tf-&gt;eflags = FL_IF; <span class="comment">//allow hardware interrupt</span></span><br><span class="line">p-&gt;tf-&gt;esp = PGSIZE;</span><br><span class="line">p-&gt;tf-&gt;eip = <span class="number">0</span>;  <span class="comment">// beginning of initcode.S</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>p-&gt;name</code> 設為 <code>"initcode"</code> 是為了 debug，<code>p-&gt;cwd</code> 設在 process 的現在目錄。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>設定 <code>p-&gt;state</code> 為 <code>RUNNABLE</code>。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Code-執行第一個-process">Code: 執行第一個 process<a class="header-anchor" href="#Code-執行第一個-process">#</a></h2><ul><li>當 <em>main</em> 呼叫完 <em>userinit</em> 後，呼叫 <em>mpmain</em>，<em>mpmain</em> 接著呼叫 <em>scheduler</em> 開始運行 process。</li></ul><div class="alert alert-success"><p><strong>File:</strong> main.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>完成多核心開機程序</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Common CPU setup code.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mpmain(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  cprintf(<span class="string">"cpu%d: starting\n"</span>, cpu-&gt;id);</span><br><span class="line">  idtinit();       <span class="comment">// load idt register</span></span><br><span class="line">  xchg(&amp;cpu-&gt;started, <span class="number">1</span>); <span class="comment">// tell startothers() we're up</span></span><br><span class="line">  scheduler();     <span class="comment">// start running processes</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong>File:</strong> proc.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>執行調度，指定執行的 process</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 42</span></span><br><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//      via swtch back to the scheduler.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">scheduler(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>第一行指令：<code>sti</code>，啟動處理器中斷；開機的時候在 <em>bootasm.S</em> 中將中斷禁止(<code>cli</code>)，在 XV6 準備完成後重新開啟。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;){</span><br><span class="line">  <span class="comment">// Enable interrupts on this processor.</span></span><br><span class="line">  sti();</span><br></pre></td></tr></tbody></table></figure><ul><li><em>Scheduler</em> 找到一個<code>p-&gt;state</code>為<code>RUNNABLE</code>的 process，此時是唯一的：<code>initproc</code>。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop over process table looking for process to run.</span></span><br><span class="line">acquire(&amp;ptable.lock);</span><br><span class="line"><span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state != RUNNABLE)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把 pre-cpu 的變量 <code>proc</code> 設為此 process。</li><li>呼叫 <code>switchuvm</code> 通知硬體開始使用目標 process 的  page table。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line"><span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line"><span class="comment">// before jumping back to us.</span></span><br><span class="line">proc = p;</span><br><span class="line">switchuvm(p);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把 <code>p-&gt;state</code> 設為 <code>RUNNING</code>。</li><li>呼叫 <code>swtch</code>，context switch 到目標程序的 kernel thread。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line">      swtch(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">      switchkvm();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      proc = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><div class="alert alert-success"><p><strong><strong>File:</strong></strong> vm.c</p></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch TSS and h/w page table to correspond to process p.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">switchuvm(struct proc *p)</span><br><span class="line">{</span><br><span class="line">  pushcli();</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;cpu-&gt;ts, <span class="keyword">sizeof</span>(cpu-&gt;ts)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">  cpu-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  ltr(SEG_TSS &lt;&lt; <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pgdir == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"switchuvm: no pgdir"</span>);</span><br><span class="line">  lcr3(v2p(p-&gt;pgdir));  <span class="comment">// switch to new address space</span></span><br><span class="line">  popcli();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>switchuvm</code> 同時設置好任務狀態段 <code>SEG_TSS</code>，讓硬體在 process 的 kernel stack 中執行 system call 與中斷。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line"><span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line"><span class="comment">// before jumping back to us.</span></span><br><span class="line">proc = p;</span><br><span class="line">switchuvm(p);</span><br></pre></td></tr></tbody></table></figure><ul><li>接著把 <code>p-&gt;state</code> 設為 <code>RUNNING</code>。</li><li>呼叫 <code>swtch</code>，context switch 到目標程序的 kernel thread。</li></ul><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line">      swtch(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">      switchkvm();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      proc = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="File-swtch-S"><strong>File:</strong> swtch.S<a class="header-anchor" href="#File-swtch-S">#</a></h3><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context **old, struct context *new)<span class="comment">;</span></span><br><span class="line"># </span><br><span class="line"># Save current register context <span class="keyword">in</span> old</span><br><span class="line"># <span class="keyword">and</span> then load register context from new.</span><br><span class="line"></span><br><span class="line"><span class="meta">.globl</span> swtch</span><br><span class="line"><span class="symbol">swtch:</span></span><br><span class="line">     movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">     movl <span class="number">8</span>(%esp), %edx</span><br><span class="line"></span><br><span class="line">     # Save old callee-save registers</span><br><span class="line">     pushl %ebp</span><br><span class="line">     pushl %ebx</span><br><span class="line">     pushl %esi</span><br><span class="line">     pushl %edi</span><br><span class="line"></span><br><span class="line">     # Switch stacks</span><br><span class="line">     movl %esp, (%eax)</span><br><span class="line">     movl %edx, %esp</span><br><span class="line"></span><br><span class="line">     # Load new callee-save registers</span><br><span class="line">     popl %edi</span><br><span class="line">     popl %esi</span><br><span class="line">     popl %ebx</span><br><span class="line">     popl %ebp</span><br><span class="line">     <span class="keyword">ret</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>ret</code> 指令從 stack pop 目標程序的 <code>%eip</code>，結束 context switch。</li><li>現在處理器在程序 p 的 kernel stack 上執行。</li><li><code>allocproc</code> 把 <code>initproc</code> 的 <code>p-&gt;context-&gt;eip</code> 設為 <code>forkret</code>，使得 <code>ret</code> 開始執行 <code>forkret</code>。</li><li>第一次執行 <code>forkret</code> 時會呼叫一些初始化函數(<code>initlog</code>)，接著返回。</li></ul><hr><div class="alert alert-success"><p><strong>File:</strong> proc.c</p></div><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>功能</th><th>回傳值</th></tr></thead><tbody><tr><td>-</td><td>void</td></tr></tbody></table></div><figure class="highlight c line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child's very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch here.  "Return" to user space.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">forkret(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Still holding ptable.lock from scheduler.</span></span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first) {</span><br><span class="line">    <span class="comment">// Some initialization functions must be run in the context</span></span><br><span class="line">    <span class="comment">// of a regular process (e.g., they call sleep), and thus cannot </span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    initlog();</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Return to "caller", actually trapret (see allocproc).</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>接著位於 p-&gt;context 的是 <code>trapret</code>。</li><li><code>%esp</code> 保存著 <code>p-&gt;tf</code>。</li><li><code>trapret</code> 恢復暫存器，如同　<code>swtch</code> 進行　context switch 一樣。</li><li><code>popal</code> 恢復通用暫存器</li><li><code>popl</code> 恢復<code>%gs</code>、<code>%fs</code>、<code>%es</code>、<code>%ds</code></li><li><code>addl</code> 跳過 <code>trapno</code> 和 <code>errcode</code> 兩個數據</li><li>最後 <code>iret</code> pop <code>%gs</code>、<code>%fs</code>、<code>%es</code>、<code>%ds</code> 出堆疊。</li></ul><div class="alert alert-success"><p><strong>File:</strong> trapasm.S</p></div><figure class="highlight x86asm"><table><tbody><tr><td class="code"><pre><span class="line">  # Return falls through to trapret...</span><br><span class="line"><span class="meta">.globl</span> trapret</span><br><span class="line"><span class="symbol">trapret:</span></span><br><span class="line">  popal</span><br><span class="line">  popl %gs</span><br><span class="line">  popl %fs</span><br><span class="line">  popl %es</span><br><span class="line">  popl %ds</span><br><span class="line">  addl <span class="number">$0</span>x8, %esp  # trapno <span class="keyword">and</span> errcode</span><br><span class="line">  <span class="keyword">iret</span></span><br></pre></td></tr></tbody></table></figure><div class="alert alert-info"><p><code>iret</code>：interrupt return，程序返回中斷前的位址。</p></div><ul><li>處理器從 <code>%eip</code> 的值繼續執行，對於 <code>initproc</code> 即為虛擬地址 0，也就是 <em>initcode.S</em> 的第一條指令。</li></ul><hr><h2 id="第一個-system-call：exec">第一個 system call：exec<a class="header-anchor" href="#第一個-system-call：exec">#</a></h2><ul><li><em>initcode.S</em> 第一件事是觸發 <code>exec</code> system call。</li><li><code>exec</code> 用一個新的程式代替當前 process 的記憶體及暫存器。</li><li>首先將<code>$argv</code>、<code>$init</code>、<code>$0</code> push 進堆疊，接著把 <code>%eax</code> 設為 <code>$SYS_exec</code>。</li><li>最後執行 <code>int $T_SYSCALL</code>。</li><li>這告訴 kernel 來運行 <code>exec</code>。</li><li>正常情況下，<code>exec</code> 不會返回；會運行名叫 <code>$init</code>(23) 的程式。</li><li><code>$init</code> 會 return <code>"/init\0"</code></li><li>若 <code>exec</code> 失敗了且返回，<em>initcode</em> 會不斷的呼叫一個 system call：<code>exit()</code>(17)。</li></ul><h3 id="File-initcode-S"><strong>File:</strong> initcode.S<a class="header-anchor" href="#File-initcode-S">#</a></h3><figure class="highlight x86asm line-number"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Initial process execs /init.</span><br><span class="line"></span><br><span class="line">#include <span class="string">"syscall.h"</span></span><br><span class="line">#include <span class="string">"traps.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line"><span class="meta">.globl</span> start</span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">  pushl $argv</span><br><span class="line">  pushl $init</span><br><span class="line">  pushl <span class="number">$0</span>  // where caller pc would be</span><br><span class="line">  movl $SYS_exec, %eax</span><br><span class="line">  <span class="keyword">int</span> $T_SYSCALL</span><br><span class="line"></span><br><span class="line"># for(<span class="comment">;;) exit();</span></span><br><span class="line"><span class="symbol">exit:</span></span><br><span class="line">  movl $SYS_exit, %eax</span><br><span class="line">  <span class="keyword">int</span> $T_SYSCALL</span><br><span class="line">  <span class="keyword">jmp</span> exit</span><br><span class="line"></span><br><span class="line"># char init[] = <span class="string">"/init\0"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">init:</span></span><br><span class="line"><span class="meta">  .string</span> <span class="string">"/init\0"</span></span><br><span class="line"></span><br><span class="line"># char *argv[] = { init, <span class="number">0</span> }<span class="comment">;</span></span><br><span class="line"><span class="meta">.p2align</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">argv:</span></span><br><span class="line"><span class="meta">  .long</span> init</span><br><span class="line"><span class="meta">  .long</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
            <tag> process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 - OS Interfaces</title>
      <link href="/posts/xv6/intro.html"/>
      <url>/posts/xv6/intro.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>OS的工作：有效率的在電腦上執行數個程式。</li><li>Kernel：提供 process 服務</li><li>Process：執行中的程式，擁有記憶體存放指令、資料、及堆疊。<ul><li>指令：實現程式的運算。</li><li>資料：運算中所用到的變數。</li><li>堆疊：組織 procedure 呼叫。</li></ul></li></ul><ol><li>當一個 process 需要調用 kernel 的服務時，就會調用一個<strong>procedure 呼叫</strong>至OS介面。</li><li>procedure 即為 <strong>system call</strong></li><li>system call 進入 kernel，kernel 回傳其服務。</li></ol><p><div class="img-item" data-src="https://i.imgur.com/N2chcG4.png" data-sub-html=".caption"><img src="https://i.imgur.com/N2chcG4.png" alt="System call sample" title="A kernel and two user processes."><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">System call sample</span></div></div></p><ul><li>Kernel 使用 CPU 的硬體保護機制去確保 process 只會在 user space 中執行，及只存取自己的記憶體（使用特權 privilege 機制）。</li></ul><hr><h2 id="Process-及記憶體">Process 及記憶體<a class="header-anchor" href="#Process-及記憶體">#</a></h2><ul><li>Time-share：透明的在等待執行的 process 中切換可用的CPU。<ul><li>當一個 process未執行時，XV6 保存其 CPU 暫存器，當下次要執行時再恢復。</li><li>Kernel 將一個 process 與其 pid（process identifier）連結。</li></ul></li><li><code>fork()</code>：一個 system call 用來新增子 process。</li></ul><p>子 process 與父 porcess 擁有同樣的記憶體<strong>內容</strong>，但是在不同的記憶體及暫存器上執行，所以在其中一個process 中改變一個變數值並不會影響另一個。</p><ul><li><code>exit()</code>：用來結束子 process。</li><li><code>wait()</code>：在主 process 中使用；當子 process 結束後，才繼續執行主 process（通常搭配 <code>exit()</code> 使用）。</li></ul><hr><h2 id="I-O-及檔案描述符">I/O 及檔案描述符<a class="header-anchor" href="#I-O-及檔案描述符">#</a></h2><ul><li>檔案描述符 file descriptor：一個小整數代表一個 process 可能會讀取或寫入的kernel-managed 物件；XV6 kernel 使用檔案描述符做為一個 pre-process table 的索引。<ul><li>0 standard input</li><li>1 standard output</li><li>2 standard error</li></ul></li><li>Shell 確保上述三個描述符每次都會被打開。</li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// read something from file descriptor to "buf"</span></span><br><span class="line">read(fd, buf, n);</span><br><span class="line"><span class="comment">// write something from "buf" to file descriptor</span></span><br><span class="line">write(fd, buf, n);</span><br><span class="line"><span class="comment">// both read and write will return n of how much its read/write</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Pipes">Pipes<a class="header-anchor" href="#Pipes">#</a></h2><ul><li>如同一條水管，pipes 的兩端連接不同的 process，其中一端寫入資料，其中一端讀取其資料。也就是說，pipes 提供使兩個不同的 process 互相溝通的方法。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># sample of pipes</span></span><br><span class="line"><span class="built_in">echo</span> hello world | wc</span><br><span class="line"><span class="comment"># another way call "temporary files"</span></span><br><span class="line"><span class="built_in">echo</span> hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</span><br></pre></td></tr></tbody></table></figure><ul><li>比較<ol><li>Pipes 會自我清理。</li><li>Pipes 可以任意長。</li><li>Pipes 允許同步，兩個 process 可以利用一條 pipe 進行訊息溝通。</li></ol></li></ul><hr><h2 id="檔案系統">檔案系統<a class="header-anchor" href="#檔案系統">#</a></h2><ul><li>一個文件即為位元組陣列。</li><li>一個目錄中包含一些檔案或其他的目錄。</li><li>目錄的結構為樹，且有一個<strong>根目錄 /</strong>（例如：/a/b/c）。</li><li>任何不從根目錄開始的路徑稱作 process 的當前目錄。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># create a new director</span></span><br><span class="line">mkdir(<span class="string">"/dir"</span>);</span><br><span class="line"><span class="comment"># open with 0_CREATE flag create a new file</span></span><br><span class="line">open(<span class="string">"/dir/file"</span>,0_CREARTE|0_WRONLY);</span><br></pre></td></tr></tbody></table></figure><ul><li>inode<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[理解inode](http://www.ruanyifeng.com/blog/2011/12/inode.html?utm_source=tool.lu)">[1]</span></a></sup>：儲存一個檔案的基本訊息，如檔案的權限、擁有者等等。</li><li>每個 inode 有一組唯一的號碼，檔案系統用此號碼來識別文件。</li></ul><div id="footnotes"><hr class="block-hr"><div id="footnotelist" class="card card-default"><div class="card-header">Reference</div><ol class="list-group list-group-flush" style="list-style: none; padding-left: 0; margin-left: 0px"><li id="fn:1" class="list-group-item"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: 0px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html?utm_source=tool.lu" target="_blank" rel="noopener">理解inode</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> XV6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> XV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 電腦運算的限制</title>
      <link href="/posts/ItC/overflow.html"/>
      <url>/posts/ItC/overflow.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="硬體">硬體<a class="header-anchor" href="#硬體">#</a></h2><p>算數上的限制</p><h3 id="整數">整數<a class="header-anchor" href="#整數">#</a></h3><p>32位元→ $-2^{31}$ ~ $2^{31}-1$</p><h3 id="實數">實數<a class="header-anchor" href="#實數">#</a></h3><ul><li>精確度：可以被表示的有效位數的最大數值。</li></ul><p>假設一個精確度為4位元，第五個位元表示指數，如：</p><figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">+  +  <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> 為 <span class="number">1234</span> * <span class="number">10</span>^<span class="number">9</span>，-  -  <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">6</span> 為 <span class="number">-1446</span> * <span class="number">10</span>^<span class="number">-3</span></span><br><span class="line">↑  ↑  ↑</span><br><span class="line">數 指 指</span><br><span class="line">字 數 數</span><br><span class="line">的 的 值</span><br></pre></td></tr></tbody></table></figure><h3 id="表示錯誤（捨去錯誤）">表示錯誤（捨去錯誤）<a class="header-anchor" href="#表示錯誤（捨去錯誤）">#</a></h3><ul><li>下溢位 underflow：表示為0。</li></ul><p>$$<br>\begin{equation}\begin{split}<br>4412 &amp; \times 10^{-9}\\<br>\times \ 1000 &amp; \times 10^{-8}\\<br>= 4412000 &amp; \times 10^{-17}\\<br>= 4412 &amp; \times 10^{-14}\\<br>\end{split}\end{equation}<br>$$</p><div class="alert alert-warning"><p>太小了無法表示</p></div><ul><li>上溢位 overflow：以最大值表示\</li></ul><p>$$<br>\begin{equation}\begin{split}<br>4412 &amp; \times 10^9\\<br>\times \ 1000 &amp; \times 10^8\\<br>= 4412000 &amp; \times 10^{17}\\<br>= 4412 &amp; \times 10^{20}\\<br>\end{split}\end{equation}<br>$$</p><div class="alert alert-warning"><p>太大了無法表示<br>表示為 $9999 \times 10^9$</p></div><ul><li>相消錯誤</li></ul><p>$$<br>\begin{equation}\begin{split}<br>1 + 0.00001234 - 1 &amp; = 0.00001234\\<br>100000000 \times 10^{-8}&amp;+\ 1234 \times 10^{-8}\\<br>= 100001234 \times 10^{-8} &amp;\to 1000 \times 10^{-3}\\\\<br>1000 \times 10^{-3} -  1000 &amp;\times 10^{-3}=0\\<br>\end{split}\end{equation}<br>$$</p><h3 id="溝通的限制">溝通的限制<a class="header-anchor" href="#溝通的限制">#</a></h3><h4 id="錯誤偵查編碼、錯誤修正編碼">錯誤偵查編碼、錯誤修正編碼<a class="header-anchor" href="#錯誤偵查編碼、錯誤修正編碼">#</a></h4><ul><li>同位元：用一個額外的位元來確保一個位元組的1的個數為基或偶數。</li><li>奇同位：如10001100，此時同位元為0，10111101，此時同位元為1。</li><li>偶同位</li><li>檢查位元：將所有位數加起來，存取總和的個位數，如 34376 總和為 23 ，儲存：34376-3。</li></ul><hr><h2 id="軟體">軟體<a class="header-anchor" href="#軟體">#</a></h2><h3 id="軟體的複雜性">軟體的複雜性<a class="header-anchor" href="#軟體的複雜性">#</a></h3><h3 id="軟體工程">軟體工程<a class="header-anchor" href="#軟體工程">#</a></h3><p>解決問題的步驟新增兩項，軟體需求、規格。</p><hr><h2 id="問題">問題<a class="header-anchor" href="#問題">#</a></h2><h3 id="Big-O-分析">Big-O 分析<a class="header-anchor" href="#Big-O-分析">#</a></h3><p>$$f(N) = N^4 + N^2 - 1 \to O(N^4)$$</p><ul><li>$O(1)$ 界線時間：如指定一個直到一個長度為N的陣列中的第i項。</li><li>$O(logN)$ 對數時間：如二元搜尋法 BST。</li><li>$O(N)$ 線性時間：如印出N筆資料。</li><li>$O(NlogN)$：如快速搜尋法。</li><li>$O(N^2)$：如簡單排序法。</li><li>$O(2^N)$ 指數時間</li><li>$O(N!)$ 階層時間</li></ul><h3 id="杜林機器（圖靈機器）">杜林機器（圖靈機器）<a class="header-anchor" href="#杜林機器（圖靈機器）">#</a></h3><ul><li>讀取紙帶上一個儲存格的符號</li><li>將一個符號寫入儲存格</li><li>向左/右移一格，或不動</li></ul><p>任何具有可計算性的東西都可以藉由杜林機器來運算</p><h3 id="演算法分類">演算法分類<a class="header-anchor" href="#演算法分類">#</a></h3><ul><li>多項式演算法 P 類別</li><li>NP 類別：可以在多項式時間內完成的演算法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 網路</title>
      <link href="/posts/ItC/internet.html"/>
      <url>/posts/ItC/internet.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="網路連接">網路連接<a class="header-anchor" href="#網路連接">#</a></h2><ul><li>網路的任一裝置被稱作節點或是主機 host。</li><li>資料傳輸率：即數據在網路上從一個點到另一個點的速度，也稱作網路頻寬 bandwidth。</li><li>通訊協定 protocol：用來描述所傳輸的資料如何格式化及處理。</li><li>主/從架構模式 client/server model：從屬端送出一個請求命令，伺服器送回所需的資訊或動作。<br><div class="img-item" data-src="https://i.imgur.com/mTUbgvk.png" data-sub-html=".caption"><img src="https://i.imgur.com/mTUbgvk.png" alt="主/從架構模式" title="主/從架構模式"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">主/從架構模式</span></div></div></li></ul><h3 id="網路類型">網路類型<a class="header-anchor" href="#網路類型">#</a></h3><h4 id="區域網路-LAN：封閉的網路。">區域網路 LAN：封閉的網路。<a class="header-anchor" href="#區域網路-LAN：封閉的網路。">#</a></h4><ul><li>環狀拓樸 ring topology：以封閉環路連接所有電腦，訊息以單方向傳遞。</li><li>星狀拓樸 star topology：以一個節點為中心，連結所有其他節點，透過中心發送訊息。中心承載大量網路負荷，若中心無法運作，則無法通訊。</li><li>匯流排拓樸 bus topology：所有節點都可以連上一個雙向的通訊線上，如乙太網路 Ethernet。</li></ul><h4 id="廣域網路-WAN：連結兩個或以上的區域網路。">廣域網路 WAN：連結兩個或以上的區域網路。<a class="header-anchor" href="#廣域網路-WAN：連結兩個或以上的區域網路。">#</a></h4><ul><li>閘道器 gateway：處理區域網路與其他網路的通訊。</li></ul><h4 id="都會網路-MAN：校園或都市的大型網路。">都會網路 MAN：校園或都市的大型網路。<a class="header-anchor" href="#都會網路-MAN：校園或都市的大型網路。">#</a></h4><ul><li>網際網路連接<ul><li>網際網路骨幹：運送網際網路資料的高容量資料網路路徑。</li><li>電話數據機</li><li>數位用戶電路 DSL</li><li>纜線數據機：寬頻。</li></ul></li></ul><h3 id="封包交換：">封包交換：<a class="header-anchor" href="#封包交換：">#</a></h3><p>將資料分成固定大小並編號的封包，傳送到目的地再將封包重組。</p><ul><li>路由器 route：引導封包傳遞的設備，每個路由器僅知道最接近目的地的最佳下一個行程。</li></ul><hr><h2 id="開放系統與協定">開放系統與協定<a class="header-anchor" href="#開放系統與協定">#</a></h2><ul><li>開放系統：OSI模式。</li></ul><p><div class="img-item" data-src="https://i.imgur.com/oYtZOwQ.png" data-sub-html=".caption"><img src="https://i.imgur.com/oYtZOwQ.png" alt="OSI" title="OSI模式"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">OSI</span></div></div></p><ul><li>網路協定<ul><li>協定堆疊：每一層的協定都堆疊在構成本層的協議上方。</li></ul></li></ul><h3 id="TCP-IP">TCP/IP<a class="header-anchor" href="#TCP-IP">#</a></h3><ul><li><p>IP：處理封包的路由，協處資料抵達目的地。</p></li><li><p>TCP：將資料處理成封包，及重組封包。</p></li><li><p>UDP：與TCP扮演同樣角色。</p></li><li><p>搜索工具 ping：測試網路可達性的IP程式。</p></li></ul><hr><h2 id="網路位址">網路位址<a class="header-anchor" href="#網路位址">#</a></h2><ul><li>主機名稱：如 <a href="http://github.io" target="_blank" rel="noopener">github.io</a>。</li></ul><h3 id="IP位址">IP位址<a class="header-anchor" href="#IP位址">#</a></h3><ul><li>IPv4：32位元，如：123.45.255.0</li><li>IPv6：128位元，如：FFFF : 0000 : 00F0 : 00FF : 00A2 : 1202</li></ul><h3 id="網域名稱">網域名稱<a class="header-anchor" href="#網域名稱">#</a></h3><p>電腦名稱由主機名稱＋網域名稱組成，網域名稱最後一欄為頂級網域，如：.com。</p><h3 id="網域名稱系統-DNS：">網域名稱系統 DNS：<a class="header-anchor" href="#網域名稱系統-DNS：">#</a></h3><p>將主機名稱轉為IP位址的系統。</p><hr><h2 id="雲端計算">雲端計算<a class="header-anchor" href="#雲端計算">#</a></h2><p>公有雲、私有雲、企業雲、混合雲。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 資訊系統</title>
      <link href="/posts/ItC/database.html"/>
      <url>/posts/ItC/database.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="管理資訊">管理資訊<a class="header-anchor" href="#管理資訊">#</a></h2><p>有三種普遍的資訊系統：電子試算表、資料庫管理系統及電子商務。</p><h2 id="試算表">試算表<a class="header-anchor" href="#試算表">#</a></h2><p>試算表 spreadsheet 允許使用者以標籤畫的儲存格來組織、分析資料，一個儲存格可儲存資料，如數字、文字等，或公式求值。<br>試算表通常以字母表示直欄 column，以數字表示橫列 row，如A5、B7等。</p><ul><li>試算表公式：如SUM、COUNT、MAX等。</li><li>循環參照：一個無解狀態，如B14 = D21+D22，而D21 = B13+B14。</li></ul><hr><h2 id="資料庫系統">資料庫系統<a class="header-anchor" href="#資料庫系統">#</a></h2><ul><li>資料庫 database：一套結構化的資料。</li><li>資料庫管理系統 DBMS：軟體和資料的結合，有三大要素：<ol><li>實體資料庫</li><li>資料庫引擎：配合資料庫語言，可指定資料的結構、新增、修改、刪除及查詢 query 資料。</li><li>資料庫綱要 schema：提供資料庫中資料的邏輯綱要。</li></ol></li></ul><h3 id="關聯式模型-relational-model">關聯式模型 relational model<a class="header-anchor" href="#關聯式模型-relational-model">#</a></h3><p>資料項目與他們的關係組織成資料表 table，資料表示一些紀錄的集合 record，一筆紀錄是一些相關欄位 field 的集合，一個欄位對應一個值。</p><p>一筆紀錄稱作一個資料庫物件或是一個實體 entity，一筆紀錄的欄位稱作資料庫物件的屬性 attribute。</p><p>關鍵欄位 key：用來識別資料表中的每個紀錄。</p><h3 id="結構化查詢語言-SQL">結構化查詢語言 SQL<a class="header-anchor" href="#結構化查詢語言-SQL">#</a></h3><p>用來管理關聯式資料庫的語言，包含了規範 schema、新增、修改、刪除及查詢資料。</p><ul><li>查詢：</li></ul><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">attribute</span>-<span class="keyword">list</span> <span class="keyword">FROM</span> <span class="keyword">table</span>-<span class="keyword">list</span> <span class="keyword">WHERE</span> condition</span><br></pre></td></tr></tbody></table></figure><p>如欲取回整個紀錄，可以用 *，需要字串比對，可以用 like：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span>-<span class="keyword">list</span> <span class="keyword">WHERE</span> condition <span class="keyword">like</span> <span class="string">'%doc%'</span></span><br></pre></td></tr></tbody></table></figure><p>也可以用 order by 來排序</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">attribute</span>-<span class="keyword">list</span> <span class="keyword">FROM</span> <span class="keyword">table</span>-<span class="keyword">list</span> <span class="keyword">WHERE</span> condition <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></tbody></table></figure><ul><li>修改：</li></ul><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">attribute</span>-<span class="keyword">list</span> <span class="keyword">values</span> (<span class="keyword">some</span> , <span class="string">'value'</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">attribute</span>-<span class="keyword">list</span> <span class="keyword">set</span> field_name = <span class="string">'value'</span> <span class="keyword">where</span> another_field = <span class="string">'value2'</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">attribute</span>-<span class="keyword">list</span> <span class="keyword">where</span> field_name = <span class="string">'value'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="資料庫的設計">資料庫的設計<a class="header-anchor" href="#資料庫的設計">#</a></h3><ul><li>實體 — 關係 ER 模型、ER圖</li><li>一對一、一對多、多對多</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 檔案系統及目錄</title>
      <link href="/posts/ItC/FS.html"/>
      <url>/posts/ItC/FS.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="檔案系統">檔案系統<a class="header-anchor" href="#檔案系統">#</a></h2><ul><li>檔案：一個命名的資料集合。</li><li>檔案系統：將一群檔案集合成目錄。</li><li>檔案型態：檔案中所含的資訊種類。</li><li>檔案名稱：主要名稱＋檔案延伸檔名（副檔名），如1023.c。</li></ul><h3 id="檔案的操作">檔案的操作<a class="header-anchor" href="#檔案的操作">#</a></h3><ul><li>檔案存取<ol><li>循序檔案存取：將檔案中的資訊依序存取，依照進度移動檔案指標。</li><li>直接檔案存取：將檔案分成數個邏輯紀錄，可直接存取某個紀錄而不需照順序。</li></ol></li><li>檔案保護</li></ul><hr><h2 id="目錄">目錄<a class="header-anchor" href="#目錄">#</a></h2><p>目錄為一群檔案的集合，同時目錄也表示成一個檔案（目錄檔）。</p><ul><li>目錄樹：一個目錄可以被包含在另一個目錄下，包含的目錄稱為父目錄，被包含的稱作子目錄；一個檔案系統被視為一個目錄樹，最上層的目錄稱作根目錄 root directory。</li><li>路徑名稱<ol><li>絕對路徑：由根目錄開始至所選的檔案，如：/usr/local/download/103.c</li><li>相對路徑：由目前的工作目錄開始，如：download/103.c</li></ol></li></ul><hr><h2 id="磁碟排程">磁碟排程<a class="header-anchor" href="#磁碟排程">#</a></h2><ul><li>搜尋時間 seek time：移動磁頭到指定磁住的時間。</li><li>潛在時間 latency：圓盤旋至正確位置，使讀寫資訊可以進行的額外時間。</li></ul><h3 id="FCFS">FCFS<a class="header-anchor" href="#FCFS">#</a></h3><p>即先到先服務</p><h3 id="SSTF">SSTF<a class="header-anchor" href="#SSTF">#</a></h3><p>即最短搜尋時間優先，讀寫完一個後會找一個最近的讀寫。</p><h3 id="SCAN">SCAN<a class="header-anchor" href="#SCAN">#</a></h3><p>從特定的方向開始，從頭走到尾，不斷的來回，有經過的都會服務；c-SCAN指的是只有一個方向會服務。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 作業系統</title>
      <link href="/posts/ItC/OS.html"/>
      <url>/posts/ItC/OS.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="作業系統的角色">作業系統的角色<a class="header-anchor" href="#作業系統的角色">#</a></h2><h3 id="記憶體、程序與CPU管理">記憶體、程序與CPU管理<a class="header-anchor" href="#記憶體、程序與CPU管理">#</a></h3><ul><li>持續追蹤什麼程式在記憶體，及其位置。</li><li>程序 process 為執行中的程式，追蹤程序的進展及記錄。</li><li>CPU 排程，為決定哪個程序可以執行。</li></ul><hr><h2 id="記憶體管理">記憶體管理<a class="header-anchor" href="#記憶體管理">#</a></h2><ul><li>邏輯位址：相對位址。</li><li>位址聯繫 address binding：邏輯位址對應到實體位址的過程。</li></ul><h3 id="單一連續記憶體管理">單一連續記憶體管理<a class="header-anchor" href="#單一連續記憶體管理">#</a></h3><p>記憶體中只有作業系統及一個要執行的程式。</p><h3 id="分割記憶體管理">分割記憶體管理<a class="header-anchor" href="#分割記憶體管理">#</a></h3><p>記憶體中允許多個程序。</p><ul><li>固定分割技術：分割區不需要相同大小，每個分割區的大小是固定的。</li><li>動態分割技術：程式載入至分割區後，多餘的空間會分割成新的分割區。</li></ul><h3 id="分頁記憶體管理">分頁記憶體管理<a class="header-anchor" href="#分頁記憶體管理">#</a></h3><p>記憶體分成固定大小的頁框 frame，程序分成同樣大小的分頁 page。</p><hr><h2 id="程序管理">程序管理<a class="header-anchor" href="#程序管理">#</a></h2><ul><li>程序狀態：new、ready、running、waiting、terminated。</li><li>程序控制區塊 PCB：儲存有關程序的各項資訊。</li></ul><hr><h2 id="CPU排程">CPU排程<a class="header-anchor" href="#CPU排程">#</a></h2><ul><li>先佔式排程：程序有可能在尚未執行完就被強制移出CPU。</li><li>非先佔式排程：程序不會在尚未執行完就被強制移出CPU。</li></ul><h3 id="先到先服務-FCFS（非先佔式）">先到先服務 FCFS（非先佔式）<a class="header-anchor" href="#先到先服務-FCFS（非先佔式）">#</a></h3><h3 id="最短工作優先-SJN（非先佔式）">最短工作優先 SJN（非先佔式）<a class="header-anchor" href="#最短工作優先-SJN（非先佔式）">#</a></h3><h3 id="循環輪流（先佔式）">循環輪流（先佔式）<a class="header-anchor" href="#循環輪流（先佔式）">#</a></h3><p>建立一個時間片段 time slice，使用CPU時間超過時間片段的程序必須先移出，直到下一次輪到此程序時才能繼續使CPU。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 物件導向與高階程式語言</title>
      <link href="/posts/ItC/OOP.html"/>
      <url>/posts/ItC/OOP.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="物件導向方法論">物件導向方法論<a class="header-anchor" href="#物件導向方法論">#</a></h2><h3 id="物件導向-OOP">物件導向 OOP<a class="header-anchor" href="#物件導向-OOP">#</a></h3><ul><li>物件 object：問題內可顯現的實體或事物。</li><li>類別 class：物件類別，將有共同特性的物件分類成相關群組，物件則為類別的實例。</li></ul><h3 id="設計方法論">設計方法論<a class="header-anchor" href="#設計方法論">#</a></h3><ol><li>腦力激盪：來產生一個候補的類別表單。</li><li>過濾：決定哪些類別是問題解決的核心類別。</li><li>劇本：為每個類別指定「責任」，即為每個類別必須完成的工作，也就是副程式。</li><li>責任演算法：演算法須依責任來撰寫。<ul><li>兩種責任類型：知識（是什麼）及行為（做什麼）。</li></ul></li></ol><div class="alert alert-info"><p>class 會將資料封裝，也就是把資料和動作捆綁在一起，別的 class 無法存去此資訊。</p></div><hr><h2 id="翻譯過程">翻譯過程<a class="header-anchor" href="#翻譯過程">#</a></h2><ul><li><p>編譯器 compiler：將高階語言翻譯成針對電腦的機器語言，再執行。</p></li><li><p>直譯器 interpreter：翻譯完一行就立即執行此行，類似於此高階語言的模擬器或是虛擬機。</p></li><li><p>高階語言也分成兩大類：編譯式、直譯式。</p><ul><li>JAVA 將程式編譯成位元組碼，為一種標準的機器語言，程式需在java的虛擬機(JVM)上執行。</li></ul></li></ul><hr><h2 id="程式語言方法">程式語言方法<a class="header-anchor" href="#程式語言方法">#</a></h2><h3 id="命令式架構">命令式架構<a class="header-anchor" href="#命令式架構">#</a></h3><ul><li>用一連串的指令執行，用變數代表記憶體位置，使用一些敘述來改變其值。<ul><li>程序式架構：敘述被分成副程式。</li><li>物件導向架構：每個物件負責他自己的動作。</li></ul></li></ul><h3 id="宣告式架構">宣告式架構<a class="header-anchor" href="#宣告式架構">#</a></h3><ul><li>函數模式：是基於函數的運算概念。</li><li>邏輯模式：是基於邏輯原理而來。</li></ul><hr><h2 id="高階語言功能">高階語言功能<a class="header-anchor" href="#高階語言功能">#</a></h2><h3 id="布林表示式：即判斷式或條件式，可以是">布林表示式：即判斷式或條件式，可以是<a class="header-anchor" href="#布林表示式：即判斷式或條件式，可以是">#</a></h3><ol><li>一個布林變數：如 true。</li><li>一個算數表示式＋一個關係運算子＋一個算數表示式，如：d1&lt;d2。</li><li>一個布林表示式＋一個布林運算子＋一個布林表示式，如：a&lt;1 or b&gt;1</li></ol><h3 id="資料型態：如-int、char、bool、string等。">資料型態：如 int、char、bool、string等。<a class="header-anchor" href="#資料型態：如-int、char、bool、string等。">#</a></h3><ul><li>強制型態：要指定一個記憶體位置時，須先說明此資料型態，非此資料型態不可以存入此記憶體位置。</li></ul><h3 id="控制結構">控制結構<a class="header-anchor" href="#控制結構">#</a></h3><ul><li>結構化程式設計：程式的每一個邏輯單元只允許一個入口及一個出口。</li><li>巢狀邏輯</li></ul><hr><h2 id="物件導向語言功能">物件導向語言功能<a class="header-anchor" href="#物件導向語言功能">#</a></h2><ul><li>封裝：資訊隱藏。</li><li>類別</li><li>繼承：類別可被繼承，衍生類即為執行繼承的類別。</li><li>多形</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 抽象資料型態與副程式</title>
      <link href="/posts/ItC/data-structure.html"/>
      <url>/posts/ItC/data-structure.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="抽象資料型態">抽象資料型態<a class="header-anchor" href="#抽象資料型態">#</a></h2><p>Abstract data type, ADT，就是一種容器。</p><h2 id="堆疊-Stack">堆疊 Stack<a class="header-anchor" href="#堆疊-Stack">#</a></h2><p>為LIFO(Last In First Out)，後進先出，即當我們要放資料時，放在最上面（也就是最後一個），要拿資料的時候也是拿最上面。</p><p><div class="img-item" data-src="https://i.imgur.com/5WjOSt2.png" data-sub-html=".caption"><img src="https://i.imgur.com/5WjOSt2.png" alt="stack" title="堆疊"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">stack</span></div></div></p><ul><li>插入 Push</li><li>刪除 Pop</li></ul><hr><h2 id="佇列-Queue">佇列 Queue<a class="header-anchor" href="#佇列-Queue">#</a></h2><p>為FIFO(First In First Out)，先進先出，即當我們要放資料時，排在最後面 rear，拿資料時拿第一個 front；類似於排隊。</p><p><div class="img-item" data-src="https://i.imgur.com/TT68nAV.png" data-sub-html=".caption"><img src="https://i.imgur.com/TT68nAV.png" alt="queue" title="佇列"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">queue</span></div></div></p><hr><h2 id="串列">串列<a class="header-anchor" href="#串列">#</a></h2><p>項目是同性質的、線性的、可變長度的；可由陣列實現。</p><ul><li>也可視為鍵結結構，基於節點 node的概念，一個接著下一個。</li></ul><hr><h2 id="樹-Tree">樹 Tree<a class="header-anchor" href="#樹-Tree">#</a></h2><h3 id="二元樹">二元樹<a class="header-anchor" href="#二元樹">#</a></h3><p>每個node有兩個後繼節點，稱作子結點 children，可一直延續下去。起始節點稱作樹根 root。<br><br>一個node 可能有0至2個節點，左邊的稱作 left child，右邊的稱作 right child；如有一個節點沒有子結點，則稱作樹葉 leaf。</p><p><div class="img-item" data-src="https://i.imgur.com/B9nhAz7.png" data-sub-html=".caption"><img src="https://i.imgur.com/B9nhAz7.png" alt="二元樹" title="二元樹"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">二元樹</span></div></div></p><h3 id="二元搜尋樹-BST">二元搜尋樹 BST<a class="header-anchor" href="#二元搜尋樹-BST">#</a></h3><p>如果 left child &lt; node &lt; right child，則此數為BST。</p><p><div class="img-item" data-src="https://i.imgur.com/YJ2kFFZ.png" data-sub-html=".caption"><img src="https://i.imgur.com/YJ2kFFZ.png" alt="二元搜尋樹" title="二元搜尋樹"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">二元搜尋樹</span></div></div></p><hr><h2 id="圖形-Graph">圖形 Graph<a class="header-anchor" href="#圖形-Graph">#</a></h2><p>G=(V,E)，V 為圖形中的點集合，E 為編集合。<br><br>如果邊有方向，稱作有向圖，反之，則為無向圖。<br><br>若兩個邊之間存在一條邊，則稱作相鄰頂點。<br><br>兩點之間的路徑由一連串的相鄰頂點組成。</p><h3 id="圖形演算法">圖形演算法<a class="header-anchor" href="#圖形演算法">#</a></h3><ul><li>深度優先搜索 BFS</li><li>廣度優先搜索 DFS</li><li>最短路徑搜索</li></ul><hr><h2 id="副程式">副程式<a class="header-anchor" href="#副程式">#</a></h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">swap(num1,num2)</span><br><span class="line">temp ← num1</span><br><span class="line">num1 ← num2</span><br><span class="line">num2 ← temp</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 問題解決與演算法設計</title>
      <link href="/posts/ItC/algorithm.html"/>
      <url>/posts/ItC/algorithm.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="如何解決問題">如何解決問題<a class="header-anchor" href="#如何解決問題">#</a></h2><blockquote><p>以問題取代未知數、以資訊取代資料、以解待取待理論。</p></blockquote><ul><li>一般的問題解決過程<br>提出問題 <i class="fa fa-long-arrow-right"></i> 尋找熟悉的事物 <i class="fa fa-long-arrow-right"></i> 分割並征服 <i class="fa fa-long-arrow-right"></i> 演算法。</li><li>電腦的問題解決過程<br>分析與定義階段 <i class="fa fa-long-arrow-right"></i> 演算法開發階段 <i class="fa fa-long-arrow-right"></i> 實作階段 <i class="fa fa-long-arrow-right"></i> 維護階段。</li></ul><hr><h2 id="簡單變數演算法">簡單變數演算法<a class="header-anchor" href="#簡單變數演算法">#</a></h2><ul><li>可選擇的演算法：IF THEN ELSE。</li></ul><h3 id="重複演算法">重複演算法<a class="header-anchor" href="#重複演算法">#</a></h3><ul><li>技術控制型迴圈<ul><li>由三部分組成：起始化、測試、增量。</li></ul></li></ul><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">count</span> <span class="keyword">to</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">WHILE</span>(<span class="keyword">count</span> &lt; <span class="keyword">limit</span>)</span><br><span class="line">…</span><br><span class="line"><span class="keyword">count</span> ← <span class="keyword">count</span> + <span class="number">1</span></span><br><span class="line">…</span><br></pre></td></tr></tbody></table></figure><ul><li>事件控制型迴圈<ul><li>巢狀結構</li></ul></li></ul><figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">WHILE</span><span class="params">(count &lt; limit)</span></span></span><br><span class="line"><span class="function"><span class="title">IF</span><span class="params">(value&lt;<span class="number">0</span>)</span></span></span><br><span class="line">…</span><br><span class="line">…</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="複合變數">複合變數<a class="header-anchor" href="#複合變數">#</a></h2><ul><li>陣列：為同性質項目的集合。<ul><li>索引 index：由0開始，代表位置。</li><li>陣列名字[index]</li></ul></li><li>紀錄：為不同性質項目的集合。<ul><li>名字.欄位名稱</li></ul></li></ul><hr><h2 id="搜索演算法">搜索演算法<a class="header-anchor" href="#搜索演算法">#</a></h2><p>二元搜索：由以排序過的陣列搜索，每次與中間比較，再將搜索範圍減半，直到找到答案。</p><h2 id="排序">排序<a class="header-anchor" href="#排序">#</a></h2><p>泡沫排序：每次由最後一項與前一項相比，若比較小則交換，直到最前；若從底至頭都沒有需要交換，則排序結束。</p><h2 id="遞迴演算法">遞迴演算法<a class="header-anchor" href="#遞迴演算法">#</a></h2><p>分為兩種狀況：底層狀況、一般狀況。</p><ul><li>副程式敘述：將一段程式碼命名，並移至外部；有回傳值的，也有不回傳值的。</li></ul><hr><h2 id="重要的串連思路">重要的串連思路<a class="header-anchor" href="#重要的串連思路">#</a></h2><ul><li>資訊隱藏</li><li>抽象概念</li><li>為事件命名</li><li>測試</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 低階程式語言與虛擬碼</title>
      <link href="/posts/ItC/code.html"/>
      <url>/posts/ItC/code.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="電腦的動作">電腦的動作<a class="header-anchor" href="#電腦的動作">#</a></h2><blockquote><p>即可程式化 programmable、儲存 store、擷取 retrieve 及運算 process。</p></blockquote><h2 id="機器語言">機器語言<a class="header-anchor" href="#機器語言">#</a></h2><p>機器語言是電腦唯一能執行的指令，由二進制的數字組成。</p><h3 id="Pep-8-虛擬電腦">Pep/8 虛擬電腦<a class="header-anchor" href="#Pep-8-虛擬電腦">#</a></h3><p>依據不同的CPU會有不同的機器語言，而Pep/8為一台假想的電腦，具有真實電腦應有的特徵，及39個機器語言指令。</p><ul><li>記憶單元：由65536個位元組的記憶體組成。</li><li>字語長度：2個位元組，也就是16位元。</li><li>CPU 內有7個暫存器，以下會討論到三個：<ul><li>PC 程式計數器：存放下一個被執行的指令位址。</li><li>IR 程式暫存器：儲存目前執行的指令。</li><li>累加器（A暫存器）。</li></ul></li></ul><p>一個位元組能表示的最大數為255(base 10)，也就是11111111(base 2)、0xFF，一個字語（16位元）能表示的最大數為65535，也就是0xFFFF，若要表示負數，則範圍為0x-7FFF~0x7FFF</p><h3 id="指令格式">指令格式<a class="header-anchor" href="#指令格式">#</a></h3><p>有兩個部分：<br>8bits 的指令指標 instruction specifier：表示要執行何種運算，及指標需如何解讀。<br>16bits 的運算元指標 operand specifier（非必要）：存放運算元本身或運算元地址。</p><ul><li>指令指標格式</li></ul><p>運算碼 operation codes (opcodes) 有4~8個位元長度，我們討論4或是5個bit的，其中 4bits 的第五個 bit 用來表示使用哪個暫存器，暫存器指標為0代表使用A暫存器。</p><p>定址模式指標佔 3bits，如果為000代表為立即定址，代表運算元指標即運算元本身；001為直接定址，代表運算元指標為記憶體位址；還有兩種定址模式不討論。</p><hr><h2 id="組合語言">組合語言<a class="header-anchor" href="#組合語言">#</a></h2><p>以指定的字母來助憶機器語言，由組譯器負責翻譯。</p><h3 id="Pep-8-組合語言">Pep/8 組合語言<a class="header-anchor" href="#Pep-8-組合語言">#</a></h3><p>運算碼由0x和四位16進位值組成，定址模式由i（立即）或d（直接）表示。</p><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th style="text-align:center">組合語言</th><th style="text-align:center">機器語言</th><th style="text-align:center">運算元指標</th></tr></thead><tbody><tr><td style="text-align:center">STOP</td><td style="text-align:center">0000</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LDA</td><td style="text-align:center">1100</td><td style="text-align:center">0x0008,i</td></tr><tr><td style="text-align:center">LDA</td><td style="text-align:center">1100</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">STA</td><td style="text-align:center">1110</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">ADDA</td><td style="text-align:center">0111</td><td style="text-align:center">0x0008,i</td></tr><tr><td style="text-align:center">ADDA</td><td style="text-align:center">0111</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">SUBA</td><td style="text-align:center">1000</td><td style="text-align:center">0x0008,i</td></tr><tr><td style="text-align:center">SUBA</td><td style="text-align:center">1000</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">BR</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CHARI</td><td style="text-align:center">01001</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">CHARO</td><td style="text-align:center">01010</td><td style="text-align:center">0x0008,i</td></tr><tr><td style="text-align:center">CHARO</td><td style="text-align:center">01010</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">DECI</td><td style="text-align:center">00110</td><td style="text-align:center">0x0008,d</td></tr><tr><td style="text-align:center">DECO</td><td style="text-align:center">00111</td><td style="text-align:center">0x0008,i</td></tr><tr><td style="text-align:center">DECO</td><td style="text-align:center">00111</td><td style="text-align:center">0x0008,d</td></tr></tbody></table></div><h3 id="組譯器指揮動作">組譯器指揮動作<a class="header-anchor" href="#組譯器指揮動作">#</a></h3><ul><li>.ASCII+”STR/x00"：表示一組字串。</li><li>.BLOCK+位元組數目：產生一個空間。</li><li>.WORD+值：指派一個值給字語。</li><li>.END：結束。</li></ul><h3 id="分歧指令">分歧指令<a class="header-anchor" href="#分歧指令">#</a></h3><ul><li>BRLT，若小於則跳至分歧。</li><li>BREQ，若等於則跳至分歧。</li></ul><hr><h2 id="演算法表示">演算法表示<a class="header-anchor" href="#演算法表示">#</a></h2><h3 id="虛擬碼-pseudocode-功能">虛擬碼 pseudocode 功能<a class="header-anchor" href="#虛擬碼-pseudocode-功能">#</a></h3><ul><li>變數：出現的名稱，需反應其角色。</li><li>指定：變數需要放值，如 Set sum to 0，或是 sum ← 0。</li></ul><p>也可以用 Set sum to sum + num，或是 sum ← sum + num。</p><ul><li>輸入/輸出</li></ul><figure class="highlight cos"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">Write</span> “Hello word!”</span><br><span class="line"><span class="keyword">Read</span> num</span><br></pre></td></tr></tbody></table></figure><ul><li>選擇</li></ul><figure class="highlight fortran"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span>(<span class="built_in">sum</span>&lt;<span class="number">0</span>)…</span><br><span class="line"><span class="keyword">ELSE</span> …</span><br></pre></td></tr></tbody></table></figure><ul><li>重複</li></ul><figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="constructor">WHILE(<span class="params">counter</span> &lt; <span class="params">limit</span>)</span> …</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 電腦元件</title>
      <link href="/posts/ItC/com.html"/>
      <url>/posts/ItC/com.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="個別電腦元件">個別電腦元件<a class="header-anchor" href="#個別電腦元件">#</a></h2><ul><li>處理器速度 Hz 表示，如 2.7GHz。</li><li>計時器速度，如1066MHz；FSB，front side bus 前端匯排流。</li></ul><hr><h2 id="程式儲存化概念">程式儲存化概念<a class="header-anchor" href="#程式儲存化概念">#</a></h2><h3 id="范紐曼架構：資料與指令可存於同個地方，具有五個元件：">范紐曼架構：資料與指令可存於同個地方，具有五個元件：<a class="header-anchor" href="#范紐曼架構：資料與指令可存於同個地方，具有五個元件：">#</a></h3><ul><li>記憶體單元：具有儲存格，及定址能力。</li><li>算數邏輯單元 ALU：能完成基本運算及邏輯運算。</li><li>輸出單元：可將運算結果傳至電腦外的裝置。</li><li>輸入單元：將資料帶進電腦的裝置。</li><li>控制單元：包含兩個暫存器，IR 指令暫存器及 PC 程式計數器。</li></ul><div class="alert alert-info"><p>ALU 與控制單元組成CPU。</p></div><ul><li>匯流排 bus：連接不同單元的排線。</li><li>匯流排寬度：可以同時被傳輸的位元數目。</li></ul><h3 id="擷取-執行週期">擷取/執行週期<a class="header-anchor" href="#擷取-執行週期">#</a></h3><p>擷取下一個指令→將指令解碼 → 取得資料 → 執行指令</p><ul><li>RAM：每個儲存格都可以直接存取、改變；關機時資料會不見。</li><li>ROM：內容不可改變。</li></ul><hr><h2 id="平行架構">平行架構<a class="header-anchor" href="#平行架構">#</a></h2><ul><li>平行處理<ul><li>位元級：依據字組大小的增加，如一個8位元的電腦處理16位元的運算，則需兩個運算。</li><li>指令級：依據程式上某些指令可以獨立平行的執行。</li><li>資料級：單一指令可以在不同資料集合上執行。</li><li>任務級：基於不同的處理器，可以在相同或不同的資料集合上執行不同任務。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 閘與電路</title>
      <link href="/posts/ItC/gate.html"/>
      <url>/posts/ItC/gate.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="電腦與電學">電腦與電學<a class="header-anchor" href="#電腦與電學">#</a></h2><p>電子訊號有某個電壓準位，一般而言電壓準位在 0~2 伏特時屬於「低」，代表二進制的 0，而位於 2~5 伏特時則為「高」，代表二進制的 1。</p><ul><li>閘 gate：是完成電子訊號基本運算的裝置。閘接受一至多個輸入訊號，產生單一輸出訊號；有數種特定裝置的閘，以下討論六種基本的閘。</li><li>電路 circuits：閘可組成電路，完成更複雜的工作。有三種可以描述電路的表示法：<ul><li>布林表示法</li><li>邏輯圖</li><li>真值表</li></ul></li></ul><hr><h2 id="閘">閘<a class="header-anchor" href="#閘">#</a></h2><h3 id="1-NOT閘">1. NOT閘<a class="header-anchor" href="#1-NOT閘">#</a></h3><p>NOT閘接受一個輸入，產生一個輸出。</p><h4 id="DEF">DEF<a class="header-anchor" href="#DEF">#</a></h4><p>如輸入為 1，則輸出 0；反之亦然。</p><h4 id="布林運算式">布林運算式<a class="header-anchor" href="#布林運算式">#</a></h4><p>$X = A '$</p><h4 id="邏輯圖">邏輯圖<a class="header-anchor" href="#邏輯圖">#</a></h4><p><div class="img-item" data-src="https://i.imgur.com/mHBP6FW.png" data-sub-html=".caption"><img src="https://i.imgur.com/mHBP6FW.png" alt="NOT閘" title="NOT閘"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">NOT閘</span></div></div></p><h4 id="真值表">真值表<a class="header-anchor" href="#真值表">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>X</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table></div><hr><h3 id="2-AND閘">2. AND閘<a class="header-anchor" href="#2-AND閘">#</a></h3><p>AND閘接受多個訊號，產生一個輸出。</p><h4 id="DEF-v2">DEF<a class="header-anchor" href="#DEF-v2">#</a></h4><p>若輸入全為1，則輸出1，反之，則為0。</p><h4 id="布林運算式-v2">布林運算式<a class="header-anchor" href="#布林運算式-v2">#</a></h4><p>$X = A \cdot B$</p><h4 id="邏輯圖-v2">邏輯圖<a class="header-anchor" href="#邏輯圖-v2">#</a></h4><p><div class="img-item" data-src="https://i.imgur.com/IJHEbrP.png" data-sub-html=".caption"><img src="https://i.imgur.com/IJHEbrP.png" alt="AND閘" title="AND閘"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">AND閘</span></div></div></p><h4 id="真值表-v2">真值表<a class="header-anchor" href="#真值表-v2">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th>X</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><hr><h3 id="3-OR閘">3.OR閘<a class="header-anchor" href="#3-OR閘">#</a></h3><p>OR閘接受兩個輸入，產生一個輸出。</p><h4 id="DEF-v3">DEF<a class="header-anchor" href="#DEF-v3">#</a></h4><p>如兩個輸入全為0，則輸出0，反之，輸出1。</p><h4 id="布林運算式-v3">布林運算式<a class="header-anchor" href="#布林運算式-v3">#</a></h4><p>$X = A + B$</p><h4 id="邏輯圖-v3">邏輯圖<a class="header-anchor" href="#邏輯圖-v3">#</a></h4><p><div class="img-item" data-src="https://i.imgur.com/87CEd05.png" data-sub-html=".caption"><img src="https://i.imgur.com/87CEd05.png" alt="OR閘" title="OR閘"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">OR閘</span></div></div></p><h4 id="真值表-v3">真值表<a class="header-anchor" href="#真值表-v3">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th>X</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><hr><h3 id="4-XOR閘">4.XOR閘<a class="header-anchor" href="#4-XOR閘">#</a></h3><p>XOR閘，又稱互斥閘。</p><h4 id="DEF-v4">DEF<a class="header-anchor" href="#DEF-v4">#</a></h4><p>若輸出相同，則輸出0，反之，輸出1。</p><h4 id="布林運算式-v4">布林運算式<a class="header-anchor" href="#布林運算式-v4">#</a></h4><p>$X = A \oplus B$</p><h4 id="邏輯圖-v4">邏輯圖<a class="header-anchor" href="#邏輯圖-v4">#</a></h4><p><div class="img-item" data-src="https://i.imgur.com/dyp1SSN.png" data-sub-html=".caption"><img src="https://i.imgur.com/dyp1SSN.png" alt="XOR閘" title="XOR閘"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">XOR閘</span></div></div></p><h4 id="真值表-v4">真值表<a class="header-anchor" href="#真值表-v4">#</a></h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th>X</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><hr><h3 id="5-NAND-與-NOR閘">5.NAND 與 NOR閘<a class="header-anchor" href="#5-NAND-與-NOR閘">#</a></h3><p>分別為AND與OR閘的相反</p><h4 id="NAND閘">NAND閘<a class="header-anchor" href="#NAND閘">#</a></h4><h5 id="布林運算式-v5">布林運算式<a class="header-anchor" href="#布林運算式-v5">#</a></h5><p>$X = ( A \cdot B ) '$</p><h5 id="邏輯圖-v5">邏輯圖<a class="header-anchor" href="#邏輯圖-v5">#</a></h5><p><div class="img-item" data-src="https://i.imgur.com/LVGmMnV.png" data-sub-html=".caption"><img src="https://i.imgur.com/LVGmMnV.png" alt="NAND閘" title="NAND閘"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">NAND閘</span></div></div></p><h5 id="真值表-v5">真值表<a class="header-anchor" href="#真值表-v5">#</a></h5><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th>X</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><hr><h4 id="NOR閘">NOR閘<a class="header-anchor" href="#NOR閘">#</a></h4><h5 id="布林運算式-v6">布林運算式<a class="header-anchor" href="#布林運算式-v6">#</a></h5><p>$X = ( A + B ) '$</p><h5 id="邏輯圖-v6">邏輯圖<a class="header-anchor" href="#邏輯圖-v6">#</a></h5><p><div class="img-item" data-src="https://i.imgur.com/76wkbGw.png" data-sub-html=".caption"><img src="https://i.imgur.com/76wkbGw.png" alt="NOR閘" title="NOR閘"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">NOR閘</span></div></div></p><h5 id="真值表-v6">真值表<a class="header-anchor" href="#真值表-v6">#</a></h5><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th>X</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><hr><h2 id="閘的建構">閘的建構<a class="header-anchor" href="#閘的建構">#</a></h2><ul><li>電晶體 transistor：是以半導體所製成，依據電壓準位來決定要當導線還是電阻的裝置。<br><div class="img-item" data-src="https://i.imgur.com/I6OFGJq.png" data-sub-html=".caption"><img src="https://i.imgur.com/I6OFGJq.png" alt="transistor" title="電晶體"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">transistor</span></div></div></li></ul><p>射極一般是接地的。而對電腦而言，源極產生大約5伏特的高電壓值，基極的電壓值用來判斷源極是否形成接地，若接地，電壓值會被下拉至0，反之，則會維持高電壓。</p><ul><li>輸出線會接在源極上，若源極接地，則輸出為低準位（二進制的 0），反之則為高準位（二進制的 1）。</li><li>如基極訊號為高準位，則源極接地，此時電晶體為 on，反之，電晶體為off。</li></ul><hr><h2 id="電路">電路<a class="header-anchor" href="#電路">#</a></h2><ul><li>組合電路<br><br>藉由某個閘的輸出作為另一個閘的輸入，便可組合成電路。<br><div class="img-item" data-src="https://i.imgur.com/cvi0B0J.png" data-sub-html=".caption"><img src="https://i.imgur.com/cvi0B0J.png" alt="組合電路" title="組合電路範例"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">組合電路</span></div></div></li></ul><p>其中圖中的黑點，表示兩線是相連接的，如果沒有點，代表其中一條線從另一條線的上方跳過，互不影響。<br><br>此邏輯圖的布林運算式為：( AB + AC )，也可寫成 A ( B + C )，讀者可自行寫出真值表來確認。此現象稱作電路等效性。<br></p><ul><li><p>事實上，布林運算式滿足幾種數學性質：</p><ul><li>交換律，如：$AB = BA$、$A + B = B + A$。</li><li>結合律，如：$( AB ) C = A ( BC )$、$A + ( B + C ) = ( A + B ) + C$。</li><li>分配律，如：$A ( B + C ) = AB + AC$、$A + BC = ( A + B ) ( A + C )$。</li><li>恆等，如：$A1 = A$、$A + 0 = A$。</li><li>互補，如：$A ( A ’ ) = 0$、$A + A ’ = 1$。</li><li>狄摩根定律，如：$( AB ) ’ = A ’ + B '$、$( A + B ) ’ = A ’ B '$。</li></ul></li><li><p>加法器<br><br>二進制數元相加可能會產生進位值，如 1 + 1 = 10，能計算 2 個位元總和並產生進位為元的電路稱作半加器 half adder。<br>考慮半加器時，可寫出以下真值表：</p></li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th style="text-align:center">總和</th><th style="text-align:center">進位</th></tr></thead><tbody><tr><td>0</td><td>0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td>1</td><td>0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>0</td><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>1</td><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><p>可看出來，總和為 $A \oplus B$，進位為 $AB$。<br></p><ul><li>一個半加器並未將可能的進位值併入計算，也就是說，一個半加器在兩個單一數元的相加是沒問題的，但在多重數元時會產生問題。</li><li>可以考慮進位輸入的電路稱作全加器 full adder。簡單的想法可以用兩個半加器來製作一個全加器；作法為：在總和輸出前，再加上一個半加器與進位輸入做總和，最後調整進位輸出。<br>以下為全加器的真值表及邏輯圖：</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>A</th><th>B</th><th style="text-align:center">進位輸入</th><th style="text-align:center">總和</th><th style="text-align:center">進位輸出</th></tr></thead><tbody><tr><td>0</td><td>0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td>0</td><td>0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>0</td><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>0</td><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>1</td><td>0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td>1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td>1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p><div class="img-item" data-src="https://i.imgur.com/Y6PH0oI.png" data-sub-html=".caption"><img src="https://i.imgur.com/Y6PH0oI.png" alt="加法器" title="全加器"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">加法器</span></div></div></p><ul><li>多工器 multiplexer<br><br>為一種產生單一輸出的電路，輸出等於電路中數個輸入的其中一個。依據一些原始輸入以外的輸入訊號（選擇訊號、選擇控制線）來決定哪條輸入將被輸出。<br>如：選擇訊號為 S0、S1、S2，輸入為D0~D7，則有以下真值表。</li></ul><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th>S0</th><th>S1</th><th>S2</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>D0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>D1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>D2</td></tr><tr><td>0</td><td>1</td><td>0</td><td>D3</td></tr><tr><td>1</td><td>0</td><td>1</td><td>D4</td></tr><tr><td>1</td><td>0</td><td>0</td><td>D5</td></tr><tr><td>1</td><td>1</td><td>1</td><td>D6</td></tr><tr><td>1</td><td>1</td><td>0</td><td>D7</td></tr></tbody></table></div><p>上述多工器可化成此方塊圖。<br><br><div class="img-item" data-src="https://i.imgur.com/zrGhNVm.png" data-sub-html=".caption"><img src="https://i.imgur.com/zrGhNVm.png" alt="多工器" title="多工器"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">多工器</span></div></div></p><hr><h2 id="作為記憶體的電路">作為記憶體的電路<a class="header-anchor" href="#作為記憶體的電路">#</a></h2><p>數位電路也可以儲存資訊，這些電路形成一個循序電路，電路的輸出可以當成電路的輸入，也就是說，某些電路的存在狀態有些被用來決定此電路的下個狀態；一些記憶體設計如：S-R閂。</p><ul><li>S-R閂 S-R latch：用來儲存一個單一二進制的數元。<br><div class="img-item" data-src="https://i.imgur.com/kubXSgE.png" data-sub-html=".caption"><img src="https://i.imgur.com/kubXSgE.png" alt="S-R閂" title="S-R閂"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">S-R閂</span></div></div></li></ul><p>S Set、R Reset，透過此設計，只要S與R保持為1，X與Y的值皆能保持不變；通常，我們把X當作現在電路的狀態。<br><br>假設目前X為1，則Y為0，如果須將X設為0的話，只需將R設為0，X就會變成0，這時立刻將R設為1，X就會保持為0了。相反的，如需將X設為1，則需變動S為0，待X變為1後，再立刻改變S為1，X就會保持為1。</p><hr><h2 id="積體電路">積體電路<a class="header-anchor" href="#積體電路">#</a></h2><p>積體電路是一種嵌入多重閘的矽片，矽片邊緣上有許多腳位，代表著輸入或輸出。積體電路是依據閘的數量來分類的</p><ul><li>SSI（小型積體電路）<i class="fa fa-arrow-right"></i> 1~10</li><li>MSI（中型積體電路）<i class="fa fa-arrow-right"></i> 10~100</li><li>LSI（大型積體電路）<i class="fa fa-arrow-right"></i> 100~100,000</li><li>VLSI（超大型積體電路 <i class="fa fa-arrow-right"></i> 100,000 <i class="fa fa-arrow-up"></i></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
            <tag> 邏輯閘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 資料表示法</title>
      <link href="/posts/ItC/data.html"/>
      <url>/posts/ItC/data.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="資料與電腦">資料與電腦<a class="header-anchor" href="#資料與電腦">#</a></h2><ul><li>資料 data：事實的基本數值。</li><li>資訊 infromation：經過組織、處理過的資料。</li></ul><h3 id="資料壓縮-data-compression">資料壓縮 data compression<a class="header-anchor" href="#資料壓縮-data-compression">#</a></h3><ul><li>壓縮率 compression ration：壓縮過後的大小 / 原始大小，介於 0 與 1 之間，越接近 0 代表壓縮越緊密。</li><li>資料壓縮技術分為兩種：<ul><li>無漏失型 lossless：指經過壓縮後無原始資料流失。</li><li>漏失型 lossy：指資料壓縮後有資料會漏失。</li></ul></li></ul><ol><li>類比資料 analog data：連續的，較類似實際資訊</li><li>數位資料 digital data：不連續的。</li><li>數位化 digitize：由類比轉成數位。</li></ol><h2 id="位置表示法">位置表示法<a class="header-anchor" href="#位置表示法">#</a></h2><blockquote><p>基底 base：由 0 開始，等於基底時進位。</p></blockquote><h3 id="位置表示法-positional-notation">位置表示法 positional notation<a class="header-anchor" href="#位置表示法-positional-notation">#</a></h3><p>base R，位元數為 n，di →第 i 個位元，則公式為：<br>$${d_nR<sup>{n-1}+d_{n-1}R</sup>{n-2}+···+d_2R+d_1}$$</p><h3 id="二進位與八進位">二進位與八進位<a class="header-anchor" href="#二進位與八進位">#</a></h3><ul><li>只要分別知道各個位元在另外一個進制的表示法，合起來即是其數值在另一個進制的表示法。</li><li>如：754(base 8)中 7(111)、5(101)、4(100)，則 111101100(base 2) == 754(base 8)。</li><li>每一個儲存單元稱為二進制數元 binary digit，或簡稱位元 bit。</li><li>8 個 bit 組合成位元組 bytes，bytes 組合成字組 words。</li></ul><h3 id="二進製表示法">二進製表示法<a class="header-anchor" href="#二進製表示法">#</a></h3><p>一個位元可表示兩件事（ 0 或是 1 ），如：會下雨、不會下雨；當需要表示超過兩件事時，就需要多重位元，兩個位元可表示四件事（ 00, 01, 10, 11 ）… 以此類推。</p><hr><h2 id="數字資料的表示">數字資料的表示<a class="header-anchor" href="#數字資料的表示">#</a></h2><h3 id="負數的表示">負數的表示<a class="header-anchor" href="#負數的表示">#</a></h3><ol><li>帶號 — 數量表示法 singed-magintude representation<br>即日常身活中，常常使用的表示法；概念為，負數在 0 的左邊，正數在 0 的右邊；表示為，將符號（+,−）放在數字的前面，通常正號省略，即：5、-1、10、0 (忽略 -0）……<ul><li>計算方法：加法為：將前數往右移後數的數量，若為負數則往左；減法為：將前數往左移後數的數量，若為負數則往右。</li></ul></li><li>固定大小數字表示法<br>如果我們固定數字總量的位元數，則我們有以下的表示法。<ol><li>十的補數 ten’s complement<br>假設固定位元數 == 2，則我們可以用 $0 \sim 49$ 來表示 $0 \sim 49$ 的正值，用 $50 \sim 99$ 來表示 $-50 \sim -1$ ，則無論加減法都用表示值做運算即可，如：$-2+1$ 可寫成 $98+1 = 99$，即 $-1$。<ul><li>公式：負數 $I = 10^k − I$，其中 k 為數元的數目。</li></ul></li><li>二的補數<br>假定數元數 == 8，則一個二進位的數，最左邊的值代表著符號，1 為負、0 為正，例如：00000010 為 10 進位的 2，11111110 為10 進位的 -2。<ul><li>公式：負數 $I = 2^k − I$，其中 k 為數元的數目。</li><li>計算：如何計算一個負數 I 利用二的補數求得的二進位值，則有以下步驟：<br>將負數 I 取絕對值，求得其二進位值。<br>將其值反相，並加ㄧ，求得答案。<br>如：-2，其絕對值的二進位為 00000010，反相：11111101，並加ㄧ，則答案為 11111110。</li></ul></li></ol></li></ol><h3 id="實數的表示">實數的表示<a class="header-anchor" href="#實數的表示">#</a></h3><ul><li>在電腦中，可被表示為非整數值稱作實數，即可寫成帶有小數的。<ul><li>基數點 radix point ：即 base 10 的小數點，在任意基底中稱作基數點。</li><li>浮點 floating point：即利用基數點浮動的方式來表示實數，公式為<br>$符號 \times 假數 \times 基底^{指數}$<br>其中假數為未加上基數點的數，指數則決定了基數點要浮動至哪裡，如指數為正，代表基數點右移，反之亦然。<br>例：$146.654$ 可表示為 $146654 * 10^{-3}$。</li></ul></li><li>十進位小數轉換為二進位的方法：不斷乘以 2 直到其值為 0，取每次計算過程中，基數點左邊第一位。<br>例：$.75 → .11$<br>$<br>\begin{equation}\begin{split}<br>.75 \times 2 = 1.50\\<br>.50 \times 2 = 1.00\\<br>\end{split}\end{equation}<br>$</li></ul><hr><h2 id="文字的表示">文字的表示<a class="header-anchor" href="#文字的表示">#</a></h2><ul><li>字元集 character set：即字元表單，用碼來紀錄字元。<ul><li>ASCII 字元集<br>最初用 7 個位元表示每個字元，第八個位元為檢查位元，可協助電腦檢查資料正確性，之後演變成八個位元全部用來表示字元。</li><li>Unicode 字元集<br>為了表示所有語言而誕生，ASCII 為此集的子集。</li></ul></li></ul><h3 id="文字的壓縮">文字的壓縮<a class="header-anchor" href="#文字的壓縮">#</a></h3><ol><li>關鍵字編碼：將一些常用的單詞以單一位元的符號取代，如：as → ^<ul><li>限制：使用的符號不可為原始文字的一部份，如欲壓縮一份菜單，則不可以用 $ 來代替任何單詞。</li><li>延伸：取代的為文字的樣式，如 ing、tion 等。缺點為，短樣式，節省的空間不多。</li></ul></li><li>遊程長度編碼：某些情況下，某一字元可能會不斷的重複，則可用此編碼，如：AAAAAAA → *A7，其中 * 稱作旗標字元 flag character，7 為重複的數量。</li><li>霍夫曼編碼：將常用的字元以短位元的字串表示，如 A → 00、E → 01。此編碼有一個重要的特徵為，沒有一個字串是另一個字串的開頭，即我們用 01 表示 O 後，不會有任何一個字元被表示為 0110，事實上任何用 01 開頭的字串接不會出現。</li></ol><hr><h2 id="音訊資料的表示">音訊資料的表示<a class="header-anchor" href="#音訊資料的表示">#</a></h2><p>要在電腦上表示聲音，須將聲波數位化，也就是將聲波以電子訊號表示，為一系列不連續的數值。<br>類比訊號是以電壓來做連續變動，要將訊號數位化，則必須週期的測量電壓，記錄其值，這個過程稱作取樣 sampling。</p><ul><li>乙烯基錄音唱片（黑膠）：為一種聲波的類比表示法，記錄播放器的唱針延唱片的螺旋上升及下降，類似於電壓的變化。</li><li>光碟片 CD：為數位的表示法，低強度的雷射光瞄準碟片，反射至感知器，如表面平坦，則會強烈反射，如有凹坑，則反射減弱；藉此分析結果，產生二進位資料。</li></ul><h3 id="音訊格式">音訊格式<a class="header-anchor" href="#音訊格式">#</a></h3><ul><li>MP3<br>為 MPEG-2 音訊第三層檔案的縮寫，MPEG Moving Picture Experts Group，為一個發展數位音訊與視訊壓縮的委員會。<br>MP3 使用了漏失與非漏失型兩種方式壓縮，分析實際聲音與人類心理聲音的關係之數學模型做比較，並丟棄人類無法聽到的資訊，最後用霍夫曼編碼的形式壓縮。</li></ul><hr><h2 id="影像與圖形的表示">影像與圖形的表示<a class="header-anchor" href="#影像與圖形的表示">#</a></h2><h3 id="顏色的表示">顏色的表示<a class="header-anchor" href="#顏色的表示">#</a></h3><ul><li>電腦以 RGB 來表示，其中實際的數值代表主要顏色的相對貢獻度。<ul><li>顏色深度 color depth：通常以位元數來表示。</li><li>高彩 HiColor：表示16位元的顏色深度，其中5個位元用來表示每一個RGB值，其餘位元有時表示透明度 transparency。</li><li>全彩 TureColor：表示24位元的顏色深度，每一個RGB值用8個位元。</li></ul></li><li>影樣及圖形數位化<ul><li>像素 pixels：圖形數位化是透過聚集個別點來表示圖像，此個別點稱作像素。一個像素是由一種單一顏色組成。</li><li>解析度 resolution：代表圖像的像素數目。</li></ul></li></ul><h3 id="光柵圖形格式">光柵圖形格式<a class="header-anchor" href="#光柵圖形格式">#</a></h3><p>以一個像素接著一個的圖形稱作光柵圖形格式，如：JPG、BMP 等。</p><h3 id="圖形向量表示法">圖形向量表示法<a class="header-anchor" href="#圖形向量表示法">#</a></h3><p>為另一種影像表示法，以線條及幾何形狀來描述圖像。</p><hr><h2 id="視訊的表示">視訊的表示<a class="header-anchor" href="#視訊的表示">#</a></h2><ul><li>codec 壓縮/解壓縮器</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計概 - 簡介</title>
      <link href="/posts/ItC/intro.html"/>
      <url>/posts/ItC/intro.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="電腦系統">電腦系統<a class="header-anchor" href="#電腦系統">#</a></h2><blockquote><p>電腦系統如洋蔥由許多層組成，由內而外為：<br>資訊 <i class="fa fa-arrow-right"></i> 硬體 <i class="fa fa-arrow-right"></i> 程式設計 <i class="fa fa-arrow-right"></i> 作業系統 <i class="fa fa-arrow-right"></i> 應用  <i class="fa fa-arrow-right"></i> 通訊。</p></blockquote><ol><li>資訊層（最內層）：對應電腦內資訊的表示方式，為純概念層；電腦上的資訊用2進位來管理。</li><li>硬體層：電腦系統中的實體硬體，包括邏輯閘、控制電流的電路等。</li><li>程式設計層：處理軟體及指令。</li><li>OS：OS協助管理電腦資源、協助我們和電腦互動，以及管理硬體、軟體、資料互動的方式。</li><li>應用：前面幾層聚焦在讓電腦工作（內部），此層聚焦在真實世界的問題，如遊戲、設計等。</li><li>通訊：透過網際網路分享資訊、資源。</li></ol><hr><h2 id="電腦歷史">電腦歷史<a class="header-anchor" href="#電腦歷史">#</a></h2><h3 id="硬體">硬體<a class="header-anchor" href="#硬體">#</a></h3><ul><li>真空管  <i class="fa fa-arrow-right"></i> 電晶體  <i class="fa fa-arrow-right"></i> 積體電路(IC)  <i class="fa fa-arrow-right"></i> 大型積體電路</li></ul><h3 id="軟體">軟體<a class="header-anchor" href="#軟體">#</a></h3><ol><li>機械語言</li><li>協助開發機械語言而發展出組合語言，此語言需要被翻譯為機械語言才可使用，因此「組譯器 assemblers」誕生了。</li><li>高階語言允許以英文的陳述句來撰寫指令，每一個不同的高階語言需要不同的翻譯程式，稱作「編譯器 compiler」。</li><li>OS可決定程式何時執行。</li><li>結構化程式設計</li><li>OOP</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 計算機概論 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 計算機概論 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
